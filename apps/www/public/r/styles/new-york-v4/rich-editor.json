{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "rich-editor",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion",
    "lucide-react",
    "sonner",
    "color",
    "next-themes",
    "clsx",
    "tailwind-merge",
    "@radix-ui/react-popover",
    "@radix-ui/react-dialog",
    "@radix-ui/react-dropdown-menu",
    "@radix-ui/react-context-menu",
    "@radix-ui/react-select",
    "@radix-ui/react-switch",
    "@radix-ui/react-slider",
    "@radix-ui/react-separator",
    "@radix-ui/react-scroll-area",
    "@radix-ui/react-slot"
  ],
  "registryDependencies": [
    "button",
    "button-group",
    "card",
    "checkbox",
    "command",
    "context-menu",
    "dialog",
    "input",
    "label",
    "popover",
    "scroll-area",
    "select",
    "separator",
    "sheet",
    "skeleton",
    "switch",
    "tabs",
    "textarea",
    "toggle-group",
    "tooltip"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/ui/rich-editor/index.ts",
      "content": "/**\n * Mina Rich Editor\n *\n * A flexible, TypeScript-first rich text editor library built with React.\n * Features a JSON-based document model, immutable state management,\n * and extensible plugin architecture.\n *\n * @packageDocumentation\n *\n * @example Basic Usage\n * ```tsx\n * import { EditorProvider, useEditor, EditorActions } from 'mina-rich-editor';\n *\n * function App() {\n *   return (\n *     <EditorProvider>\n *       <MyEditor />\n *     </EditorProvider>\n *   );\n * }\n *\n * function MyEditor() {\n *   const [state, dispatch] = useEditor();\n *\n *   const addParagraph = () => {\n *     dispatch(EditorActions.insertNode(\n *       { id: 'p-new', type: 'p', content: 'Hello!' },\n *       state.container.id,\n *       'append'\n *     ));\n *   };\n *\n *   return <button onClick={addParagraph}>Add Paragraph</button>;\n * }\n * ```\n */\n\n// ============================================================================\n// Types and Interfaces\n// ============================================================================\nexport type {\n  NodeType,\n  NodeAttributes,\n  BaseNode,\n  TextNode,\n  ContainerNode,\n  StructuralNode,\n  EditorNode,\n  EditorState,\n  SelectionInfo,\n  InlineText,\n  BlockLine,\n} from \"./types\"\n\nexport {\n  isContainerNode,\n  isStructuralNode,\n  isTextNode,\n  hasInlineChildren,\n  getNodeTextContent,\n} from \"./types\"\n\n// ============================================================================\n// Actions\n// ============================================================================\nexport type {\n  UpdateNodeAction,\n  UpdateAttributesAction,\n  UpdateContentAction,\n  DeleteNodeAction,\n  InsertNodeAction,\n  MoveNodeAction,\n  DuplicateNodeAction,\n  ReplaceContainerAction,\n  ResetAction,\n  BatchAction,\n  EditorAction,\n} from \"./reducer/actions\"\n\nexport { EditorActions } from \"./reducer/actions\"\n\n// ============================================================================\n// Reducer\n// ============================================================================\nexport { editorReducer, createInitialState } from \"./reducer/editor-reducer\"\n\n// ============================================================================\n// Context and Hooks\n// ============================================================================\nexport {\n  EditorProvider,\n  useEditorState,\n  useEditorDispatch,\n  useEditor,\n  useEditorSelector,\n  useNode,\n  useSelectionManager,\n  useSelection,\n} from \"./context/editor-context\"\n\nexport type { EditorProviderProps } from \"./context/editor-context\"\n\n// ============================================================================\n// Utilities\n// ============================================================================\nexport {\n  findNodeById,\n  findParentById,\n  updateNodeById,\n  deleteNodeById,\n  insertNode,\n  moveNode,\n  cloneNode,\n  traverseTree,\n  validateTree,\n} from \"./utils/tree-operations\"\n\nexport type { InsertPosition } from \"./utils/tree-operations\"\n\nexport {\n  splitTextAtSelection,\n  convertToInlineFormat,\n  applyFormatting,\n  removeFormatting,\n  mergeAdjacentTextNodes,\n  getFormattingAtPosition,\n} from \"./utils/inline-formatting\"\n\nexport {\n  serializeToHtml,\n  serializeToHtmlFragment,\n  serializeToHtmlWithClass,\n} from \"./utils/serialize-to-html\"\n\nexport {\n  parseMarkdownTable,\n  isMarkdownTable,\n} from \"./utils/markdown-table-parser\"\n\nexport {\n  setupDragAutoScroll,\n  useDragAutoScroll,\n} from \"./utils/drag-auto-scroll\"\n\nexport type { AutoScrollConfig } from \"./utils/drag-auto-scroll\"\n\n// ============================================================================\n// Tailwind Classes Utilities\n// ============================================================================\nexport {\n  tailwindClasses,\n  popularClasses,\n  searchTailwindClasses,\n  getAllClasses,\n} from \"./tailwind-classes\"\n\nexport type { TailwindClassGroup } from \"./tailwind-classes\"\n\n// ============================================================================\n// Demo Content\n// ============================================================================\nexport { createDemoContent } from \"./demo-content\"\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/types.ts",
      "content": "/**\n * Mina Rich Editor - Core Type Definitions\n *\n * A flexible, type-safe document model for building rich text editors.\n * Supports nested containers, various node types, and dynamic attributes.\n *\n * @packageDocumentation\n */\n\n/**\n * Supported node types for the editor.\n * Can be extended for custom node types via plugins.\n */\nexport type NodeType =\n  | \"h1\"\n  | \"h2\"\n  | \"h3\"\n  | \"h4\"\n  | \"h5\"\n  | \"h6\"\n  | \"p\"\n  | \"blockquote\"\n  | \"ul\"\n  | \"ol\"\n  | \"li\"\n  | \"code\"\n  | \"pre\"\n  | \"img\"\n  | \"video\"\n  | \"audio\"\n  | \"a\"\n  | \"span\"\n  | \"div\"\n  | \"hr\"\n  | \"br\"\n  | \"table\"\n  | \"thead\"\n  | \"tbody\"\n  | \"tr\"\n  | \"th\"\n  | \"td\"\n  | \"container\"\n  | \"text\"\n\n/**\n * Dynamic attributes that can be attached to any node.\n * Allows for custom styling, classes, data attributes, etc.\n *\n * Special formatting attributes:\n * - bold: boolean - makes text bold\n * - italic: boolean - makes text italic\n * - underline: boolean - makes text underlined\n *\n * @example\n * ```typescript\n * const attributes: NodeAttributes = {\n *   bold: true,\n *   italic: true,\n *   className: 'text-blue-500',\n *   href: 'https://example.com',\n * };\n * ```\n */\nexport interface NodeAttributes {\n  bold?: boolean\n  italic?: boolean\n  underline?: boolean\n  [key: string]: string | number | boolean | undefined\n}\n\n/**\n * Base interface for all editor nodes.\n * Every node must have an id, type, and attributes.\n */\nexport interface BaseNode {\n  /** Unique identifier for the node (used for updates, deletion, etc.) */\n  id: string\n\n  /** The type of node (h1, p, img, container, etc.) */\n  type: NodeType\n\n  /** Dynamic attributes (className, style, href, src, etc.) */\n  attributes?: NodeAttributes\n}\n\n/**\n * Inline text segment with its own formatting\n */\nexport interface InlineText {\n  content: string\n  bold?: boolean\n  italic?: boolean\n  underline?: boolean\n  // Inline element type (for text that should render as p, h1, h2, etc. within a paragraph)\n  elementType?:\n    | \"p\"\n    | \"h1\"\n    | \"h2\"\n    | \"h3\"\n    | \"h4\"\n    | \"h5\"\n    | \"h6\"\n    | \"code\"\n    | \"blockquote\"\n  // Link URL (makes the text a clickable link)\n  href?: string\n  // Custom Tailwind CSS classes\n  className?: string\n  // Inline CSS styles (e.g., { fontSize: '24px', color: '#ff0000' })\n  styles?: Record<string, string>\n}\n\n/**\n * A single line of content within a block.\n * Can contain either plain text or inline formatted children.\n */\nexport interface BlockLine {\n  /** Plain text content (if no formatting) */\n  content?: string\n  /** Inline children with formatting */\n  children?: InlineText[]\n}\n\n/**\n * Text content node - represents actual content/text.\n * Can be simple text, have inline children with formatting, OR have multiple lines.\n *\n * @example Simple text (no formatting):\n * ```typescript\n * const textNode: TextNode = {\n *   id: 'p-1',\n *   type: 'p',\n *   content: 'Hello, world!',\n * };\n * ```\n *\n * @example Block with inline children (rich formatting):\n * ```typescript\n * const paragraph: TextNode = {\n *   id: 'p-1',\n *   type: 'p',\n *   children: [\n *     { content: 'Hello ', bold: false },\n *     { content: 'world', bold: true },\n *     { content: '!', bold: false }\n *   ]\n * };\n * ```\n *\n * @example Block with multiple lines (e.g., ordered list):\n * ```typescript\n * const listItem: TextNode = {\n *   id: 'li-1',\n *   type: 'li',\n *   lines: [\n *     { content: 'First item' },\n *     { content: 'Second item' },\n *     { content: 'Third item' }\n *   ]\n * };\n * ```\n */\nexport interface TextNode extends BaseNode {\n  type: Exclude<NodeType, \"container\">\n\n  /** The actual text content (used when no inline formatting and single line) */\n  content?: string\n\n  /** Inline children with individual formatting (used for rich text, single line) */\n  children?: InlineText[]\n\n  /** Multiple lines of content (used for multi-line blocks like ordered lists) */\n  lines?: BlockLine[]\n}\n\n/**\n * Container node - can have children nodes (nested structure).\n * Allows building complex document trees.\n *\n * @example\n * ```typescript\n * const container: ContainerNode = {\n *   id: 'root',\n *   type: 'container',\n *   children: [\n *     { id: 'h1-1', type: 'h1', content: 'Title' },\n *     { id: 'p-1', type: 'p', content: 'Paragraph' },\n *     {\n *       id: 'nested',\n *       type: 'container',\n *       children: [...]\n *     }\n *   ]\n * };\n * ```\n */\nexport interface ContainerNode extends BaseNode {\n  type: \"container\"\n\n  /** Child nodes (can be TextNode or ContainerNode) */\n  children: EditorNode[]\n}\n\n/**\n * Structural node - similar to container but for specific structures like tables\n * Can have children nodes for table elements (thead, tbody, tr)\n */\nexport interface StructuralNode extends BaseNode {\n  type: \"table\" | \"thead\" | \"tbody\" | \"tr\"\n\n  /** Child nodes */\n  children: EditorNode[]\n}\n\n/**\n * Union type representing any node in the editor.\n */\nexport type EditorNode = TextNode | ContainerNode | StructuralNode\n\n/**\n * Information about the current text selection\n */\nexport interface SelectionInfo {\n  /** The selected text */\n  text: string\n\n  /** Start position in the text content */\n  start: number\n\n  /** End position in the text content */\n  end: number\n\n  /** ID of the node containing the selection */\n  nodeId: string\n\n  /** Active formatting styles on the selection */\n  formats: {\n    bold: boolean\n    italic: boolean\n    underline: boolean\n  }\n\n  /** Active element type on the selection (if all selected text has the same type) */\n  elementType?:\n    | \"p\"\n    | \"h1\"\n    | \"h2\"\n    | \"h3\"\n    | \"h4\"\n    | \"h5\"\n    | \"h6\"\n    | \"code\"\n    | \"blockquote\"\n    | null\n\n  /** Active link href on the selection (if all selected text has the same href) */\n  href?: string | null\n\n  /** Active custom class on the selection (if all selected text has the same class) */\n  className?: string | null\n\n  /** Active inline styles on the selection (if all selected text has the same styles) */\n  styles?: Record<string, string> | null\n}\n\n/**\n * The root document state for the editor.\n * Contains metadata, the root container, UI state, and history for undo/redo.\n */\nexport interface EditorState {\n  /** Schema version for future migrations */\n  version: string\n\n  /** History stack of container states for undo/redo */\n  history: ContainerNode[]\n\n  /** Current position in the history stack */\n  historyIndex: number\n\n  /** Currently active/focused node ID */\n  activeNodeId: string | null\n\n  /** Whether there is an active text selection */\n  hasSelection: boolean\n\n  /** Selection key to trigger re-renders when selection changes */\n  selectionKey: number\n\n  /** Current selection information (null if no selection) */\n  currentSelection: SelectionInfo | null\n\n  /** Set of block IDs that are currently selected (for multi-block operations like Ctrl+A) */\n  selectedBlocks: Set<string>\n\n  /** Optional metadata (created date, last modified, author, etc.) */\n  metadata?: {\n    createdAt?: string\n    updatedAt?: string\n    [key: string]: any\n  }\n}\n\n/**\n * Type guard to check if a node is a ContainerNode.\n *\n * @param node - The node to check\n * @returns True if node is a ContainerNode\n *\n * @example\n * ```typescript\n * if (isContainerNode(node)) {\n *   console.log(node.children.length);\n * }\n * ```\n */\nexport function isContainerNode(node: EditorNode): node is ContainerNode {\n  return node.type === \"container\"\n}\n\n/**\n * Type guard to check if a node is a StructuralNode (table, thead, tbody, tr).\n *\n * @param node - The node to check\n * @returns True if node is a StructuralNode\n */\nexport function isStructuralNode(node: EditorNode): node is StructuralNode {\n  return (\n    node.type === \"table\" ||\n    node.type === \"thead\" ||\n    node.type === \"tbody\" ||\n    node.type === \"tr\"\n  )\n}\n\n/**\n * Type guard to check if a node is a TextNode.\n *\n * @param node - The node to check\n * @returns True if node is a TextNode\n *\n * @example\n * ```typescript\n * if (isTextNode(node)) {\n *   console.log(node.content);\n * }\n * ```\n */\nexport function isTextNode(node: EditorNode): node is TextNode {\n  return node.type !== \"container\" && !isStructuralNode(node)\n}\n\n/**\n * Type guard to check if a node has inline children (rich text).\n *\n * @param node - The node to check\n * @returns True if node has inline children\n *\n * @example\n * ```typescript\n * if (hasInlineChildren(node)) {\n *   console.log(node.children); // Array of inline text segments\n * }\n * ```\n */\nexport function hasInlineChildren(\n  node: EditorNode\n): node is TextNode & { children: InlineText[] } {\n  return (\n    isTextNode(node) &&\n    Array.isArray((node as TextNode).children) &&\n    (node as TextNode).children!.length > 0\n  )\n}\n\n/**\n * Get the text content of a node (whether simple or with inline children).\n *\n * @param node - The node to extract text from\n * @returns The full text content\n *\n * @example\n * ```typescript\n * const text = getNodeTextContent(node); // \"Hello world!\"\n * ```\n */\nexport function getNodeTextContent(node: TextNode): string {\n  // If node has multiple lines, join them with newlines\n  if (node.lines && node.lines.length > 0) {\n    return node.lines\n      .map((line) => {\n        if (line.children && line.children.length > 0) {\n          return line.children.map((child) => child.content).join(\"\")\n        }\n        return line.content || \"\"\n      })\n      .join(\"\\n\")\n  }\n\n  // If node has inline children (single line with formatting)\n  if (hasInlineChildren(node)) {\n    return node.children!.map((child) => child.content).join(\"\")\n  }\n\n  // Simple content (single line, no formatting)\n  return node.content || \"\"\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/editor.tsx",
      "content": "/**\n * Mina Rich Editor - Clean Version\n *\n * A minimal editor demonstrating text formatting with our CRUD system.\n * Focus on: Select text → Click format button → Update via reducer\n *\n * CLEAN VERSION - All handlers extracted to separate modules\n */\n\n\"use client\"\n\nimport React, { useCallback, useEffect, useRef, useState } from \"react\"\n\nimport { Card, CardContent } from \"../card\"\nimport { AddBlockButton } from \"./add-block-button\"\nimport { Block } from \"./block\"\nimport { CustomClassPopover } from \"./custom-class-popover\"\nimport { EditorToolbar } from \"./editor-toolbar\"\nimport { GroupImagesButton } from \"./group-images-button\"\nimport {\n  createHandleBlockDragStart,\n  createHandleDragEnter,\n  createHandleDragLeave,\n  createHandleDragOver,\n  createHandleDrop,\n  createHandleImageDragStart,\n} from \"./handlers/drag-drop-handlers\"\nimport {\n  createHandleFileChange,\n  createHandleImageUploadClick,\n  createHandleMultipleFilesChange,\n  createHandleMultipleImagesUploadClick,\n} from \"./handlers/file-upload-handlers\"\nimport {\n  createHandleFlexContainerDragLeave,\n  createHandleFlexContainerDragOver,\n  createHandleFlexContainerDrop,\n} from \"./handlers/flex-container-handlers\"\nimport {\n  checkImagesInSameFlex,\n  createHandleClearImageSelection,\n  createHandleExtractFromFlex,\n  createHandleGroupSelectedImages,\n  createHandleReverseImagesInFlex,\n  createHandleToggleImageSelection,\n} from \"./handlers/image-selection-handlers\"\nimport {\n  createHandleClickWithModifier,\n  createHandleContentChange,\n  createHandleKeyDown,\n} from \"./handlers/keyboard-handlers\"\nimport {\n  createHandleAddBlock,\n  createHandleChangeBlockType,\n  createHandleCopyHtml,\n  createHandleCopyJson,\n  createHandleCreateLink,\n  createHandleCreateList,\n  createHandleCreateListFromCommand,\n  createHandleCreateNested,\n  createHandleCreateTable,\n  createHandleDeleteNode,\n  createHandleInsertImageFromCommand,\n  createHandleNodeClick,\n} from \"./handlers/node-operation-handlers\"\n// Import all handlers\nimport {\n  createHandleApplyColor,\n  createHandleApplyFontSize,\n  createHandleFormat,\n  createHandleSelectionChange,\n  createHandleTypeChange,\n} from \"./handlers/selection-handlers\"\nimport { useToast } from \"./hooks/use-toast\"\nimport {\n  ContainerNode,\n  EditorActions,\n  findNodeById,\n  getNodeTextContent,\n  hasInlineChildren,\n  isContainerNode,\n  isTextNode,\n  serializeToHtml,\n  useEditor,\n  useSelection,\n  useSelectionManager,\n  type EditorNode,\n  type EditorState,\n  type SelectionInfo,\n  type TextNode,\n} from \"./index\"\nimport { LinkPopover } from \"./link-popover\"\nimport { TableBuilder } from \"./table-builder\"\nimport { TableDialog } from \"./table-dialog\"\nimport { useDragAutoScroll } from \"./utils/drag-auto-scroll\"\n\n/**\n * Editor Component Props\n */\ninterface EditorProps {\n  readOnly?: boolean // View-only mode - renders content without editing capabilities\n  onUploadImage?: (file: File) => Promise<string> // Custom image upload handler - should return the uploaded image URL\n}\n\nexport function Editor({\n  readOnly: initialReadOnly = false,\n  onUploadImage,\n}: EditorProps = {}) {\n  const [state, dispatch] = useEditor()\n  const selectionManager = useSelectionManager()\n  const { toast } = useToast()\n  const lastEnterTime = useRef<number>(0)\n  const nodeRefs = useRef<Map<string, HTMLElement>>(new Map())\n  const contentUpdateTimers = useRef<Map<string, NodeJS.Timeout>>(new Map())\n  const fileInputRef = useRef<HTMLInputElement>(null)\n  const multipleFileInputRef = useRef<HTMLInputElement>(null)\n  const editorContentRef = useRef<HTMLDivElement>(null)\n  const [readOnly, setReadOnly] = useState(initialReadOnly)\n\n  // Enable auto-scroll when dragging near viewport edges\n  useDragAutoScroll(editorContentRef, {\n    scrollZone: 100,\n    scrollSpeed: 15,\n    enableVertical: true,\n    enableHorizontal: false,\n  })\n\n  const [isUploading, setIsUploading] = useState(false)\n  const [copiedHtml, setCopiedHtml] = useState(false)\n  const [copiedJson, setCopiedJson] = useState(false)\n  const [enhanceSpaces, setEnhanceSpaces] = useState(true)\n  const [dragOverNodeId, setDragOverNodeId] = useState<string | null>(null)\n  const [dropPosition, setDropPosition] = useState<\n    \"before\" | \"after\" | \"left\" | \"right\" | null\n  >(null)\n  const [draggingNodeId, setDraggingNodeId] = useState<string | null>(null)\n  const [selectedColor, setSelectedColor] = useState<string>(\"\")\n  const [selectedImageIds, setSelectedImageIds] = useState<Set<string>>(\n    new Set()\n  )\n  const [dragOverFlexId, setDragOverFlexId] = useState<string | null>(null)\n  const [flexDropPosition, setFlexDropPosition] = useState<\n    \"left\" | \"right\" | null\n  >(null)\n  const [tableDialogOpen, setTableDialogOpen] = useState(false)\n\n  // Get the current container from history\n  const container = state.history[state.historyIndex]\n\n  const currentNode = state.activeNodeId\n    ? (container.children.find(\n        (n: EditorNode) => n.id === state.activeNodeId\n      ) as TextNode | undefined)\n    : (container.children[0] as TextNode | undefined)\n\n  // Debounced dispatch for selection state updates\n  const selectionDispatchTimerRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Create handler parameters\n  const selectionParams = {\n    container,\n    state,\n    dispatch,\n    selectionManager,\n    nodeRefs,\n  }\n\n  // keyboardParams will be created dynamically with the handlers\n\n  const nodeOperationParams = {\n    container,\n    dispatch,\n    toast,\n    nodeRefs,\n    editorContentRef,\n  }\n\n  const dragDropParams = {\n    container,\n    dispatch,\n    toast,\n    draggingNodeId,\n    setDraggingNodeId,\n    setDragOverNodeId,\n    setDropPosition,\n    setIsUploading,\n    onUploadImage,\n  }\n\n  const fileUploadParams = {\n    container,\n    dispatch,\n    state,\n    toast,\n    setIsUploading,\n    fileInputRef,\n    multipleFileInputRef,\n    onUploadImage,\n  }\n\n  // Create all handlers\n  const handleSelectionChange = useCallback(\n    createHandleSelectionChange(selectionParams, selectionDispatchTimerRef),\n    [container, state.activeNodeId, selectionManager, dispatch]\n  )\n\n  const handleFormat = useCallback(createHandleFormat(selectionParams), [\n    container,\n    dispatch,\n    selectionManager,\n  ])\n\n  const handleApplyColor = useCallback(\n    createHandleApplyColor(selectionParams, toast, setSelectedColor),\n    [dispatch, selectionManager, toast]\n  )\n\n  const handleApplyFontSize = useCallback(\n    createHandleApplyFontSize(selectionParams, toast),\n    [dispatch, selectionManager, toast]\n  )\n\n  const handleTypeChange = useCallback(\n    createHandleTypeChange(selectionParams, currentNode, handleSelectionChange),\n    [currentNode, dispatch, selectionManager, handleSelectionChange]\n  )\n\n  const handleToggleImageSelection = useCallback(\n    createHandleToggleImageSelection(selectedImageIds, setSelectedImageIds),\n    [selectedImageIds]\n  )\n\n  const handleContentChange = useCallback(\n    createHandleContentChange(\n      {\n        container,\n        dispatch,\n        nodeRefs,\n        lastEnterTime,\n        onToggleImageSelection: handleToggleImageSelection,\n      },\n      contentUpdateTimers\n    ),\n    [container, dispatch, handleToggleImageSelection]\n  )\n\n  const handleKeyDown = useCallback(\n    createHandleKeyDown({\n      container,\n      dispatch,\n      nodeRefs,\n      lastEnterTime,\n      onToggleImageSelection: handleToggleImageSelection,\n    }),\n    [container, dispatch, nodeRefs, lastEnterTime, handleToggleImageSelection]\n  )\n\n  const handleClickWithModifier = useCallback(\n    createHandleClickWithModifier({\n      container,\n      dispatch,\n      nodeRefs,\n      lastEnterTime,\n      onToggleImageSelection: handleToggleImageSelection,\n    }),\n    [container, handleToggleImageSelection]\n  )\n\n  const handleNodeClick = useCallback(\n    createHandleNodeClick({ container, dispatch }),\n    [container, dispatch]\n  )\n\n  const handleDeleteNode = useCallback(\n    createHandleDeleteNode({ container, dispatch, toast }),\n    [container, dispatch, toast]\n  )\n\n  const handleAddBlock = useCallback(\n    createHandleAddBlock({ dispatch, nodeRefs }),\n    [dispatch, nodeRefs]\n  )\n\n  const handleCreateNested = useCallback(\n    createHandleCreateNested({ container, dispatch, toast }),\n    [container, dispatch, toast]\n  )\n\n  const handleChangeBlockType = useCallback(\n    createHandleChangeBlockType({ dispatch, nodeRefs }),\n    [dispatch, nodeRefs]\n  )\n\n  const handleInsertImageFromCommand = useCallback(\n    createHandleInsertImageFromCommand({ dispatch, nodeRefs }, fileInputRef),\n    [dispatch, fileInputRef]\n  )\n\n  const handleCreateList = useCallback(\n    createHandleCreateList(nodeOperationParams),\n    [container, dispatch, toast, editorContentRef]\n  )\n\n  const handleCreateListFromCommand = useCallback(\n    createHandleCreateListFromCommand({ dispatch, toast, nodeRefs }),\n    [dispatch, toast, nodeRefs]\n  )\n\n  const handleCreateLink = useCallback(\n    createHandleCreateLink(nodeOperationParams),\n    [container, dispatch, toast, editorContentRef]\n  )\n\n  const handleCreateTable = useCallback(\n    createHandleCreateTable(nodeOperationParams),\n    [container, dispatch, toast, editorContentRef]\n  )\n\n  const handleImportMarkdownTable = useCallback(\n    (table: any) => {\n      const timestamp = Date.now()\n\n      // Wrap table in a container for consistent handling\n      const tableWrapper: ContainerNode = {\n        id: `table-wrapper-${timestamp}`,\n        type: \"container\",\n        children: [table],\n        attributes: {},\n      }\n\n      // Insert the table at the end\n      const lastNode = container.children[container.children.length - 1]\n      if (lastNode) {\n        dispatch(EditorActions.insertNode(tableWrapper, lastNode.id, \"after\"))\n      } else {\n        // If no nodes exist, replace the container\n        dispatch(\n          EditorActions.replaceContainer({\n            ...container,\n            children: [tableWrapper],\n          })\n        )\n      }\n\n      toast({\n        title: \"Table Imported\",\n        description: \"Markdown table has been imported successfully\",\n      })\n\n      // Smooth scroll to the newly created table\n      setTimeout(() => {\n        const editorContent = editorContentRef.current\n        if (editorContent) {\n          const lastChild = editorContent.querySelector(\n            \"[data-editor-content]\"\n          )?.lastElementChild\n          if (lastChild) {\n            lastChild.scrollIntoView({\n              behavior: \"smooth\",\n              block: \"end\",\n              inline: \"nearest\",\n            })\n          }\n        }\n      }, 150)\n    },\n    [container, dispatch, toast, editorContentRef]\n  )\n\n  const handleCopyHtml = useCallback(\n    () =>\n      createHandleCopyHtml({ toast }, enhanceSpaces, setCopiedHtml)(container),\n    [container, enhanceSpaces, toast]\n  )\n\n  const handleCopyJson = useCallback(\n    () => createHandleCopyJson({ toast }, setCopiedJson)(container),\n    [container, toast]\n  )\n\n  const handleImageDragStart = useCallback(\n    createHandleImageDragStart(setDraggingNodeId),\n    []\n  )\n\n  const handleBlockDragStart = useCallback(\n    createHandleBlockDragStart(setDraggingNodeId),\n    []\n  )\n\n  const handleDragEnter = useCallback(createHandleDragEnter(), [])\n\n  const handleDragOver = useCallback(\n    createHandleDragOver({\n      container,\n      dispatch,\n      draggingNodeId,\n      setDraggingNodeId,\n      setDragOverNodeId,\n      setDropPosition,\n    }),\n    [container, draggingNodeId]\n  )\n\n  const handleDragLeave = useCallback(\n    createHandleDragLeave(setDragOverNodeId, setDropPosition),\n    []\n  )\n\n  const handleDrop = useCallback(\n    createHandleDrop(dragDropParams, dropPosition),\n    [container, dispatch, toast, draggingNodeId, dropPosition, onUploadImage]\n  )\n\n  const handleFileChange = useCallback(\n    createHandleFileChange(fileUploadParams),\n    [container, dispatch, state, toast, onUploadImage]\n  )\n\n  const handleMultipleFilesChange = useCallback(\n    createHandleMultipleFilesChange(fileUploadParams),\n    [container, dispatch, state, toast, onUploadImage]\n  )\n\n  const handleImageUploadClick = useCallback(\n    createHandleImageUploadClick(fileInputRef),\n    []\n  )\n\n  const handleMultipleImagesUploadClick = useCallback(\n    createHandleMultipleImagesUploadClick(multipleFileInputRef),\n    []\n  )\n\n  const handleClearImageSelection = useCallback(\n    createHandleClearImageSelection(setSelectedImageIds),\n    []\n  )\n\n  const handleGroupSelectedImages = useCallback(\n    createHandleGroupSelectedImages(\n      { container, dispatch, toast },\n      selectedImageIds,\n      handleClearImageSelection\n    ),\n    [container, dispatch, toast, selectedImageIds, handleClearImageSelection]\n  )\n\n  // Check if selected images are in same flex container\n  const flexInfo = React.useMemo(() => {\n    if (selectedImageIds.size < 2) {\n      return { inSameFlex: false, flexParentId: null }\n    }\n    return checkImagesInSameFlex(\n      { container, dispatch, toast },\n      selectedImageIds\n    )\n  }, [container, selectedImageIds, dispatch, toast])\n\n  const handleReverseImagesInFlex = useCallback(\n    createHandleReverseImagesInFlex(\n      { container, dispatch, toast },\n      selectedImageIds,\n      flexInfo.flexParentId || \"\"\n    ),\n    [container, dispatch, toast, selectedImageIds, flexInfo.flexParentId]\n  )\n\n  const handleExtractFromFlex = useCallback(\n    createHandleExtractFromFlex(\n      { container, dispatch, toast },\n      selectedImageIds,\n      flexInfo.flexParentId || \"\",\n      handleClearImageSelection\n    ),\n    [\n      container,\n      dispatch,\n      toast,\n      selectedImageIds,\n      flexInfo.flexParentId,\n      handleClearImageSelection,\n    ]\n  )\n\n  const handleFlexContainerDragOver = useCallback(\n    createHandleFlexContainerDragOver({\n      container,\n      dispatch,\n      toast,\n      draggingNodeId,\n      setDragOverFlexId,\n      setFlexDropPosition,\n    }),\n    [container, dispatch, toast, draggingNodeId]\n  )\n\n  const handleFlexContainerDragLeave = useCallback(\n    createHandleFlexContainerDragLeave(setDragOverFlexId, setFlexDropPosition),\n    []\n  )\n\n  const handleFlexContainerDrop = useCallback(\n    createHandleFlexContainerDrop({\n      container,\n      dispatch,\n      toast,\n      draggingNodeId,\n      setDragOverFlexId,\n      setFlexDropPosition,\n    }),\n    [container, dispatch, toast, draggingNodeId]\n  )\n\n  // Selection change listener\n  useEffect(() => {\n    document.addEventListener(\"selectionchange\", handleSelectionChange)\n    return () => {\n      document.removeEventListener(\"selectionchange\", handleSelectionChange)\n    }\n  }, [handleSelectionChange])\n\n  // Focus on current node when it changes\n  useEffect(() => {\n    if (!state.activeNodeId) return\n\n    const activeId = state.activeNodeId\n\n    const attemptFocus = (retries = 0) => {\n      const element = nodeRefs.current.get(activeId)\n\n      if (element && document.activeElement !== element) {\n        element.focus({ preventScroll: true })\n      } else if (!element && retries < 10) {\n        setTimeout(() => attemptFocus(retries + 1), 50)\n      } else if (!element) {\n        console.error(\n          \"❌ [Focus Failed] Element not found after 10 retries:\",\n          activeId\n        )\n      }\n    }\n\n    attemptFocus()\n  }, [state.activeNodeId])\n\n  // Cleanup timers on unmount\n  useEffect(() => {\n    return () => {\n      contentUpdateTimers.current.forEach((timer) => clearTimeout(timer))\n      contentUpdateTimers.current.clear()\n    }\n  }, [])\n\n  // Handle global keyboard shortcuts\n  useEffect(() => {\n    const handleGlobalKeyDown = (e: KeyboardEvent) => {\n      const isCtrlOrCmd = e.ctrlKey || e.metaKey\n\n      const activeElement = document.activeElement\n      const isInEditor = Array.from(nodeRefs.current.values()).some(\n        (el) => el === activeElement || el.contains(activeElement)\n      )\n\n      // Ctrl+A / Cmd+A - Select all content in current block only\n      if (isCtrlOrCmd && e.key === \"a\" && isInEditor) {\n        e.preventDefault()\n\n        const selection = window.getSelection()\n        if (!selection) return\n\n        const currentBlock = activeElement as HTMLElement\n        if (currentBlock && currentBlock.isContentEditable) {\n          const range = document.createRange()\n          range.selectNodeContents(currentBlock)\n          selection.removeAllRanges()\n          selection.addRange(range)\n        }\n      }\n\n      // Ctrl+B / Cmd+B - Toggle Bold\n      if (isCtrlOrCmd && e.key === \"b\" && isInEditor) {\n        e.preventDefault()\n        const selection = window.getSelection()\n        if (selection && !selection.isCollapsed) {\n          handleFormat(\"bold\")\n        }\n      }\n\n      // Ctrl+I / Cmd+I - Toggle Italic\n      if (isCtrlOrCmd && e.key === \"i\" && isInEditor) {\n        e.preventDefault()\n        const selection = window.getSelection()\n        if (selection && !selection.isCollapsed) {\n          handleFormat(\"italic\")\n        }\n      }\n\n      // Ctrl+U / Cmd+U - Toggle Underline\n      if (isCtrlOrCmd && e.key === \"u\" && isInEditor) {\n        e.preventDefault()\n        const selection = window.getSelection()\n        if (selection && !selection.isCollapsed) {\n          handleFormat(\"underline\")\n        }\n      }\n\n      // Ctrl+Z / Cmd+Z - Undo\n      if (isCtrlOrCmd && e.key === \"z\" && !e.shiftKey) {\n        if (\n          !isInEditor &&\n          (activeElement?.tagName === \"INPUT\" ||\n            activeElement?.tagName === \"TEXTAREA\")\n        ) {\n          return\n        }\n        e.preventDefault()\n        if (state.historyIndex > 0) {\n          dispatch(EditorActions.undo())\n        }\n      }\n\n      // Ctrl+Y / Cmd+Y or Ctrl+Shift+Z - Redo\n      if (\n        (isCtrlOrCmd && e.key === \"y\") ||\n        (isCtrlOrCmd && e.shiftKey && e.key === \"z\")\n      ) {\n        if (\n          !isInEditor &&\n          (activeElement?.tagName === \"INPUT\" ||\n            activeElement?.tagName === \"TEXTAREA\")\n        ) {\n          return\n        }\n        e.preventDefault()\n        if (state.historyIndex < state.history.length - 1) {\n          dispatch(EditorActions.redo())\n        }\n      }\n    }\n\n    document.addEventListener(\"keydown\", handleGlobalKeyDown)\n    return () => {\n      document.removeEventListener(\"keydown\", handleGlobalKeyDown)\n    }\n  }, [state.historyIndex, state.history.length, dispatch, toast, handleFormat])\n\n  return (\n    <div className=\"bg-background flex flex-1 flex-col transition-colors duration-300\">\n      {/* Editor with integrated toolbar */}\n      <div className=\"mx-auto flex w-full flex-1 flex-col\">\n        <Card className=\"flex flex-1 flex-col gap-3 rounded-none border-2 pt-0 shadow-2xl transition-all duration-300\">\n          {/* Toolbar - hidden in readOnly mode */}\n          {!readOnly && (\n            <EditorToolbar\n              currentNode={currentNode}\n              currentSelection={state.currentSelection}\n              selectedColor={selectedColor}\n              isUploading={isUploading}\n              enhanceSpaces={enhanceSpaces}\n              copiedHtml={copiedHtml}\n              copiedJson={copiedJson}\n              container={container}\n              readOnly={readOnly}\n              onReadOnlyChange={setReadOnly}\n              onTypeChange={handleTypeChange}\n              onFormat={handleFormat}\n              onColorSelect={handleApplyColor}\n              onFontSizeSelect={handleApplyFontSize}\n              onImageUploadClick={handleImageUploadClick}\n              onMultipleImagesUploadClick={handleMultipleImagesUploadClick}\n              onCreateList={handleCreateList}\n              onCreateLink={handleCreateLink}\n              onCreateTable={() => setTableDialogOpen(true)}\n              onCopyHtml={handleCopyHtml}\n              onCopyJson={handleCopyJson}\n              onEnhanceSpacesChange={setEnhanceSpaces}\n            />\n          )}\n\n          {/* Table Dialog */}\n          <TableDialog\n            open={tableDialogOpen}\n            onOpenChange={setTableDialogOpen}\n            onCreateTable={handleCreateTable}\n            onImportMarkdown={handleImportMarkdownTable}\n          />\n\n          {/* Hidden file inputs for image uploads */}\n          {!readOnly && (\n            <>\n              <input\n                ref={fileInputRef}\n                type=\"file\"\n                accept=\"image/*\"\n                onChange={handleFileChange}\n                className=\"hidden\"\n              />\n              <input\n                ref={multipleFileInputRef}\n                type=\"file\"\n                accept=\"image/*\"\n                multiple\n                onChange={handleMultipleFilesChange}\n                className=\"hidden\"\n              />\n            </>\n          )}\n\n          {/* Editor Content */}\n          <CardContent\n            className={`mx-auto flex w-full max-w-4xl flex-1 flex-col p-6 transition-all duration-300 ${\n              readOnly ? \"py-14 md:py-20\" : \"\"\n            }`}\n          >\n            <div ref={editorContentRef}>\n              <div data-editor-content>\n                {container.children.map((node: EditorNode, index: number) => {\n                  const isText = isTextNode(node)\n                  const textNode = isText ? (node as TextNode) : null\n\n                  const hasChildren =\n                    textNode &&\n                    Array.isArray(textNode.children) &&\n                    textNode.children.length > 0\n                  const nodeKey = hasChildren\n                    ? `${node.id}-children-${textNode?.children?.length}`\n                    : `${node.id}-content`\n\n                  const isFirstBlock = index === 0\n\n                  return (\n                    <React.Fragment key={nodeKey}>\n                      {/* Add block button before first block */}\n                      {!readOnly && isFirstBlock && (\n                        <AddBlockButton\n                          onAdd={() => handleAddBlock(node.id, \"before\")}\n                          position=\"before\"\n                        />\n                      )}\n\n                      <div\n                        onDragEnter={(e: React.DragEvent) =>\n                          handleDragEnter(e, node.id)\n                        }\n                        onDragOver={(e) => handleDragOver(e, node.id)}\n                        onDragLeave={handleDragLeave}\n                        onDrop={(e) => handleDrop(e, node.id)}\n                        className={`relative transition-all ${\n                          dragOverNodeId === node.id &&\n                          dropPosition === \"before\" &&\n                          draggingNodeId !== node.id\n                            ? \"before:bg-primary/30 before:absolute before:inset-x-0 before:-top-1 before:z-10 before:h-1 before:rounded-full\"\n                            : \"\"\n                        } ${\n                          dragOverNodeId === node.id &&\n                          dropPosition === \"after\" &&\n                          draggingNodeId !== node.id\n                            ? \"after:bg-primary/30 after:absolute after:inset-x-0 after:-bottom-1 after:z-10 after:h-1 after:rounded-full\"\n                            : \"\"\n                        } ${\n                          dragOverNodeId === node.id &&\n                          dropPosition === \"left\" &&\n                          draggingNodeId !== node.id\n                            ? \"before:absolute before:inset-y-0 before:-left-1 before:z-10 before:w-1 before:rounded-full before:bg-blue-500/50\"\n                            : \"\"\n                        } ${\n                          dragOverNodeId === node.id &&\n                          dropPosition === \"right\" &&\n                          draggingNodeId !== node.id\n                            ? \"after:absolute after:inset-y-0 after:-right-1 after:z-10 after:w-1 after:rounded-full after:bg-blue-500/50\"\n                            : \"\"\n                        } `}\n                      >\n                        <Block\n                          key={`${node.id}-${node.type}`}\n                          node={node}\n                          isActive={state.activeNodeId === node.id}\n                          nodeRef={(el) => {\n                            if (el) {\n                              const elementNodeId =\n                                el.getAttribute(\"data-node-id\")\n                              if (elementNodeId) {\n                                nodeRefs.current.set(elementNodeId, el)\n                              }\n\n                              if (textNode && elementNodeId === node.id) {\n                                const isCurrentlyFocused =\n                                  document.activeElement === el\n                                const selection = window.getSelection()\n\n                                const hasActiveSelection =\n                                  selection &&\n                                  selection.rangeCount > 0 &&\n                                  !selection.isCollapsed\n\n                                let selectionInThisElement = false\n                                if (\n                                  hasActiveSelection &&\n                                  selection.rangeCount > 0\n                                ) {\n                                  const range = selection.getRangeAt(0)\n                                  selectionInThisElement = el.contains(\n                                    range.commonAncestorContainer\n                                  )\n                                }\n\n                                if (\n                                  !isCurrentlyFocused &&\n                                  !hasChildren &&\n                                  !hasActiveSelection &&\n                                  !selectionInThisElement\n                                ) {\n                                  const displayContent = textNode.content || \"\"\n                                  const currentContent = el.textContent || \"\"\n\n                                  if (currentContent !== displayContent) {\n                                    el.textContent = displayContent\n                                  }\n                                }\n                              }\n                            } else {\n                              nodeRefs.current.delete(node.id)\n                            }\n                          }}\n                          onInput={(element) =>\n                            handleContentChange(node.id, element)\n                          }\n                          onKeyDown={(e) => handleKeyDown(e, node.id)}\n                          onClick={() => handleNodeClick(node.id)}\n                          onDelete={(nodeId?: string) =>\n                            handleDeleteNode(nodeId || node.id)\n                          }\n                          onCreateNested={handleCreateNested}\n                          readOnly={readOnly}\n                          onImageDragStart={handleImageDragStart}\n                          onBlockDragStart={handleBlockDragStart}\n                          onChangeBlockType={handleChangeBlockType}\n                          onInsertImage={handleInsertImageFromCommand}\n                          onCreateList={handleCreateListFromCommand}\n                          onUploadImage={onUploadImage}\n                          selectedImageIds={selectedImageIds}\n                          onToggleImageSelection={handleToggleImageSelection}\n                          onClickWithModifier={handleClickWithModifier}\n                          onFlexContainerDragOver={handleFlexContainerDragOver}\n                          onFlexContainerDragLeave={\n                            handleFlexContainerDragLeave\n                          }\n                          onFlexContainerDrop={handleFlexContainerDrop}\n                          dragOverFlexId={dragOverFlexId}\n                          flexDropPosition={flexDropPosition}\n                        />\n                      </div>\n\n                      {/* Add block button after each block */}\n                      {!readOnly && (\n                        <AddBlockButton\n                          onAdd={() => handleAddBlock(node.id, \"after\")}\n                          position=\"after\"\n                        />\n                      )}\n                    </React.Fragment>\n                  )\n                })}\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Custom Class Popover - Floats on text selection */}\n      <div className={`${readOnly ? \"opacity-0\" : \"\"}`}>\n        <CustomClassPopover />\n      </div>\n\n      {/* Link Popover - Floats on text selection */}\n      <div className={`${readOnly ? \"opacity-0\" : \"\"}`}>\n        <LinkPopover />\n      </div>\n\n      {/* Group Images Button - Floats when multiple images selected */}\n      {!readOnly && (\n        <GroupImagesButton\n          selectedCount={selectedImageIds.size}\n          inSameFlex={flexInfo.inSameFlex}\n          onGroup={handleGroupSelectedImages}\n          onReverse={\n            flexInfo.inSameFlex ? handleReverseImagesInFlex : undefined\n          }\n          onExtract={flexInfo.inSameFlex ? handleExtractFromFlex : undefined}\n          onClear={handleClearImageSelection}\n        />\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/editor-toolbar.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport {\n  Bold,\n  Check,\n  Copy,\n  Download,\n  Eye,\n  EyeOff,\n  ImagePlus,\n  Italic,\n  LayoutGrid,\n  Link as LinkIcon,\n  List,\n  ListOrdered,\n  Moon,\n  Sun,\n  Table as TableIcon,\n  Type,\n  Underline,\n} from \"lucide-react\"\nimport { useTheme } from \"next-themes\"\n\nimport { Button } from \"../button\"\nimport { ButtonGroup } from \"../button-group\"\nimport { CardContent } from \"../card\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../dialog\"\nimport { Label } from \"../label\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"../select\"\nimport { Separator } from \"../separator\"\nimport { Switch } from \"../switch\"\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"../tabs\"\nimport { ToggleGroup, ToggleGroupItem } from \"../toggle-group\"\nimport { ColorPickerComponent } from \"./color-picker\"\nimport { FontSizePicker } from \"./font-size-picker\"\nimport {\n  serializeToHtml,\n  type ContainerNode,\n  type SelectionInfo,\n  type TextNode,\n} from \"./index\"\n\ninterface EditorToolbarProps {\n  currentNode?: TextNode | null\n  currentSelection: SelectionInfo | null\n  selectedColor: string\n  isUploading: boolean\n  enhanceSpaces: boolean\n  copiedHtml: boolean\n  copiedJson: boolean\n  container: ContainerNode\n  readOnly: boolean\n  onReadOnlyChange: (readOnly: boolean) => void\n  onTypeChange: (type: TextNode[\"type\"]) => void\n  onFormat: (format: \"bold\" | \"italic\" | \"underline\") => void\n  onColorSelect: (color: string) => void\n  onFontSizeSelect: (fontSize: string) => void\n  onImageUploadClick: () => void\n  onMultipleImagesUploadClick: () => void\n  onCreateList: (listType: \"ul\" | \"ol\") => void\n  onCreateLink: () => void\n  onCreateTable: () => void\n  onCopyHtml: () => void\n  onCopyJson: () => void\n  onEnhanceSpacesChange: (checked: boolean) => void\n}\n\nexport function EditorToolbar({\n  currentNode,\n  currentSelection,\n  selectedColor,\n  isUploading,\n  enhanceSpaces,\n  copiedHtml,\n  copiedJson,\n  container,\n  readOnly,\n  onReadOnlyChange,\n  onTypeChange,\n  onFormat,\n  onColorSelect,\n  onFontSizeSelect,\n  onImageUploadClick,\n  onMultipleImagesUploadClick,\n  onCreateList,\n  onCreateLink,\n  onCreateTable,\n  onCopyHtml,\n  onCopyJson,\n  onEnhanceSpacesChange,\n}: EditorToolbarProps) {\n  const { theme, setTheme } = useTheme()\n\n  const toggleTheme = () => {\n    setTheme(theme === \"dark\" ? \"light\" : \"dark\")\n  }\n\n  return (\n    <CardContent className=\"bg-background/30 sticky top-0 z-[100] mx-auto w-full border-b p-3 backdrop-blur-2xl transition-all duration-300 md:p-4\">\n      <div className=\"mx-auto flex w-full max-w-4xl flex-col items-stretch justify-between gap-2 md:flex-row md:items-center md:gap-3\">\n        {/* Left Section - Text Formatting */}\n        <div className=\"flex flex-wrap items-center gap-1.5 md:gap-2\">\n          {/* Type Selector */}\n          <div className=\"bg-muted/50 flex items-center gap-1 rounded-md px-1.5 py-1 md:gap-1.5 md:px-2\">\n            <Type className=\"text-muted-foreground hidden size-3 sm:block md:size-3.5\" />\n            <Select\n              value={\n                currentSelection?.elementType !== undefined &&\n                currentSelection?.elementType !== null\n                  ? currentSelection.elementType\n                  : currentNode?.type || \"p\"\n              }\n              onValueChange={(value) => onTypeChange(value as TextNode[\"type\"])}\n              disabled={\n                !currentNode ||\n                currentNode.type === \"br\" ||\n                currentNode.type === \"img\"\n              }\n            >\n              <SelectTrigger className=\"h-7 w-[90px] border-0 bg-transparent text-xs focus:ring-0 sm:w-[120px] sm:text-sm md:h-8 md:w-[140px]\">\n                <SelectValue placeholder=\"Select type\">\n                  {(() => {\n                    const type =\n                      currentSelection?.elementType !== undefined &&\n                      currentSelection?.elementType !== null\n                        ? currentSelection.elementType\n                        : currentNode?.type || \"p\"\n\n                    switch (type) {\n                      case \"h1\":\n                        return (\n                          <span className=\"text-base font-bold\">Heading 1</span>\n                        )\n                      case \"h2\":\n                        return (\n                          <span className=\"text-sm font-bold\">Heading 2</span>\n                        )\n                      case \"h3\":\n                        return (\n                          <span className=\"text-sm font-semibold\">\n                            Heading 3\n                          </span>\n                        )\n                      case \"h4\":\n                        return (\n                          <span className=\"text-xs font-semibold\">\n                            Heading 4\n                          </span>\n                        )\n                      case \"h5\":\n                        return (\n                          <span className=\"text-xs font-semibold\">\n                            Heading 5\n                          </span>\n                        )\n                      case \"h6\":\n                        return (\n                          <span className=\"text-xs font-semibold\">\n                            Heading 6\n                          </span>\n                        )\n                      case \"li\":\n                        return <span className=\"text-sm\">List Item</span>\n                      case \"blockquote\":\n                        return <span className=\"text-sm italic\">Quote</span>\n                      case \"code\":\n                        return <span className=\"font-mono text-xs\">Code</span>\n                      default:\n                        return <span className=\"text-sm\">Paragraph</span>\n                    }\n                  })()}\n                </SelectValue>\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"p\">\n                  <span className=\"text-sm\">Paragraph</span>\n                </SelectItem>\n                <SelectItem value=\"h1\">\n                  <span className=\"text-base font-bold\">Heading 1</span>\n                </SelectItem>\n                <SelectItem value=\"h2\">\n                  <span className=\"text-sm font-bold\">Heading 2</span>\n                </SelectItem>\n                <SelectItem value=\"h3\">\n                  <span className=\"text-sm font-semibold\">Heading 3</span>\n                </SelectItem>\n                <SelectItem value=\"h4\">\n                  <span className=\"text-xs font-semibold\">Heading 4</span>\n                </SelectItem>\n                <SelectItem value=\"h5\">\n                  <span className=\"text-xs font-semibold\">Heading 5</span>\n                </SelectItem>\n                <SelectItem value=\"h6\">\n                  <span className=\"text-xs font-semibold\">Heading 6</span>\n                </SelectItem>\n                <SelectItem value=\"li\">\n                  <span className=\"text-sm\">List Item</span>\n                </SelectItem>\n                <SelectItem value=\"blockquote\">\n                  <span className=\"text-sm italic\">Quote</span>\n                </SelectItem>\n                <SelectItem value=\"code\">\n                  <span className=\"font-mono text-xs\">Code</span>\n                </SelectItem>\n              </SelectContent>\n            </Select>\n          </div>\n\n          <Separator\n            orientation=\"vertical\"\n            className=\"hidden h-5 sm:block md:h-6\"\n          />\n\n          {/* Format Buttons */}\n          <ToggleGroup\n            type=\"multiple\"\n            variant=\"outline\"\n            disabled={!currentSelection}\n            size=\"sm\"\n            value={[\n              ...(currentSelection?.formats.bold ? [\"bold\"] : []),\n              ...(currentSelection?.formats.italic ? [\"italic\"] : []),\n              ...(currentSelection?.formats.underline ? [\"underline\"] : []),\n            ]}\n          >\n            <ToggleGroupItem\n              value=\"bold\"\n              aria-label=\"Toggle bold\"\n              onClick={() => onFormat(\"bold\")}\n              disabled={!currentSelection}\n              className=\"h-9 w-9 md:h-9 md:w-9\"\n            >\n              <Bold className=\"size-4 md:size-4\" />\n            </ToggleGroupItem>\n            <ToggleGroupItem\n              value=\"italic\"\n              aria-label=\"Toggle italic\"\n              onClick={() => onFormat(\"italic\")}\n              disabled={!currentSelection}\n              className=\"h-9 w-9 md:h-9 md:w-9\"\n            >\n              <Italic className=\"size-4 md:size-4\" />\n            </ToggleGroupItem>\n            <ToggleGroupItem\n              value=\"underline\"\n              aria-label=\"Toggle underline\"\n              onClick={() => onFormat(\"underline\")}\n              disabled={!currentSelection}\n              className=\"h-9 w-9 md:h-9 md:w-9\"\n            >\n              <Underline className=\"size-4 md:size-4\" />\n            </ToggleGroupItem>\n          </ToggleGroup>\n\n          {/* Color Picker */}\n          <ColorPickerComponent\n            disabled={!currentSelection}\n            onColorSelect={onColorSelect}\n            selectedColor={selectedColor}\n          />\n\n          <Separator\n            orientation=\"vertical\"\n            className=\"hidden h-5 md:h-6 lg:block\"\n          />\n\n          {/* Font Size Picker */}\n          <FontSizePicker\n            disabled={!currentSelection}\n            onFontSizeSelect={onFontSizeSelect}\n            currentFontSize={currentSelection?.styles?.fontSize || undefined}\n          />\n        </div>\n\n        <Separator orientation=\"vertical\" className=\"hidden h-8 xl:block\" />\n\n        {/* Right Section - Insert Elements */}\n        <div className=\"flex flex-wrap items-center gap-1.5 md:gap-2\">\n          {/* Image Buttons Group */}\n          <ButtonGroup>\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={onImageUploadClick}\n              disabled={isUploading}\n              className=\"h-9 w-9\"\n              title=\"Add single image\"\n            >\n              <ImagePlus className=\"size-4\" />\n            </Button>\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={onMultipleImagesUploadClick}\n              disabled={isUploading}\n              className=\"h-9 w-9\"\n              title=\"Add multiple images\"\n            >\n              <LayoutGrid className=\"size-4\" />\n            </Button>\n          </ButtonGroup>\n\n          <Separator\n            orientation=\"vertical\"\n            className=\"hidden h-5 sm:block md:h-6\"\n          />\n\n          {/* List Button Group */}\n          <ButtonGroup>\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={() => onCreateList(\"ul\")}\n              className=\"h-7 w-7 md:h-8 md:w-8\"\n              title=\"Add unordered list\"\n            >\n              <List className=\"size-3 md:size-3.5\" />\n            </Button>\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={() => onCreateList(\"ol\")}\n              className=\"h-7 w-7 md:h-8 md:w-8\"\n              title=\"Add ordered list\"\n            >\n              <ListOrdered className=\"size-3 md:size-3.5\" />\n            </Button>\n          </ButtonGroup>\n\n          {/* Link Button */}\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            onClick={onCreateLink}\n            className=\"h-7 w-7 md:h-8 md:w-8\"\n            title=\"Add link\"\n          >\n            <LinkIcon className=\"size-3 md:size-3.5\" />\n          </Button>\n\n          {/* Table Button */}\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            onClick={onCreateTable}\n            className=\"h-7 w-7 md:h-8 md:w-8\"\n            title=\"Add table\"\n          >\n            <TableIcon className=\"size-3 md:size-3.5\" />\n          </Button>\n\n          <Separator\n            orientation=\"vertical\"\n            className=\"hidden h-5 sm:block md:h-6\"\n          />\n\n          {/* View Code Button */}\n          <Dialog>\n            <DialogTrigger asChild>\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"h-7 w-7 md:h-8 md:w-8\"\n                title=\"Export code\"\n              >\n                <Download className=\"size-3 md:size-3.5\" />\n              </Button>\n            </DialogTrigger>\n            <DialogContent className=\"flex max-h-[90vh] max-w-[90vw] min-w-[90vw] flex-col overflow-hidden\">\n              <DialogHeader>\n                <DialogTitle>Export Code</DialogTitle>\n                <DialogDescription>\n                  Copy the HTML or JSON output of your editor content\n                </DialogDescription>\n              </DialogHeader>\n\n              <Tabs\n                defaultValue=\"preview\"\n                className=\"flex flex-1 flex-col overflow-hidden\"\n              >\n                <TabsList className=\"grid w-full grid-cols-3\">\n                  <TabsTrigger value=\"preview\">\n                    <Eye className=\"mr-2 h-4 w-4\" />\n                    Preview\n                  </TabsTrigger>\n                  <TabsTrigger value=\"html\">HTML Output</TabsTrigger>\n                  <TabsTrigger value=\"json\">JSON Data</TabsTrigger>\n                </TabsList>\n\n                {/* Enhance Spaces Toggle */}\n                <div className=\"mt-4 flex items-center justify-between px-1\">\n                  <p className=\"text-muted-foreground text-sm\">\n                    Preview Options\n                  </p>\n                  <div className=\"flex items-center gap-2\">\n                    <Label\n                      htmlFor=\"enhance-spaces\"\n                      className=\"cursor-pointer text-sm\"\n                    >\n                      Enhance Spaces\n                    </Label>\n                    <Switch\n                      id=\"enhance-spaces\"\n                      checked={enhanceSpaces}\n                      onCheckedChange={onEnhanceSpacesChange}\n                    />\n                  </div>\n                </div>\n\n                <TabsContent\n                  value=\"preview\"\n                  className=\"mt-4 flex flex-1 flex-col overflow-hidden\"\n                >\n                  <div className=\"mb-2 flex items-center justify-between\">\n                    <p className=\"text-muted-foreground text-sm\">\n                      Live preview of rendered HTML\n                    </p>\n                  </div>\n                  <div\n                    className=\"bg-background flex-1 overflow-auto rounded-lg border p-6\"\n                    dangerouslySetInnerHTML={{\n                      __html: enhanceSpaces\n                        ? `<div class=\"[&>*]:my-3 [&_*]:my-5\">${serializeToHtml(\n                            container\n                          )}</div>`\n                        : serializeToHtml(container),\n                    }}\n                  />\n                </TabsContent>\n\n                <TabsContent\n                  value=\"html\"\n                  className=\"mt-4 flex flex-1 flex-col overflow-hidden\"\n                >\n                  <div className=\"mb-2 flex items-center justify-between\">\n                    <p className=\"text-muted-foreground text-sm\">\n                      HTML with Tailwind CSS classes\n                    </p>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={onCopyHtml}\n                      className=\"gap-2\"\n                    >\n                      {copiedHtml ? (\n                        <>\n                          <Check className=\"h-4 w-4\" />\n                          Copied!\n                        </>\n                      ) : (\n                        <>\n                          <Copy className=\"h-4 w-4\" />\n                          Copy HTML\n                        </>\n                      )}\n                    </Button>\n                  </div>\n                  <pre className=\"bg-secondary text-secondary-foreground flex-1 overflow-auto rounded-lg border p-4 text-xs\">\n                    {enhanceSpaces\n                      ? `<div class=\"[&>*]:my-3 [&_*]:my-5\">\\n${serializeToHtml(\n                          container\n                        )}\\n</div>`\n                      : serializeToHtml(container)}\n                  </pre>\n                </TabsContent>\n\n                <TabsContent\n                  value=\"json\"\n                  className=\"mt-4 flex flex-1 flex-col overflow-hidden\"\n                >\n                  <div className=\"mb-2 flex items-center justify-between\">\n                    <p className=\"text-muted-foreground text-sm\">\n                      Editor state as JSON\n                    </p>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={onCopyJson}\n                      className=\"gap-2\"\n                    >\n                      {copiedJson ? (\n                        <>\n                          <Check className=\"h-4 w-4\" />\n                          Copied!\n                        </>\n                      ) : (\n                        <>\n                          <Copy className=\"h-4 w-4\" />\n                          Copy JSON\n                        </>\n                      )}\n                    </Button>\n                  </div>\n                  <pre className=\"bg-secondary text-secondary-foreground flex-1 overflow-auto rounded-lg border p-4 text-xs\">\n                    {JSON.stringify(container.children, null, 2)}\n                  </pre>\n                </TabsContent>\n              </Tabs>\n            </DialogContent>\n          </Dialog>\n\n          <Separator\n            orientation=\"vertical\"\n            className=\"hidden h-5 sm:block md:h-6\"\n          />\n\n          {/* Read-only toggle */}\n          <Button\n            variant={readOnly ? \"default\" : \"ghost\"}\n            size=\"icon\"\n            className=\"h-7 w-7 md:h-8 md:w-8\"\n            onClick={() => onReadOnlyChange(!readOnly)}\n            title={readOnly ? \"View Only Mode\" : \"Edit Mode\"}\n          >\n            {readOnly ? (\n              <Eye className=\"size-3 md:size-3.5\" />\n            ) : (\n              <EyeOff className=\"size-3 md:size-3.5\" />\n            )}\n          </Button>\n\n          {/* Theme toggle */}\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"h-7 w-7 md:h-8 md:w-8\"\n            onClick={toggleTheme}\n            title=\"Toggle theme\"\n          >\n            <Sun className=\"size-3 scale-100 rotate-0 transition-all md:size-3.5 dark:scale-0 dark:-rotate-90\" />\n            <Moon className=\"absolute size-3 scale-0 rotate-90 transition-all md:size-3.5 dark:scale-100 dark:rotate-0\" />\n          </Button>\n        </div>\n      </div>\n    </CardContent>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/block.tsx",
      "content": "/**\n * Block Component - Clean Version\n *\n * Represents a single editable block (paragraph, heading, etc.)\n * Handles its own rendering, editing, and event handling.\n * Supports recursive rendering of nested blocks via ContainerNode.\n *\n * CLEAN VERSION - All handlers extracted to separate modules\n */\n\n\"use client\"\n\nimport React, { useCallback, useEffect, useRef, useState } from \"react\"\nimport { GripVertical } from \"lucide-react\"\n\nimport { BlockContextMenu } from \"./block-context-menu\"\nimport { CommandMenu } from \"./command-menu\"\nimport { useEditor } from \"./context/editor-context\"\nimport { FlexContainer } from \"./flex-container\"\n// Import all block handlers\nimport {\n  buildHTML,\n  createHandleBackgroundColorChange,\n  createHandleBlockDragEnd,\n  createHandleBlockDragStart,\n  createHandleClick,\n  createHandleCommandSelect,\n  createHandleCompositionEnd,\n  createHandleCompositionStart,\n  createHandleInput,\n  createHandleKeyDown,\n  getTypeClassName,\n  restoreSelection,\n  saveSelection,\n} from \"./handlers/block\"\nimport { ImageBlock } from \"./image-block\"\nimport {\n  ContainerNode,\n  EditorNode,\n  getNodeTextContent,\n  isContainerNode,\n  TextNode,\n} from \"./index\"\nimport { TableBuilder } from \"./table-builder\"\n\ninterface BlockProps {\n  node: EditorNode\n  isActive: boolean\n  nodeRef: (el: HTMLElement | null) => void\n  onInput: (element: HTMLElement) => void\n  onKeyDown: (e: React.KeyboardEvent<HTMLElement>) => void\n  onClick: () => void\n  onDelete?: (nodeId?: string) => void\n  onCreateNested?: (nodeId: string) => void\n  depth?: number\n  readOnly?: boolean\n  onImageDragStart?: (nodeId: string) => void\n  onChangeBlockType?: (nodeId: string, newType: string) => void\n  onInsertImage?: (nodeId: string) => void\n  onCreateList?: (nodeId: string, listType: string) => void\n  onUploadImage?: (file: File) => Promise<string>\n  onBlockDragStart?: (nodeId: string) => void\n  selectedImageIds?: Set<string>\n  onToggleImageSelection?: (nodeId: string) => void\n  onClickWithModifier?: (e: React.MouseEvent, nodeId: string) => void\n  onFlexContainerDragOver?: (\n    e: React.DragEvent,\n    flexId: string,\n    position: \"left\" | \"right\" | null\n  ) => void\n  onFlexContainerDragLeave?: (e: React.DragEvent) => void\n  onFlexContainerDrop?: (\n    e: React.DragEvent,\n    flexId: string,\n    position: \"left\" | \"right\" | null\n  ) => void\n  dragOverFlexId?: string | null\n  flexDropPosition?: \"left\" | \"right\" | null\n}\n\nexport function Block({\n  node,\n  isActive,\n  nodeRef,\n  onInput,\n  onKeyDown,\n  onClick,\n  onDelete,\n  onCreateNested,\n  depth = 0,\n  readOnly = false,\n  onImageDragStart,\n  onChangeBlockType,\n  onInsertImage,\n  onCreateList,\n  onUploadImage,\n  onBlockDragStart,\n  selectedImageIds,\n  onToggleImageSelection,\n  onClickWithModifier,\n  onFlexContainerDragOver,\n  onFlexContainerDragLeave,\n  onFlexContainerDrop,\n  dragOverFlexId,\n  flexDropPosition,\n}: BlockProps) {\n  const localRef = useRef<HTMLElement | null>(null)\n  const isComposingRef = useRef(false)\n  const shouldPreserveSelectionRef = useRef(false)\n  const [isHovering, setIsHovering] = useState(false)\n\n  // Get editor context for direct state manipulation (needed for table updates)\n  const [state, dispatch] = useEditor()\n\n  // Command menu state\n  const [showCommandMenu, setShowCommandMenu] = useState(false)\n  const [commandMenuAnchor, setCommandMenuAnchor] =\n    useState<HTMLElement | null>(null)\n\n  // Handle container nodes (recursive rendering)\n  if (isContainerNode(node)) {\n    const containerNode = node as ContainerNode\n\n    // Get first child\n    const firstChild = containerNode.children[0]\n\n    // Check if this is a table wrapper container\n    const isTableWrapper = firstChild?.type === \"table\"\n\n    // If this container wraps a table, render the TableBuilder\n    if (isTableWrapper) {\n      return (\n        <TableBuilder\n          key={node.id}\n          node={containerNode}\n          onUpdate={(id, updates) => {\n            if (dispatch) {\n              dispatch({\n                type: \"UPDATE_NODE\",\n                payload: { id, updates },\n              })\n            }\n          }}\n          readOnly={readOnly}\n          onBlockDragStart={onBlockDragStart}\n        />\n      )\n    }\n\n    // Check if this is a flex container for images\n    const layoutType = containerNode.attributes?.layoutType as\n      | string\n      | undefined\n    const isFlexContainer = layoutType === \"flex\"\n    const gap = containerNode.attributes?.gap as string | undefined\n    const flexWrap = containerNode.attributes?.flexWrap as string | undefined\n\n    // Determine if this container holds list items\n    const listTypeFromAttribute = containerNode.attributes?.listType as\n      | string\n      | undefined\n    const listTypeFromChild =\n      firstChild &&\n      (firstChild.type === \"ul\" ||\n        firstChild.type === \"ol\" ||\n        firstChild.type === \"li\")\n        ? firstChild.type === \"li\"\n          ? \"ul\"\n          : firstChild.type\n        : null\n\n    const listType = listTypeFromAttribute || listTypeFromChild\n    const isListContainer = !!listType\n\n    // Use ul/ol for list containers, div for regular nested containers\n    const ContainerElement =\n      listType === \"ul\" ? \"ul\" : listType === \"ol\" ? \"ol\" : \"div\"\n\n    const containerClasses = isFlexContainer\n      ? ``\n      : isListContainer\n        ? `list-none pl-0 ml-6`\n        : `border-l-2 border-border/50 pl-2 ml-6 transition-all ${\n            isActive ? \"border-primary\" : \"hover:border-border\"\n          }`\n\n    // Render flex container with FlexContainer component\n    if (isFlexContainer) {\n      return (\n        <FlexContainer\n          key={node.id}\n          node={containerNode}\n          onDragOver={(e, position) => {\n            if (onFlexContainerDragOver) {\n              onFlexContainerDragOver(e, node.id, position)\n            }\n          }}\n          onDragLeave={onFlexContainerDragLeave}\n          onDrop={(e, position) => {\n            if (onFlexContainerDrop) {\n              onFlexContainerDrop(e, node.id, position)\n            }\n          }}\n          dragOverPosition={\n            dragOverFlexId === node.id ? flexDropPosition : null\n          }\n        >\n          {containerNode.children.map((childNode) => {\n            const isChildImage =\n              childNode && \"type\" in childNode && childNode.type === \"img\"\n\n            const blockContent = (\n              <Block\n                key={childNode.id}\n                node={childNode}\n                isActive={isActive}\n                nodeRef={nodeRef}\n                onInput={onInput}\n                onKeyDown={(e) => {\n                  onKeyDown(e)\n                }}\n                onClick={onClick}\n                onDelete={\n                  isChildImage && onDelete\n                    ? () => onDelete(childNode.id)\n                    : undefined\n                }\n                onCreateNested={onCreateNested}\n                depth={depth + 1}\n                readOnly={readOnly}\n                onImageDragStart={onImageDragStart}\n                onChangeBlockType={onChangeBlockType}\n                onInsertImage={onInsertImage}\n                onCreateList={onCreateList}\n                onUploadImage={onUploadImage}\n                selectedImageIds={selectedImageIds}\n                onToggleImageSelection={onToggleImageSelection}\n                onClickWithModifier={onClickWithModifier}\n                onFlexContainerDragOver={onFlexContainerDragOver}\n                onFlexContainerDragLeave={onFlexContainerDragLeave}\n                onFlexContainerDrop={onFlexContainerDrop}\n                dragOverFlexId={dragOverFlexId}\n                flexDropPosition={flexDropPosition}\n              />\n            )\n\n            // Wrap in flex item div\n            return (\n              <div\n                key={childNode.id}\n                className=\"max-w-full min-w-[280px] flex-1\"\n              >\n                {blockContent}\n              </div>\n            )\n          })}\n        </FlexContainer>\n      )\n    }\n\n    return (\n      <ContainerElement\n        key={node.id}\n        data-node-id={node.id}\n        data-node-type=\"container\"\n        data-list-type={listType || undefined}\n        className={containerClasses}\n      >\n        {containerNode.children.map((childNode) => {\n          const isChildImage =\n            childNode && \"type\" in childNode && childNode.type === \"img\"\n\n          const blockContent = (\n            <Block\n              key={childNode.id}\n              node={childNode}\n              isActive={isActive}\n              nodeRef={nodeRef}\n              onInput={onInput}\n              onKeyDown={(e) => {\n                onKeyDown(e)\n              }}\n              onClick={onClick}\n              onDelete={\n                isChildImage && onDelete\n                  ? () => onDelete(childNode.id)\n                  : undefined\n              }\n              onCreateNested={onCreateNested}\n              depth={depth + 1}\n              readOnly={readOnly}\n              onImageDragStart={onImageDragStart}\n              onChangeBlockType={onChangeBlockType}\n              onInsertImage={onInsertImage}\n              onCreateList={onCreateList}\n              onUploadImage={onUploadImage}\n              selectedImageIds={selectedImageIds}\n              onToggleImageSelection={onToggleImageSelection}\n              onClickWithModifier={onClickWithModifier}\n              onFlexContainerDragOver={onFlexContainerDragOver}\n              onFlexContainerDragLeave={onFlexContainerDragLeave}\n              onFlexContainerDrop={onFlexContainerDrop}\n              dragOverFlexId={dragOverFlexId}\n              flexDropPosition={flexDropPosition}\n            />\n          )\n\n          // If it's a flex container, wrap in a flex item div\n          if (isFlexContainer) {\n            return (\n              <div\n                key={childNode.id}\n                className=\"max-w-full min-w-[280px] flex-1\"\n              >\n                {blockContent}\n              </div>\n            )\n          }\n\n          return blockContent\n        })}\n      </ContainerElement>\n    )\n  }\n\n  // Cast to TextNode for remaining cases\n  const textNode = node as TextNode\n\n  // BR elements render as empty space\n  if (textNode.type === \"br\") {\n    return (\n      <div\n        key={textNode.id}\n        data-node-id={textNode.id}\n        className=\"h-6\"\n        onClick={onClick}\n      />\n    )\n  }\n\n  // Image nodes render as ImageBlock\n  if (textNode.type === \"img\") {\n    return (\n      <ImageBlock\n        node={textNode}\n        isActive={isActive}\n        onClick={onClick}\n        onDelete={onDelete}\n        onDragStart={onImageDragStart}\n        isSelected={selectedImageIds?.has(textNode.id)}\n        onToggleSelection={onToggleImageSelection}\n        onClickWithModifier={onClickWithModifier}\n      />\n    )\n  }\n\n  // Get current container from state (already have dispatch from top of component)\n  const currentContainer = state.history[state.historyIndex]\n\n  // Build HTML callback\n  const memoizedBuildHTML = useCallback(() => {\n    return buildHTML(textNode, readOnly)\n  }, [textNode, readOnly])\n\n  // Save selection callback\n  const memoizedSaveSelection = useCallback(() => {\n    return saveSelection(localRef)\n  }, [])\n\n  // Restore selection callback\n  const memoizedRestoreSelection = useCallback(\n    (\n      savedSelection: { start: number; end: number; collapsed: boolean } | null\n    ) => {\n      restoreSelection(localRef, savedSelection)\n    },\n    []\n  )\n\n  // Update content when needed\n  useEffect(() => {\n    if (!localRef.current) return\n\n    if (isComposingRef.current || shouldPreserveSelectionRef.current) {\n      return\n    }\n\n    const element = localRef.current\n    const newHTML = memoizedBuildHTML()\n\n    if (element.innerHTML !== newHTML) {\n      const hadFocus = document.activeElement === element\n      const savedSelectionData = hadFocus ? memoizedSaveSelection() : null\n\n      element.innerHTML = newHTML\n\n      if (hadFocus && savedSelectionData) {\n        memoizedRestoreSelection(savedSelectionData)\n      }\n    }\n  }, [memoizedBuildHTML, memoizedSaveSelection, memoizedRestoreSelection])\n\n  // Create all handlers\n  const handleCompositionStart = useCallback(\n    createHandleCompositionStart()(isComposingRef),\n    []\n  )\n\n  const handleCompositionEnd = useCallback(\n    createHandleCompositionEnd()(isComposingRef),\n    []\n  )\n\n  const handleInput = useCallback(\n    createHandleInput({\n      textNode,\n      readOnly,\n      onInput,\n      onChangeBlockType,\n      showCommandMenu,\n      setShowCommandMenu,\n      setCommandMenuAnchor,\n      shouldPreserveSelectionRef,\n    }),\n    [textNode, readOnly, onInput, onChangeBlockType, showCommandMenu]\n  )\n\n  const handleKeyDown = useCallback(\n    createHandleKeyDown({\n      textNode,\n      readOnly,\n      onInput,\n      onKeyDown,\n      onClick,\n      onCreateNested,\n      onChangeBlockType,\n      onInsertImage,\n      onCreateList,\n      currentContainer,\n      dispatch,\n      localRef,\n      isComposingRef,\n      shouldPreserveSelectionRef,\n      showCommandMenu,\n      setShowCommandMenu,\n      setCommandMenuAnchor,\n    }),\n    [\n      textNode,\n      readOnly,\n      onKeyDown,\n      onCreateNested,\n      showCommandMenu,\n      currentContainer,\n      dispatch,\n    ]\n  )\n\n  const handleClick = useCallback(createHandleClick({ readOnly, onClick }), [\n    readOnly,\n    onClick,\n  ])\n\n  const handleCommandSelect = useCallback(\n    createHandleCommandSelect({\n      textNode,\n      onChangeBlockType,\n      onInsertImage,\n      onCreateList,\n      localRef,\n      setShowCommandMenu,\n      setCommandMenuAnchor,\n    }),\n    [textNode, onChangeBlockType, onInsertImage, onCreateList]\n  )\n\n  const handleBackgroundColorChange = useCallback(\n    createHandleBackgroundColorChange(textNode, dispatch),\n    [textNode, dispatch]\n  )\n\n  const handleBlockDragStartFn = useCallback(\n    createHandleBlockDragStart(textNode, onBlockDragStart),\n    [textNode, onBlockDragStart]\n  )\n\n  const handleBlockDragEndFn = useCallback(createHandleBlockDragEnd(), [])\n\n  // Check if block is empty\n  const textContent = getNodeTextContent(textNode)\n  const isEmpty = !textContent || textContent.trim() === \"\"\n  const showPlaceholder = isEmpty && isActive && !readOnly && onChangeBlockType\n\n  // Determine which HTML element to render based on type\n  const ElementType =\n    textNode.type === \"li\"\n      ? \"li\"\n      : textNode.type === \"h1\"\n        ? \"h1\"\n        : textNode.type === \"h2\"\n          ? \"h2\"\n          : textNode.type === \"h3\"\n            ? \"h3\"\n            : textNode.type === \"h4\"\n              ? \"h4\"\n              : textNode.type === \"h5\"\n                ? \"h5\"\n                : textNode.type === \"h6\"\n                  ? \"h6\"\n                  : textNode.type === \"p\"\n                    ? \"p\"\n                    : textNode.type === \"blockquote\"\n                      ? \"blockquote\"\n                      : textNode.type === \"code\"\n                        ? \"pre\"\n                        : \"div\"\n\n  const isListItem = textNode.type === \"li\"\n\n  // Get custom class from attributes\n  const customClassName = textNode.attributes?.className || \"\"\n  const isHexColor =\n    typeof customClassName === \"string\" && customClassName.startsWith(\"#\")\n  const textColor = isHexColor ? customClassName : \"\"\n  const className = isHexColor ? \"\" : customClassName\n\n  // Get background color from attributes\n  const backgroundColor = textNode.attributes?.backgroundColor as\n    | string\n    | undefined\n\n  // Common props for all elements\n  const commonProps = {\n    key: textNode.id,\n    \"data-node-id\": textNode.id,\n    \"data-node-type\": textNode.type,\n    contentEditable: !readOnly,\n    suppressContentEditableWarning: true,\n    className: `\n      ${isListItem ? \"relative\" : \"\"} \n      ${getTypeClassName(textNode.type)}\n      ${className}\n      ${readOnly ? \"\" : \"outline-none focus:ring-1 focus:ring-border/50\"}\n      rounded-lg px-3 py-2 mb-2\n      transition-all\n      ${!readOnly && isActive ? \"ring-1 ring-border/50 bg-accent/5\" : \"\"}\n      ${!readOnly ? \"hover:bg-accent/5\" : \"\"}\n      ${readOnly ? \"cursor-default\" : \"\"}\n    `,\n    style: {\n      marginLeft: `${depth * 0.5}rem`,\n      ...(textColor ? { color: textColor as string } : {}),\n      ...(backgroundColor ? { backgroundColor: backgroundColor } : {}),\n    },\n    spellCheck: false,\n  }\n\n  return (\n    <>\n      <BlockContextMenu\n        readOnly={readOnly}\n        onBackgroundColorChange={handleBackgroundColorChange}\n        currentBackgroundColor={backgroundColor}\n      >\n        <div\n          className=\"group relative\"\n          style={{\n            paddingLeft: readOnly ? \"0\" : \"28px\",\n            marginLeft: readOnly ? \"0\" : \"-28px\",\n          }}\n          onMouseEnter={() => !readOnly && setIsHovering(true)}\n          onMouseLeave={() => !readOnly && setIsHovering(false)}\n        >\n          {/* Drag Handle */}\n          {!readOnly && isHovering && onBlockDragStart && (\n            <div\n              draggable\n              onDragStart={handleBlockDragStartFn}\n              onDragEnd={handleBlockDragEndFn}\n              className=\"absolute top-1/2 left-1 z-10 -translate-y-1/2 cursor-grab opacity-0 transition-opacity duration-200 group-hover:opacity-100 active:cursor-grabbing\"\n              onClick={(e) => e.stopPropagation()}\n              onMouseDown={(e) => e.stopPropagation()}\n            >\n              <GripVertical\n                className=\"text-muted-foreground hover:text-foreground h-4 w-4 transition-colors duration-200\"\n                strokeWidth={1.5}\n              />\n            </div>\n          )}\n\n          <ElementType\n            {...commonProps}\n            key={textNode.id}\n            ref={(el: HTMLElement | null) => {\n              localRef.current = el\n              nodeRef(el)\n            }}\n            onInput={readOnly ? undefined : (e) => handleInput(e as any)}\n            onKeyDown={readOnly ? undefined : (e) => handleKeyDown(e as any)}\n            onClick={(e) => handleClick(e as any)}\n            onCompositionStart={readOnly ? undefined : handleCompositionStart}\n            onCompositionEnd={readOnly ? undefined : handleCompositionEnd}\n          />\n\n          {/* Placeholder text */}\n          {showPlaceholder && (\n            <div\n              className=\"text-muted-foreground/50 pointer-events-none absolute top-2 select-none\"\n              style={{\n                left: readOnly ? \"0.75rem\" : \"calc(28px + 0.75rem)\",\n                marginLeft: `${depth * 0.5}rem`,\n              }}\n            >\n              Type / for commands...\n            </div>\n          )}\n        </div>\n      </BlockContextMenu>\n\n      {/* Command Menu */}\n      {!readOnly && (\n        <CommandMenu\n          isOpen={showCommandMenu}\n          onClose={() => setShowCommandMenu(false)}\n          onSelect={handleCommandSelect}\n          anchorElement={commandMenuAnchor}\n          nodeId={textNode.id}\n          onUploadImage={onUploadImage}\n        />\n      )}\n    </>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/image-block.tsx",
      "content": "/**\n * ImageBlock Component\n *\n * Renders an image node with upload state, loading indicator, and error handling\n */\n\n\"use client\"\n\nimport React, { useState } from \"react\"\nimport { ImageIcon, Loader2, X } from \"lucide-react\"\n\nimport { Button } from \"../button\"\nimport { Card } from \"../card\"\nimport { Checkbox } from \"../checkbox\"\nimport { Skeleton } from \"../skeleton\"\nimport { TextNode } from \"./types\"\n\ninterface ImageBlockProps {\n  node: TextNode\n  isActive: boolean\n  onClick: () => void\n  onDelete?: () => void\n  onDragStart?: (nodeId: string) => void\n  isSelected?: boolean\n  onToggleSelection?: (nodeId: string) => void\n  onClickWithModifier?: (e: React.MouseEvent, nodeId: string) => void\n}\n\nexport function ImageBlock({\n  node,\n  isActive,\n  onClick,\n  onDelete,\n  onDragStart,\n  isSelected = false,\n  onToggleSelection,\n  onClickWithModifier,\n}: ImageBlockProps) {\n  const [imageError, setImageError] = useState(false)\n\n  const handleClick = (e: React.MouseEvent) => {\n    // Check for Ctrl/Cmd click first\n    if (onClickWithModifier) {\n      onClickWithModifier(e, node.id)\n    }\n\n    // Only call regular onClick if not a modifier click\n    if (!e.ctrlKey && !e.metaKey) {\n      onClick()\n    }\n  }\n\n  const handleDragStart = (e: React.DragEvent) => {\n    e.dataTransfer.effectAllowed = \"move\"\n    e.dataTransfer.setData(\"text/plain\", node.id)\n    e.dataTransfer.setData(\n      \"application/json\",\n      JSON.stringify({\n        nodeId: node.id,\n        type: node.type,\n        src: node.attributes?.src,\n      })\n    )\n    if (onDragStart) {\n      onDragStart(node.id)\n    }\n  }\n\n  const handleDragEnd = (e: React.DragEvent) => {}\n\n  const imageUrl = node.attributes?.src as string | undefined\n  const altText = node.attributes?.alt as string | undefined\n  const caption = node.content || \"\"\n  const isUploading =\n    node.attributes?.loading === \"true\" || node.attributes?.loading === true\n  const hasError =\n    node.attributes?.error === \"true\" || node.attributes?.error === true\n\n  const handleImageLoad = () => {\n    setImageError(false)\n  }\n\n  const handleImageError = () => {\n    setImageError(true)\n  }\n\n  return (\n    <Card\n      draggable\n      onDragStart={handleDragStart}\n      onDragEnd={handleDragEnd}\n      className={`group relative mb-4 cursor-move !border-0 p-4 transition-all duration-200 ${isActive ? \"ring-primary/50 bg-accent/5 ring-2\" : \"hover:bg-accent/5\"} ${isSelected ? \"bg-blue-500/10 ring-2 ring-blue-500\" : \"\"} `}\n      onClick={handleClick}\n    >\n      {/* Selection checkbox */}\n      {onToggleSelection && (\n        <div\n          className={`absolute top-2 left-2 z-10 transition-opacity ${\n            isSelected ? \"opacity-100\" : \"opacity-0 group-hover:opacity-100\"\n          }`}\n          onClick={(e: React.MouseEvent) => {\n            e.stopPropagation()\n          }}\n        >\n          <Checkbox\n            checked={isSelected}\n            onCheckedChange={() => onToggleSelection(node.id)}\n            className=\"bg-background h-5 w-5 border-2\"\n          />\n        </div>\n      )}\n\n      {/* Delete button */}\n      {onDelete && (\n        <Button\n          variant=\"destructive\"\n          size=\"icon\"\n          className=\"absolute top-2 right-2 z-10 h-8 w-8 opacity-0 transition-opacity group-hover:opacity-100\"\n          onClick={(e) => {\n            e.stopPropagation()\n            onDelete()\n          }}\n        >\n          <X className=\"h-4 w-4\" />\n        </Button>\n      )}\n\n      {/* Image container */}\n      <div className=\"relative w-full\">\n        {/* Uploading state - show spinner overlay */}\n        {isUploading && (\n          <div className=\"bg-muted/50 border-primary/50 flex h-64 w-full flex-col items-center justify-center rounded-lg border-2 border-dashed\">\n            <Loader2 className=\"text-primary mb-3 h-12 w-12 animate-spin\" />\n            <p className=\"text-foreground text-sm font-medium\">\n              Uploading image...\n            </p>\n            <p className=\"text-muted-foreground mt-1 text-xs\">Please wait</p>\n          </div>\n        )}\n\n        {/* Error state (from upload failure) */}\n        {!isUploading && hasError && (\n          <div className=\"bg-destructive/10 border-destructive/50 flex h-64 w-full flex-col items-center justify-center rounded-lg border-2 border-dashed\">\n            <X className=\"text-destructive mb-2 h-12 w-12\" />\n            <p className=\"text-destructive text-sm font-medium\">\n              Upload Failed\n            </p>\n            <p className=\"text-muted-foreground mt-1 text-xs\">\n              Please try again\n            </p>\n          </div>\n        )}\n\n        {/* Normal image loading/error states */}\n        {!isUploading && !hasError && (\n          <>\n            {/* Error state */}\n            {imageError && (\n              <div className=\"bg-muted border-muted-foreground/25 flex h-64 w-full flex-col items-center justify-center rounded-lg border-2 border-dashed\">\n                <ImageIcon className=\"text-muted-foreground/50 mb-2 h-12 w-12\" />\n                <p className=\"text-muted-foreground text-sm\">\n                  Failed to load image\n                </p>\n                {imageUrl && (\n                  <p className=\"text-muted-foreground/70 mt-1 max-w-xs truncate text-xs\">\n                    {imageUrl}\n                  </p>\n                )}\n              </div>\n            )}\n\n            {/* Actual image */}\n            {imageUrl && (\n              <img\n                src={imageUrl}\n                alt={altText || caption || \"Uploaded image\"}\n                className=\"h-auto max-h-[600px] rounded-lg object-cover\"\n                style={{ width: \"auto\", margin: \"auto\" }}\n                onLoad={handleImageLoad}\n                onError={handleImageError}\n              />\n            )}\n\n            {/* Caption */}\n            {caption && (\n              <p className=\"text-muted-foreground mt-3 text-center text-sm italic\">\n                {caption}\n              </p>\n            )}\n          </>\n        )}\n      </div>\n    </Card>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/flex-container.tsx",
      "content": "/**\n * FlexContainer Component\n *\n * Renders a flex container with drag-and-drop support for reordering/adding images\n * Shows visual indicators on left/right edges when dragging images\n */\n\n\"use client\"\n\nimport React, { useState } from \"react\"\n\nimport { ContainerNode } from \"./types\"\n\ninterface FlexContainerProps {\n  node: ContainerNode\n  children: React.ReactNode\n  onDragOver?: (e: React.DragEvent, position: \"left\" | \"right\" | null) => void\n  onDragLeave?: (e: React.DragEvent) => void\n  onDrop?: (e: React.DragEvent, position: \"left\" | \"right\" | null) => void\n  dragOverPosition?: \"left\" | \"right\" | null\n  className?: string\n}\n\nexport function FlexContainer({\n  node,\n  children,\n  onDragOver,\n  onDragLeave,\n  onDrop,\n  dragOverPosition,\n  className = \"\",\n}: FlexContainerProps) {\n  const [localDragPosition, setLocalDragPosition] = useState<\n    \"left\" | \"right\" | null\n  >(null)\n\n  const gap = node.attributes?.gap as string | undefined\n  const flexWrap = node.attributes?.flexWrap as string | undefined\n\n  const handleDragOver = (e: React.DragEvent) => {\n    // Only prevent default and handle if we're in an edge zone\n    // This allows images to be dragged out of the container\n\n    // Get the container's bounding rectangle\n    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect()\n\n    // Define edge threshold (30% from each edge)\n    const edgeThreshold = rect.width * 0.3\n\n    // Determine if we're near the left or right edge\n    let position: \"left\" | \"right\" | null = null\n\n    if (e.clientX < rect.left + edgeThreshold) {\n      position = \"left\"\n    } else if (e.clientX > rect.right - edgeThreshold) {\n      position = \"right\"\n    }\n\n    // Only handle if we're in an edge zone\n    if (position) {\n      e.preventDefault()\n      e.stopPropagation()\n      setLocalDragPosition(position)\n\n      if (onDragOver) {\n        onDragOver(e, position)\n      }\n    } else {\n      // Not in an edge zone - clear any indicators but don't prevent default\n      // This allows the drag to bubble up to parent handlers\n      setLocalDragPosition(null)\n    }\n  }\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    // Only clear if we're actually leaving the element (not entering a child)\n    const relatedTarget = e.relatedTarget as HTMLElement\n    const currentTarget = e.currentTarget as HTMLElement\n\n    if (!currentTarget.contains(relatedTarget)) {\n      setLocalDragPosition(null)\n\n      if (onDragLeave) {\n        onDragLeave(e)\n      }\n    }\n  }\n\n  const handleDrop = (e: React.DragEvent) => {\n    const position = localDragPosition\n\n    // Only handle the drop if we have a position (in an edge zone)\n    if (position) {\n      e.preventDefault()\n      e.stopPropagation()\n\n      if (onDrop) {\n        onDrop(e, position)\n      }\n    }\n\n    // Always clear the position indicator\n    setLocalDragPosition(null)\n  }\n\n  const displayPosition = dragOverPosition ?? localDragPosition\n\n  return (\n    <div\n      data-node-id={node.id}\n      data-node-type=\"container\"\n      data-layout-type=\"flex\"\n      className={`relative flex flex-row gap-${gap || \"4\"} items-start ${flexWrap === \"wrap\" ? \"flex-wrap items-center\" : \"\"} ${className} `}\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n    >\n      {/* Left edge indicator */}\n      {displayPosition === \"left\" && (\n        <div className=\"pointer-events-none absolute inset-y-0 -left-1 z-10 w-1 rounded-full bg-blue-500/50\" />\n      )}\n\n      {/* Right edge indicator */}\n      {displayPosition === \"right\" && (\n        <div className=\"pointer-events-none absolute inset-y-0 -right-1 z-10 w-1 rounded-full bg-blue-500/50\" />\n      )}\n\n      {children}\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/add-block-button.tsx",
      "content": "/**\n * AddBlockButton Component\n *\n * Shows a button between blocks to add new content\n * Appears on hover for better UX\n */\n\n\"use client\"\n\nimport React, { useState } from \"react\"\nimport { Plus } from \"lucide-react\"\n\nimport { Button } from \"../button\"\n\ninterface AddBlockButtonProps {\n  onAdd: () => void\n  position?: \"before\" | \"after\"\n}\n\nexport function AddBlockButton({\n  onAdd,\n  position = \"after\",\n}: AddBlockButtonProps) {\n  const [isHovered, setIsHovered] = useState(false)\n\n  return (\n    <div\n      className=\"group relative flex h-3 items-center justify-center transition-all\"\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n    >\n      {/* Hover area - full width */}\n      <div className=\"absolute inset-0 w-full\" />\n\n      {/* Divider line - shows on hover */}\n      <div\n        className={`absolute inset-0 flex items-center justify-center transition-opacity ${isHovered ? \"opacity-100\" : \"opacity-0\"} `}\n      >\n        <div className=\"bg-border h-px w-full\" />\n      </div>\n\n      {/* Add button - shows on hover */}\n      <Button\n        variant=\"outline\"\n        size=\"sm\"\n        className={`relative z-10 h-6 gap-1 px-2 shadow-sm transition-all ${isHovered ? \"scale-100 opacity-100\" : \"pointer-events-none scale-95 opacity-0\"} `}\n        onClick={(e) => {\n          e.stopPropagation()\n          onAdd()\n        }}\n      >\n        <Plus className=\"h-3 w-3\" />\n        <span className=\"text-xs\">Add block</span>\n      </Button>\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/block-context-menu.tsx",
      "content": "\"use client\"\n\nimport React, { useMemo, useState } from \"react\"\nimport { Church, PaintBucket } from \"lucide-react\"\nimport { useTheme } from \"next-themes\"\n\nimport { Button } from \"../button\"\nimport {\n  ContextMenu,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuTrigger,\n} from \"../context-menu\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n} from \"../dialog\"\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"../tabs\"\nimport {\n  ColorPickerAlpha,\n  ColorPickerEyeDropper,\n  ColorPickerFormat,\n  ColorPickerHue,\n  ColorPickerOutput,\n  ColorPickerSelection,\n  ColorPicker as ShadcnColorPicker,\n} from \"./color-picker-index\"\n\ninterface BlockContextMenuProps {\n  children: React.ReactNode\n  onBackgroundColorChange: (color: string) => void\n  currentBackgroundColor?: string\n  readOnly?: boolean\n}\n\n// Light mode colors - subtle, light backgrounds\nconst lightModeColors = [\n  { name: \"None\", hex: \"transparent\" },\n  { name: \"Red\", hex: \"#fef2f2\" },\n  { name: \"Orange\", hex: \"#fff7ed\" },\n  { name: \"Yellow\", hex: \"#fefce8\" },\n  { name: \"Green\", hex: \"#f0fdf4\" },\n  { name: \"Blue\", hex: \"#eff6ff\" },\n  { name: \"Indigo\", hex: \"#eef2ff\" },\n  { name: \"Purple\", hex: \"#faf5ff\" },\n  { name: \"Pink\", hex: \"#fdf2f8\" },\n  { name: \"Teal\", hex: \"#f0fdfa\" },\n  { name: \"Cyan\", hex: \"#ecfeff\" },\n  { name: \"Gray\", hex: \"#f9fafb\" },\n]\n\n// Dark mode colors - darker, more saturated backgrounds\nconst darkModeColors = [\n  { name: \"None\", hex: \"transparent\" },\n  { name: \"Red\", hex: \"#450a0a\" },\n  { name: \"Orange\", hex: \"#431407\" },\n  { name: \"Yellow\", hex: \"#422006\" },\n  { name: \"Green\", hex: \"#052e16\" },\n  { name: \"Blue\", hex: \"#172554\" },\n  { name: \"Indigo\", hex: \"#1e1b4b\" },\n  { name: \"Purple\", hex: \"#2e1065\" },\n  { name: \"Pink\", hex: \"#500724\" },\n  { name: \"Teal\", hex: \"#042f2e\" },\n  { name: \"Cyan\", hex: \"#164e63\" },\n  { name: \"Gray\", hex: \"#1f2937\" },\n]\n\nexport function BlockContextMenu({\n  children,\n  onBackgroundColorChange,\n  currentBackgroundColor,\n  readOnly = false,\n}: BlockContextMenuProps) {\n  const [isDialogOpen, setIsDialogOpen] = useState(false)\n  const [customColor, setCustomColor] = useState(\"#ffffff\")\n  const [displayColor, setDisplayColor] = useState(\"#ffffff\")\n\n  // Get current theme\n  const { theme, resolvedTheme } = useTheme()\n\n  // Determine which color preset to use based on theme\n  // resolvedTheme is 'light' or 'dark' (resolves 'system' to actual theme)\n  const presetColors = useMemo(() => {\n    const currentTheme = resolvedTheme || theme\n    return currentTheme === \"dark\" ? darkModeColors : lightModeColors\n  }, [theme, resolvedTheme])\n\n  const handleCustomColorChange = (value: any) => {\n    let hexColor = \"#ffffff\"\n\n    if (typeof value === \"string\") {\n      hexColor = value\n    } else if (Array.isArray(value)) {\n      // Extract RGB values (ignore alpha - it's the 4th element)\n      const [r, g, b] = value\n\n      // Ensure RGB values are valid numbers, clamp to 0-255 range\n      const rValue = Math.max(0, Math.min(255, Math.round(r || 0)))\n      const gValue = Math.max(0, Math.min(255, Math.round(g || 0)))\n      const bValue = Math.max(0, Math.min(255, Math.round(b || 0)))\n\n      hexColor = `#${rValue.toString(16).padStart(2, \"0\")}${gValue\n        .toString(16)\n        .padStart(2, \"0\")}${bValue.toString(16).padStart(2, \"0\")}`\n    }\n\n    setCustomColor(hexColor)\n    setDisplayColor(hexColor)\n  }\n\n  const handlePresetColorSelect = (color: string) => {\n    onBackgroundColorChange(color)\n    setIsDialogOpen(false)\n  }\n\n  const handleApplyCustomColor = () => {\n    onBackgroundColorChange(customColor)\n    setIsDialogOpen(false)\n  }\n\n  return (\n    <React.Fragment key={readOnly ? \"readonly\" : \"editable\"}>\n      {readOnly ? (\n        children\n      ) : (\n        <ContextMenu>\n          <ContextMenuTrigger asChild>{children}</ContextMenuTrigger>\n          <ContextMenuContent className=\"w-56\">\n            <ContextMenuItem\n              onClick={() => setIsDialogOpen(true)}\n              className=\"gap-2\"\n            >\n              <PaintBucket className=\"size-4\" />\n              <span>Change Background Color</span>\n            </ContextMenuItem>\n          </ContextMenuContent>\n        </ContextMenu>\n      )}\n\n      {!readOnly && (\n        <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>\n          <DialogContent className=\"overflow-y-auto sm:max-w-[450px]\">\n            <DialogHeader>\n              <DialogTitle>Block Background Color</DialogTitle>\n              <DialogDescription>\n                Choose a background color for this block\n              </DialogDescription>\n            </DialogHeader>\n\n            <Tabs defaultValue=\"preset\" className=\"w-full\">\n              <TabsList className=\"grid w-full grid-cols-2\">\n                <TabsTrigger value=\"preset\">Preset Colors</TabsTrigger>\n                <TabsTrigger value=\"custom\">Custom Color</TabsTrigger>\n              </TabsList>\n\n              <TabsContent value=\"preset\" className=\"space-y-3 pt-4\">\n                <h4 className=\"text-sm font-medium\">Background Colors</h4>\n                <div className=\"grid grid-cols-4 gap-2\">\n                  {presetColors.map((color) => (\n                    <button\n                      key={color.hex}\n                      onClick={() => handlePresetColorSelect(color.hex)}\n                      className={`h-16 rounded-md border-2 transition-all hover:scale-105 hover:shadow-md ${\n                        currentBackgroundColor === color.hex\n                          ? \"border-primary ring-primary ring-2 ring-offset-2\"\n                          : \"border-border\"\n                      }`}\n                      title={color.name}\n                      style={{\n                        backgroundColor: color.hex,\n                        backgroundImage:\n                          color.hex === \"transparent\"\n                            ? \"linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc)\"\n                            : \"none\",\n                        backgroundSize:\n                          color.hex === \"transparent\" ? \"10px 10px\" : \"auto\",\n                        backgroundPosition:\n                          color.hex === \"transparent\"\n                            ? \"0 0, 5px 5px\"\n                            : \"initial\",\n                      }}\n                    >\n                      <span className=\"text-foreground/60 text-xs font-medium\">\n                        {color.name}\n                      </span>\n                    </button>\n                  ))}\n                </div>\n              </TabsContent>\n\n              <TabsContent value=\"custom\" className=\"space-y-3 pt-4\">\n                <ShadcnColorPicker\n                  defaultValue=\"#ffffff\"\n                  onChange={handleCustomColorChange}\n                  className=\"bg-background w-full rounded-md border p-3 shadow-sm\"\n                >\n                  <ColorPickerSelection className=\"\" />\n                  <div className=\"mt-2 flex items-center gap-2\">\n                    <ColorPickerEyeDropper />\n                    <div className=\"grid w-full gap-1\">\n                      <ColorPickerHue />\n                      <ColorPickerAlpha />\n                    </div>\n                  </div>\n                  <div className=\"mt-2 flex items-center gap-2\">\n                    <ColorPickerOutput className=\"flex-1\" />\n                    <ColorPickerFormat />\n                  </div>\n                </ShadcnColorPicker>\n\n                <div className=\"flex items-center justify-between gap-3\">\n                  <div className=\"flex min-w-0 flex-1 items-center gap-2\">\n                    <div\n                      className=\"h-8 w-8 shrink-0 rounded border\"\n                      style={{ backgroundColor: displayColor }}\n                    />\n                    <span className=\"truncate font-mono text-xs font-medium\">\n                      {displayColor}\n                    </span>\n                  </div>\n                  <Button\n                    onClick={handleApplyCustomColor}\n                    size=\"sm\"\n                    className=\"shrink-0\"\n                  >\n                    Apply\n                  </Button>\n                </div>\n              </TabsContent>\n            </Tabs>\n          </DialogContent>\n        </Dialog>\n      )}\n    </React.Fragment>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/color-picker.tsx",
      "content": "\"use client\"\n\nimport { useRef, useState } from \"react\"\nimport { Palette } from \"lucide-react\"\n\nimport { Button } from \"../button\"\nimport { Popover, PopoverContent, PopoverTrigger } from \"../popover\"\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"../tabs\"\nimport {\n  ColorPickerAlpha,\n  ColorPickerEyeDropper,\n  ColorPickerFormat,\n  ColorPickerHue,\n  ColorPickerOutput,\n  ColorPickerSelection,\n  ColorPicker as ShadcnColorPicker,\n} from \"./color-picker-index\"\n\ninterface ColorPickerComponentProps {\n  disabled?: boolean\n  onColorSelect: (color: string) => void\n  selectedColor?: string\n}\n\nconst presetColors = [\n  { name: \"Red\", hex: \"#ef4444\" },\n  { name: \"Orange\", hex: \"#f97316\" },\n  { name: \"Yellow\", hex: \"#eab308\" },\n  { name: \"Green\", hex: \"#22c55e\" },\n  { name: \"Blue\", hex: \"#3b82f6\" },\n  { name: \"Indigo\", hex: \"#6366f1\" },\n  { name: \"Purple\", hex: \"#a855f7\" },\n  { name: \"Pink\", hex: \"#ec4899\" },\n  { name: \"Teal\", hex: \"#14b8a6\" },\n  { name: \"Cyan\", hex: \"#06b6d4\" },\n]\n\nexport function ColorPickerComponent({\n  disabled,\n  onColorSelect,\n  selectedColor,\n}: ColorPickerComponentProps) {\n  // Start with a vibrant blue so it's clearly not white\n  const [displayColor, setDisplayColor] = useState(\"rgb(59, 130, 246)\")\n  const customColorRef = useRef<string>(\"#3b82f6\")\n\n  const handleCustomColorChange = (value: any) => {\n    let hexColor = \"#000000\"\n\n    if (typeof value === \"string\") {\n      hexColor = value\n    } else if (Array.isArray(value)) {\n      // Extract RGB values (ignore alpha - it's the 4th element and can be NaN)\n      const [r, g, b] = value\n\n      // Ensure RGB values are valid numbers, clamp to 0-255 range\n      const rValue = Math.max(0, Math.min(255, Math.round(r || 0)))\n      const gValue = Math.max(0, Math.min(255, Math.round(g || 0)))\n      const bValue = Math.max(0, Math.min(255, Math.round(b || 0)))\n\n      hexColor = `#${rValue.toString(16).padStart(2, \"0\")}${gValue.toString(16).padStart(2, \"0\")}${bValue.toString(16).padStart(2, \"0\")}`\n    }\n\n    // Update ref with the current color\n    customColorRef.current = hexColor\n    // Update display\n    setDisplayColor(hexColor)\n  }\n\n  const handleApplyCustomColor = () => {\n    // Send the hex color directly (we'll handle it as inline style)\n    const hexColor = customColorRef.current\n    onColorSelect(hexColor)\n  }\n\n  return (\n    <Popover>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          disabled={disabled}\n          className=\"h-7 gap-1 px-2 md:h-8 md:gap-2 md:px-3\"\n        >\n          <Palette className=\"size-3 md:size-4\" />\n          <span className=\"text-xs md:text-sm\">Color</span>\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-[calc(100vw-2rem)] max-w-96 sm:w-96\">\n        <Tabs defaultValue=\"preset\" className=\"w-full\">\n          <TabsList className=\"grid w-full grid-cols-2\">\n            <TabsTrigger value=\"preset\">Preset Colors</TabsTrigger>\n            <TabsTrigger value=\"custom\">Custom Color</TabsTrigger>\n          </TabsList>\n\n          <TabsContent value=\"preset\" className=\"space-y-3\">\n            <h4 className=\"text-sm font-medium\">Text Colors</h4>\n            <div className=\"grid grid-cols-5 gap-2\">\n              {presetColors.map((color) => (\n                <button\n                  key={color.hex}\n                  onClick={() => onColorSelect(color.hex)}\n                  className={`h-10 rounded-md border-2 transition-all hover:scale-110 ${\n                    selectedColor === color.hex\n                      ? \"border-foreground\"\n                      : \"border-border\"\n                  }`}\n                  title={color.name}\n                  style={{ color: color.hex }}\n                >\n                  <span className=\"text-2xl font-bold\">A</span>\n                </button>\n              ))}\n            </div>\n          </TabsContent>\n\n          <TabsContent value=\"custom\" className=\"space-y-3\">\n            <h4 className=\"text-sm font-medium\">Custom Color Picker</h4>\n            <ShadcnColorPicker\n              defaultValue=\"#3b82f6\"\n              onChange={handleCustomColorChange}\n              className=\"bg-background w-full rounded-md border p-4 shadow-sm\"\n            >\n              <ColorPickerSelection className=\"h-32\" />\n              <div className=\"flex items-center gap-4\">\n                <ColorPickerEyeDropper />\n                <div className=\"grid w-full gap-1\">\n                  <ColorPickerHue />\n                  <ColorPickerAlpha />\n                </div>\n              </div>\n              <div className=\"flex items-center gap-2\">\n                <ColorPickerOutput />\n                <ColorPickerFormat />\n              </div>\n            </ShadcnColorPicker>\n            <Button\n              onClick={handleApplyCustomColor}\n              className=\"w-full\"\n              size=\"sm\"\n            >\n              Apply Custom Color\n            </Button>\n            <div className=\"flex items-center gap-2 rounded-md border p-2\">\n              <div\n                className=\"h-8 w-8 rounded border\"\n                style={{ backgroundColor: displayColor }}\n              />\n              <span className=\"font-mono text-xs\">{displayColor}</span>\n            </div>\n          </TabsContent>\n        </Tabs>\n      </PopoverContent>\n    </Popover>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/color-picker-index.tsx",
      "content": "\"use client\"\n\nimport {\n  createContext,\n  memo,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ComponentProps,\n  type HTMLAttributes,\n} from \"react\"\nimport * as Slider from \"@radix-ui/react-slider\"\nimport Color from \"color\"\nimport { PipetteIcon } from \"lucide-react\"\n\nimport { Button } from \"../button\"\nimport { Input } from \"../input\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"../select\"\nimport { cn } from \"./lib/utils\"\n\ninterface ColorPickerContextValue {\n  hue: number\n  saturation: number\n  lightness: number\n  alpha: number\n  mode: string\n  setHue: (hue: number) => void\n  setSaturation: (saturation: number) => void\n  setLightness: (lightness: number) => void\n  setAlpha: (alpha: number) => void\n  setMode: (mode: string) => void\n}\n\nconst ColorPickerContext = createContext<ColorPickerContextValue | undefined>(\n  undefined\n)\n\nexport const useColorPicker = () => {\n  const context = useContext(ColorPickerContext)\n\n  if (!context) {\n    throw new Error(\"useColorPicker must be used within a ColorPickerProvider\")\n  }\n\n  return context\n}\n\nexport type ColorPickerProps = HTMLAttributes<HTMLDivElement> & {\n  value?: Parameters<typeof Color>[0]\n  defaultValue?: Parameters<typeof Color>[0]\n  onChange?: (value: Parameters<typeof Color.rgb>[0]) => void\n}\n\nexport const ColorPicker = ({\n  value,\n  defaultValue = \"#000000\",\n  onChange,\n  className,\n  ...props\n}: ColorPickerProps) => {\n  const selectedColor = Color(value)\n  const defaultColor = Color(defaultValue)\n\n  const [hue, setHue] = useState(selectedColor.hue() || defaultColor.hue() || 0)\n  const [saturation, setSaturation] = useState(\n    selectedColor.saturationl() || defaultColor.saturationl() || 100\n  )\n  const [lightness, setLightness] = useState(\n    selectedColor.lightness() || defaultColor.lightness() || 50\n  )\n  const [alpha, setAlpha] = useState(\n    selectedColor.alpha() * 100 || defaultColor.alpha() * 100\n  )\n  const [mode, setMode] = useState(\"hex\")\n\n  // Update color when controlled value changes\n  useEffect(() => {\n    if (value) {\n      const color = Color.rgb(value).rgb().object()\n\n      setHue(color.r)\n      setSaturation(color.g)\n      setLightness(color.b)\n      setAlpha(color.a)\n    }\n  }, [value])\n\n  // Notify parent of changes\n  useEffect(() => {\n    if (onChange) {\n      const color = Color.hsl(hue, saturation, lightness).alpha(alpha / 100)\n      const rgba = color.rgb().array()\n\n      onChange([rgba[0], rgba[1], rgba[2], alpha / 100])\n    }\n  }, [hue, saturation, lightness, alpha, onChange])\n\n  return (\n    <ColorPickerContext.Provider\n      value={{\n        hue,\n        saturation,\n        lightness,\n        alpha,\n        mode,\n        setHue,\n        setSaturation,\n        setLightness,\n        setAlpha,\n        setMode,\n      }}\n    >\n      <div\n        className={cn(\"flex size-full flex-col gap-4\", className)}\n        {...props}\n      />\n    </ColorPickerContext.Provider>\n  )\n}\n\nexport type ColorPickerSelectionProps = HTMLAttributes<HTMLDivElement>\n\nexport const ColorPickerSelection = memo(\n  ({ className, ...props }: ColorPickerSelectionProps) => {\n    const containerRef = useRef<HTMLDivElement>(null)\n    const [isDragging, setIsDragging] = useState(false)\n    const [positionX, setPositionX] = useState(0)\n    const [positionY, setPositionY] = useState(0)\n    const { hue, setSaturation, setLightness } = useColorPicker()\n\n    const backgroundGradient = useMemo(() => {\n      return `linear-gradient(0deg, rgba(0,0,0,1), rgba(0,0,0,0)),\n            linear-gradient(90deg, rgba(255,255,255,1), rgba(255,255,255,0)),\n            hsl(${hue}, 100%, 50%)`\n    }, [hue])\n\n    const handlePointerMove = useCallback(\n      (event: PointerEvent) => {\n        if (!(isDragging && containerRef.current)) {\n          return\n        }\n        const rect = containerRef.current.getBoundingClientRect()\n        const x = Math.max(\n          0,\n          Math.min(1, (event.clientX - rect.left) / rect.width)\n        )\n        const y = Math.max(\n          0,\n          Math.min(1, (event.clientY - rect.top) / rect.height)\n        )\n        setPositionX(x)\n        setPositionY(y)\n        setSaturation(x * 100)\n        const topLightness = x < 0.01 ? 100 : 50 + 50 * (1 - x)\n        const lightness = topLightness * (1 - y)\n\n        setLightness(lightness)\n      },\n      [isDragging, setSaturation, setLightness]\n    )\n\n    useEffect(() => {\n      const handlePointerUp = () => setIsDragging(false)\n\n      if (isDragging) {\n        window.addEventListener(\"pointermove\", handlePointerMove)\n        window.addEventListener(\"pointerup\", handlePointerUp)\n      }\n\n      return () => {\n        window.removeEventListener(\"pointermove\", handlePointerMove)\n        window.removeEventListener(\"pointerup\", handlePointerUp)\n      }\n    }, [isDragging, handlePointerMove])\n\n    return (\n      <div\n        className={cn(\"relative size-full cursor-crosshair rounded\", className)}\n        onPointerDown={(e) => {\n          e.preventDefault()\n          setIsDragging(true)\n          handlePointerMove(e.nativeEvent)\n        }}\n        ref={containerRef}\n        style={{\n          background: backgroundGradient,\n        }}\n        {...props}\n      >\n        <div\n          className=\"pointer-events-none absolute h-4 w-4 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 border-white\"\n          style={{\n            left: `${positionX * 100}%`,\n            top: `${positionY * 100}%`,\n            boxShadow: \"0 0 0 1px rgba(0,0,0,0.5)\",\n          }}\n        />\n      </div>\n    )\n  }\n)\n\nColorPickerSelection.displayName = \"ColorPickerSelection\"\n\nexport type ColorPickerHueProps = ComponentProps<typeof Slider.Root>\n\nexport const ColorPickerHue = ({\n  className,\n  ...props\n}: ColorPickerHueProps) => {\n  const { hue, setHue } = useColorPicker()\n\n  return (\n    <Slider.Root\n      className={cn(\"relative flex h-4 w-full touch-none\", className)}\n      max={360}\n      onValueChange={([hue]) => setHue(hue)}\n      step={1}\n      value={[hue]}\n      {...props}\n    >\n      <Slider.Track className=\"relative my-0.5 h-3 w-full grow rounded-full bg-[linear-gradient(90deg,#FF0000,#FFFF00,#00FF00,#00FFFF,#0000FF,#FF00FF,#FF0000)]\">\n        <Slider.Range className=\"absolute h-full\" />\n      </Slider.Track>\n      <Slider.Thumb className=\"border-primary/50 bg-background focus-visible:ring-ring block h-4 w-4 rounded-full border shadow transition-colors focus-visible:ring-1 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50\" />\n    </Slider.Root>\n  )\n}\n\nexport type ColorPickerAlphaProps = ComponentProps<typeof Slider.Root>\n\nexport const ColorPickerAlpha = ({\n  className,\n  ...props\n}: ColorPickerAlphaProps) => {\n  const { alpha, setAlpha } = useColorPicker()\n\n  return (\n    <Slider.Root\n      className={cn(\"relative flex h-4 w-full touch-none\", className)}\n      max={100}\n      onValueChange={([alpha]) => setAlpha(alpha)}\n      step={1}\n      value={[alpha]}\n      {...props}\n    >\n      <Slider.Track\n        className=\"relative my-0.5 h-3 w-full grow rounded-full\"\n        style={{\n          background:\n            'url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWAAJyRCgLaBCAAgXwixzAS0pgAAAABJRU5ErkJggg==\") left center',\n        }}\n      >\n        <div className=\"absolute inset-0 rounded-full bg-gradient-to-r from-transparent to-black/50\" />\n        <Slider.Range className=\"absolute h-full rounded-full bg-transparent\" />\n      </Slider.Track>\n      <Slider.Thumb className=\"border-primary/50 bg-background focus-visible:ring-ring block h-4 w-4 rounded-full border shadow transition-colors focus-visible:ring-1 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50\" />\n    </Slider.Root>\n  )\n}\n\nexport type ColorPickerEyeDropperProps = ComponentProps<typeof Button>\n\nexport const ColorPickerEyeDropper = ({\n  className,\n  ...props\n}: ColorPickerEyeDropperProps) => {\n  const { setHue, setSaturation, setLightness, setAlpha } = useColorPicker()\n\n  const handleEyeDropper = async () => {\n    try {\n      // @ts-expect-error - EyeDropper API is experimental\n      const eyeDropper = new EyeDropper()\n      const result = await eyeDropper.open()\n      const color = Color(result.sRGBHex)\n      const [h, s, l] = color.hsl().array()\n\n      setHue(h)\n      setSaturation(s)\n      setLightness(l)\n      setAlpha(100)\n    } catch (error) {\n      console.error(\"EyeDropper failed:\", error)\n    }\n  }\n\n  return (\n    <Button\n      className={cn(\"text-muted-foreground shrink-0\", className)}\n      onClick={handleEyeDropper}\n      size=\"icon\"\n      variant=\"outline\"\n      type=\"button\"\n      {...props}\n    >\n      <PipetteIcon size={16} />\n    </Button>\n  )\n}\n\nexport type ColorPickerOutputProps = ComponentProps<typeof SelectTrigger>\n\nconst formats = [\"hex\", \"rgb\", \"css\", \"hsl\"]\n\nexport const ColorPickerOutput = ({\n  className,\n  ...props\n}: ColorPickerOutputProps) => {\n  const { mode, setMode } = useColorPicker()\n\n  return (\n    <Select onValueChange={setMode} value={mode}>\n      <SelectTrigger className=\"h-8 w-20 shrink-0 text-xs\" {...props}>\n        <SelectValue placeholder=\"Mode\" />\n      </SelectTrigger>\n      <SelectContent>\n        {formats.map((format) => (\n          <SelectItem className=\"text-xs\" key={format} value={format}>\n            {format.toUpperCase()}\n          </SelectItem>\n        ))}\n      </SelectContent>\n    </Select>\n  )\n}\n\ntype PercentageInputProps = ComponentProps<typeof Input>\n\nconst PercentageInput = ({ className, ...props }: PercentageInputProps) => {\n  return (\n    <div className=\"relative\">\n      <Input\n        readOnly\n        type=\"text\"\n        {...props}\n        className={cn(\n          \"bg-secondary h-8 w-[3.25rem] rounded-l-none px-2 text-xs shadow-none\",\n          className\n        )}\n      />\n      <span className=\"text-muted-foreground absolute top-1/2 right-2 -translate-y-1/2 text-xs\">\n        %\n      </span>\n    </div>\n  )\n}\n\nexport type ColorPickerFormatProps = HTMLAttributes<HTMLDivElement>\n\nexport const ColorPickerFormat = ({\n  className,\n  ...props\n}: ColorPickerFormatProps) => {\n  const { hue, saturation, lightness, alpha, mode } = useColorPicker()\n  const color = Color.hsl(hue, saturation, lightness, alpha / 100)\n\n  if (mode === \"hex\") {\n    const hex = color.hex()\n\n    return (\n      <div\n        className={cn(\n          \"relative flex w-full items-center -space-x-px rounded-md shadow-sm\",\n          className\n        )}\n        {...props}\n      >\n        <Input\n          className=\"bg-secondary h-8 rounded-r-none px-2 text-xs shadow-none\"\n          readOnly\n          type=\"text\"\n          value={hex}\n        />\n        <PercentageInput value={alpha} />\n      </div>\n    )\n  }\n\n  if (mode === \"rgb\") {\n    const rgb = color\n      .rgb()\n      .array()\n      .map((value) => Math.round(value))\n\n    return (\n      <div\n        className={cn(\n          \"flex items-center -space-x-px rounded-md shadow-sm\",\n          className\n        )}\n        {...props}\n      >\n        {rgb.map((value, index) => (\n          <Input\n            className={cn(\n              \"bg-secondary h-8 rounded-r-none px-2 text-xs shadow-none\",\n              index && \"rounded-l-none\",\n              className\n            )}\n            key={index}\n            readOnly\n            type=\"text\"\n            value={value}\n          />\n        ))}\n        <PercentageInput value={alpha} />\n      </div>\n    )\n  }\n\n  if (mode === \"css\") {\n    const rgb = color\n      .rgb()\n      .array()\n      .map((value) => Math.round(value))\n\n    return (\n      <div className={cn(\"w-full rounded-md shadow-sm\", className)} {...props}>\n        <Input\n          className=\"bg-secondary h-8 w-full px-2 text-xs shadow-none\"\n          readOnly\n          type=\"text\"\n          value={`rgba(${rgb.join(\", \")}, ${alpha}%)`}\n          {...props}\n        />\n      </div>\n    )\n  }\n\n  if (mode === \"hsl\") {\n    const hsl = color\n      .hsl()\n      .array()\n      .map((value) => Math.round(value))\n\n    return (\n      <div\n        className={cn(\n          \"flex items-center -space-x-px rounded-md shadow-sm\",\n          className\n        )}\n        {...props}\n      >\n        {hsl.map((value, index) => (\n          <Input\n            className={cn(\n              \"bg-secondary h-8 rounded-r-none px-2 text-xs shadow-none\",\n              index && \"rounded-l-none\",\n              className\n            )}\n            key={index}\n            readOnly\n            type=\"text\"\n            value={value}\n          />\n        ))}\n        <PercentageInput value={alpha} />\n      </div>\n    )\n  }\n\n  return null\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/color-picker-interface.tsx",
      "content": "\"use client\"\n\nimport { useRef, useState } from \"react\"\nimport { Palette } from \"lucide-react\"\n\nimport { Button } from \"../button\"\nimport { Popover, PopoverContent, PopoverTrigger } from \"../popover\"\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"../tabs\"\nimport {\n  ColorPickerAlpha,\n  ColorPickerEyeDropper,\n  ColorPickerFormat,\n  ColorPickerHue,\n  ColorPickerOutput,\n  ColorPickerSelection,\n  ColorPicker as ShadcnColorPicker,\n} from \"./color-picker-index\"\n\ninterface ColorPickerComponentProps {\n  disabled?: boolean\n  onColorSelect: (color: string) => void\n  selectedColor?: string\n}\n\nconst presetColors = [\n  { name: \"Red\", hex: \"#ef4444\" },\n  { name: \"Orange\", hex: \"#f97316\" },\n  { name: \"Yellow\", hex: \"#eab308\" },\n  { name: \"Green\", hex: \"#22c55e\" },\n  { name: \"Blue\", hex: \"#3b82f6\" },\n  { name: \"Indigo\", hex: \"#6366f1\" },\n  { name: \"Purple\", hex: \"#a855f7\" },\n  { name: \"Pink\", hex: \"#ec4899\" },\n  { name: \"Teal\", hex: \"#14b8a6\" },\n  { name: \"Cyan\", hex: \"#06b6d4\" },\n]\n\nexport function ColorPickerComponent({\n  disabled,\n  onColorSelect,\n  selectedColor,\n}: ColorPickerComponentProps) {\n  // Start with a vibrant blue so it's clearly not white\n  const [displayColor, setDisplayColor] = useState(\"rgb(59, 130, 246)\")\n  const customColorRef = useRef<string>(\"#3b82f6\")\n\n  const handleCustomColorChange = (value: any) => {\n    let hexColor = \"#000000\"\n\n    if (typeof value === \"string\") {\n      hexColor = value\n    } else if (Array.isArray(value)) {\n      // Extract RGB values (ignore alpha - it's the 4th element and can be NaN)\n      const [r, g, b] = value\n\n      // Ensure RGB values are valid numbers, clamp to 0-255 range\n      const rValue = Math.max(0, Math.min(255, Math.round(r || 0)))\n      const gValue = Math.max(0, Math.min(255, Math.round(g || 0)))\n      const bValue = Math.max(0, Math.min(255, Math.round(b || 0)))\n\n      hexColor = `#${rValue.toString(16).padStart(2, \"0\")}${gValue.toString(16).padStart(2, \"0\")}${bValue.toString(16).padStart(2, \"0\")}`\n    }\n\n    // Update ref with the current color\n    customColorRef.current = hexColor\n    // Update display\n    setDisplayColor(hexColor)\n  }\n\n  const handleApplyCustomColor = () => {\n    // Send the hex color directly (we'll handle it as inline style)\n    const hexColor = customColorRef.current\n    onColorSelect(hexColor)\n  }\n\n  return (\n    <Popover>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          disabled={disabled}\n          className=\"h-7 gap-1 px-2 md:h-8 md:gap-2 md:px-3\"\n        >\n          <Palette className=\"size-3 md:size-4\" />\n          <span className=\"text-xs md:text-sm\">Color</span>\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-[calc(100vw-2rem)] max-w-96 sm:w-96\">\n        <Tabs defaultValue=\"preset\" className=\"w-full\">\n          <TabsList className=\"grid w-full grid-cols-2\">\n            <TabsTrigger value=\"preset\">Preset Colors</TabsTrigger>\n            <TabsTrigger value=\"custom\">Custom Color</TabsTrigger>\n          </TabsList>\n\n          <TabsContent value=\"preset\" className=\"space-y-3\">\n            <h4 className=\"text-sm font-medium\">Text Colors</h4>\n            <div className=\"grid grid-cols-5 gap-2\">\n              {presetColors.map((color) => (\n                <button\n                  key={color.hex}\n                  onClick={() => onColorSelect(color.hex)}\n                  className={`h-10 rounded-md border-2 transition-all hover:scale-110 ${\n                    selectedColor === color.hex\n                      ? \"border-foreground\"\n                      : \"border-border\"\n                  }`}\n                  title={color.name}\n                  style={{ color: color.hex }}\n                >\n                  <span className=\"text-2xl font-bold\">A</span>\n                </button>\n              ))}\n            </div>\n          </TabsContent>\n\n          <TabsContent value=\"custom\" className=\"space-y-3\">\n            <h4 className=\"text-sm font-medium\">Custom Color Picker</h4>\n            <ShadcnColorPicker\n              defaultValue=\"#3b82f6\"\n              onChange={handleCustomColorChange}\n              className=\"bg-background w-full rounded-md border p-4 shadow-sm\"\n            >\n              <ColorPickerSelection className=\"h-32\" />\n              <div className=\"flex items-center gap-4\">\n                <ColorPickerEyeDropper />\n                <div className=\"grid w-full gap-1\">\n                  <ColorPickerHue />\n                  <ColorPickerAlpha />\n                </div>\n              </div>\n              <div className=\"flex items-center gap-2\">\n                <ColorPickerOutput />\n                <ColorPickerFormat />\n              </div>\n            </ShadcnColorPicker>\n            <Button\n              onClick={handleApplyCustomColor}\n              className=\"w-full\"\n              size=\"sm\"\n            >\n              Apply Custom Color\n            </Button>\n            <div className=\"flex items-center gap-2 rounded-md border p-2\">\n              <div\n                className=\"h-8 w-8 rounded border\"\n                style={{ backgroundColor: displayColor }}\n              />\n              <span className=\"font-mono text-xs\">{displayColor}</span>\n            </div>\n          </TabsContent>\n        </Tabs>\n      </PopoverContent>\n    </Popover>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/command-menu.tsx",
      "content": "/**\n * CommandMenu Component\n *\n * A Notion-style command menu that appears when typing \"/\" in an empty block.\n * Provides searchable commands for changing block types (H1, H2, P, etc.)\n */\n\n\"use client\"\n\nimport React, { useCallback, useEffect, useRef, useState } from \"react\"\nimport {\n  Code,\n  Heading1,\n  Heading2,\n  Heading3,\n  Heading4,\n  Heading5,\n  Heading6,\n  Image,\n  List,\n  ListOrdered,\n  Quote,\n  Type,\n} from \"lucide-react\"\n\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"../command\"\nimport { Popover, PopoverAnchor, PopoverContent } from \"../popover\"\nimport { useEditor } from \"./context/editor-context\"\nimport { EditorActions } from \"./reducer/actions\"\n\nexport interface CommandOption {\n  label: string\n  value: string\n  icon: React.ReactNode\n  description?: string\n  keywords?: string[]\n}\n\ninterface CommandMenuProps {\n  isOpen: boolean\n  onClose: () => void\n  onSelect: (value: string) => void\n  anchorElement: HTMLElement | null\n  nodeId: string // ID of the block being transformed\n  onUploadImage?: (file: File) => Promise<string> // Custom image upload handler\n}\n\nconst commands: CommandOption[] = [\n  {\n    label: \"Heading 1\",\n    value: \"h1\",\n    icon: <Heading1 className=\"h-4 w-4\" />,\n    description: \"Big section heading\",\n    keywords: [\"h1\", \"heading\", \"title\", \"large\"],\n  },\n  {\n    label: \"Heading 2\",\n    value: \"h2\",\n    icon: <Heading2 className=\"h-4 w-4\" />,\n    description: \"Medium section heading\",\n    keywords: [\"h2\", \"heading\", \"subtitle\"],\n  },\n  {\n    label: \"Heading 3\",\n    value: \"h3\",\n    icon: <Heading3 className=\"h-4 w-4\" />,\n    description: \"Small section heading\",\n    keywords: [\"h3\", \"heading\", \"subheading\"],\n  },\n  {\n    label: \"Heading 4\",\n    value: \"h4\",\n    icon: <Heading4 className=\"h-4 w-4\" />,\n    description: \"Tiny section heading\",\n    keywords: [\"h4\", \"heading\"],\n  },\n  {\n    label: \"Heading 5\",\n    value: \"h5\",\n    icon: <Heading5 className=\"h-4 w-4\" />,\n    description: \"Smaller heading\",\n    keywords: [\"h5\", \"heading\"],\n  },\n  {\n    label: \"Heading 6\",\n    value: \"h6\",\n    icon: <Heading6 className=\"h-4 w-4\" />,\n    description: \"Smallest heading\",\n    keywords: [\"h6\", \"heading\"],\n  },\n  {\n    label: \"Paragraph\",\n    value: \"p\",\n    icon: <Type className=\"h-4 w-4\" />,\n    description: \"Regular text paragraph\",\n    keywords: [\"p\", \"paragraph\", \"text\", \"normal\"],\n  },\n  {\n    label: \"Code Block\",\n    value: \"code\",\n    icon: <Code className=\"h-4 w-4\" />,\n    description: \"Code snippet\",\n    keywords: [\"code\", \"codeblock\", \"snippet\", \"pre\"],\n  },\n  {\n    label: \"Quote\",\n    value: \"blockquote\",\n    icon: <Quote className=\"h-4 w-4\" />,\n    description: \"Block quote\",\n    keywords: [\"quote\", \"blockquote\", \"citation\"],\n  },\n  {\n    label: \"Bulleted List\",\n    value: \"ul\",\n    icon: <List className=\"h-4 w-4\" />,\n    description: \"Unordered list with bullets\",\n    keywords: [\"list\", \"bullet\", \"unordered\", \"ul\", \"li\"],\n  },\n  {\n    label: \"Numbered List\",\n    value: \"ol\",\n    icon: <ListOrdered className=\"h-4 w-4\" />,\n    description: \"Ordered list with numbers\",\n    keywords: [\"list\", \"numbered\", \"ordered\", \"ol\", \"li\"],\n  },\n  {\n    label: \"Image\",\n    value: \"img\",\n    icon: <Image className=\"h-4 w-4\" />,\n    description: \"Upload or embed an image\",\n    keywords: [\"image\", \"img\", \"picture\", \"photo\", \"upload\"],\n  },\n]\n\nexport function CommandMenu({\n  isOpen,\n  onClose,\n  onSelect,\n  anchorElement,\n  nodeId,\n  onUploadImage,\n}: CommandMenuProps) {\n  const [selectedIndex, setSelectedIndex] = useState(0)\n  const [search, setSearch] = useState(\"\")\n  const [isUploading, setIsUploading] = useState(false)\n  const commandRef = useRef<HTMLDivElement>(null)\n\n  const [, dispatch] = useEditor()\n\n  // Handle command selection - for image, we'll use dispatch directly here\n  const handleSelect = useCallback(\n    async (commandValue: string) => {\n      // Special handling for image - trigger file picker and upload\n      if (commandValue === \"img\") {\n        // Close the menu first\n        onClose()\n\n        // Create a hidden file input\n        const fileInput = document.createElement(\"input\")\n        fileInput.type = \"file\"\n        fileInput.accept = \"image/*\"\n        fileInput.style.display = \"none\"\n\n        fileInput.onchange = async (e) => {\n          const file = (e.target as HTMLInputElement).files?.[0]\n          if (!file) return\n\n          // Show loading state immediately\n          setIsUploading(true)\n\n          // Create placeholder image with loading state\n          requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n              dispatch(\n                EditorActions.updateNode(nodeId, {\n                  type: \"img\",\n                  content: \"\", // Empty caption initially\n                  attributes: {\n                    src: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjQwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iODAwIiBoZWlnaHQ9IjQwMCIgZmlsbD0iI2YzZjRmNiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5Y2EzYWYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5VcGxvYWRpbmcuLi48L3RleHQ+PC9zdmc+\",\n                    alt: \"Uploading...\",\n                    loading: \"true\", // Custom attribute to indicate loading\n                  },\n                })\n              )\n            })\n          })\n\n          try {\n            // Use custom upload handler if provided\n            let imageUrl: string\n\n            if (onUploadImage) {\n              imageUrl = await onUploadImage(file)\n            } else {\n              // Fallback: use default upload\n              const { uploadImage } = await import(\"./utils/image-upload\")\n              const result = await uploadImage(file)\n              if (!result.success || !result.url) {\n                throw new Error(result.error || \"Upload failed\")\n              }\n              imageUrl = result.url\n            }\n\n            // Update with actual image URL\n            requestAnimationFrame(() => {\n              requestAnimationFrame(() => {\n                dispatch(\n                  EditorActions.updateNode(nodeId, {\n                    type: \"img\",\n                    content: \"\", // Empty caption initially\n                    attributes: {\n                      src: imageUrl,\n                      alt: file.name,\n                    },\n                  })\n                )\n              })\n            })\n          } catch (error) {\n            console.error(\"Image upload failed:\", error)\n            // Revert to error state\n            requestAnimationFrame(() => {\n              requestAnimationFrame(() => {\n                dispatch(\n                  EditorActions.updateNode(nodeId, {\n                    type: \"img\",\n                    content: \"\",\n                    attributes: {\n                      src: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjQwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iODAwIiBoZWlnaHQ9IjQwMCIgZmlsbD0iI2ZlZjJmMiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiNlZjQ0NDQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5VcGxvYWQgRmFpbGVkPC90ZXh0Pjwvc3ZnPg==\",\n                      alt: \"Upload failed\",\n                      error: \"true\",\n                    },\n                  })\n                )\n              })\n            })\n          } finally {\n            setIsUploading(false)\n            // Clean up\n            document.body.removeChild(fileInput)\n          }\n        }\n\n        // Add to DOM and trigger click\n        document.body.appendChild(fileInput)\n        fileInput.click()\n        return\n      }\n\n      // For all other commands, call the original onSelect handler AFTER closing menu\n      onClose()\n      onSelect(commandValue)\n    },\n    [dispatch, nodeId, onSelect, onClose, onUploadImage]\n  )\n\n  // Filter commands based on search\n  const filteredCommands = search\n    ? commands.filter((cmd) => {\n        const searchLower = search.toLowerCase()\n        return (\n          cmd.label.toLowerCase().includes(searchLower) ||\n          cmd.value.toLowerCase().includes(searchLower) ||\n          cmd.keywords?.some((k) => k.toLowerCase().includes(searchLower))\n        )\n      })\n    : commands\n\n  // Reset selected index when filtered commands change\n  useEffect(() => {\n    setSelectedIndex(0)\n  }, [search])\n\n  // Handle keyboard navigation\n  useEffect(() => {\n    if (!isOpen) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault()\n        setSelectedIndex((prev) =>\n          prev < filteredCommands.length - 1 ? prev + 1 : prev\n        )\n      } else if (e.key === \"ArrowUp\") {\n        e.preventDefault()\n        setSelectedIndex((prev) => (prev > 0 ? prev - 1 : prev))\n      } else if (e.key === \"Enter\") {\n        e.preventDefault()\n        if (filteredCommands[selectedIndex]) {\n          handleSelect(filteredCommands[selectedIndex].value)\n        }\n      } else if (e.key === \"Escape\") {\n        e.preventDefault()\n        onClose()\n      }\n    }\n\n    document.addEventListener(\"keydown\", handleKeyDown)\n    return () => document.removeEventListener(\"keydown\", handleKeyDown)\n  }, [isOpen, selectedIndex, filteredCommands, handleSelect, onClose])\n\n  // Reset search when menu closes\n  useEffect(() => {\n    if (!isOpen) {\n      setSearch(\"\")\n    }\n  }, [isOpen])\n\n  // Don't render if there's no anchor element\n  if (!anchorElement) return null\n\n  return (\n    <Popover\n      open={isOpen}\n      onOpenChange={(open) => {\n        // Only close if explicitly requested\n        if (!open) {\n          onClose()\n        }\n      }}\n    >\n      <PopoverAnchor virtualRef={{ current: anchorElement }} />\n      <PopoverContent\n        side=\"bottom\"\n        align=\"start\"\n        className=\"w-[320px] p-0\"\n        onOpenAutoFocus={(e) => {\n          // Prevent stealing focus from the editor\n          e.preventDefault()\n        }}\n        onEscapeKeyDown={(e) => {\n          // Let Block component handle Escape\n          e.preventDefault()\n        }}\n        onFocusOutside={(e) => {\n          // Prevent closing when focus moves\n          e.preventDefault()\n        }}\n        onPointerDownOutside={(e) => {\n          // Prevent closing when clicking on the editor block\n          const target = e.target as HTMLElement\n          if (\n            target.closest('[contenteditable=\"true\"]') ||\n            target === anchorElement\n          ) {\n            e.preventDefault()\n          }\n        }}\n      >\n        <Command ref={commandRef} shouldFilter={false}>\n          <CommandInput\n            placeholder=\"Search commands...\"\n            value={search}\n            onValueChange={setSearch}\n            autoFocus\n          />\n          <CommandList>\n            <CommandEmpty>No commands found.</CommandEmpty>\n            <CommandGroup heading=\"Turn into\">\n              {filteredCommands.map((command, index) => (\n                <CommandItem\n                  key={command.value}\n                  value={command.value}\n                  onSelect={() => handleSelect(command.value)}\n                  className={`flex cursor-pointer items-start gap-3 px-3 py-2 ${index === selectedIndex ? \"bg-accent\" : \"\"} `}\n                >\n                  <div className=\"mt-0.5\">{command.icon}</div>\n                  <div className=\"flex flex-col\">\n                    <span className=\"font-medium\">{command.label}</span>\n                    {command.description && (\n                      <span className=\"text-muted-foreground text-xs\">\n                        {command.description}\n                      </span>\n                    )}\n                  </div>\n                </CommandItem>\n              ))}\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/custom-class-popover.tsx",
      "content": "/**\n * CustomClassPopover Component\n *\n * A floating popover that appears on text selection, allowing users to apply custom Tailwind classes\n * Uses useEditor internally to access and modify the editor state\n */\n\n\"use client\"\n\nimport React, { useEffect, useRef, useState } from \"react\"\nimport { motion } from \"framer-motion\"\nimport { Code2, Pencil, Search } from \"lucide-react\"\n\nimport { Button } from \"../button\"\nimport { Input } from \"../input\"\nimport { Popover, PopoverContent, PopoverTrigger } from \"../popover\"\nimport { ScrollArea } from \"../scroll-area\"\nimport {\n  Sheet,\n  SheetContent,\n  SheetHeader,\n  SheetTitle,\n  SheetTrigger,\n} from \"../sheet\"\nimport { Switch } from \"../switch\"\nimport {\n  getUserFriendlyClasses,\n  searchUserFriendlyClasses,\n} from \"./class-mappings\"\nimport { useEditor } from \"./context/editor-context\"\nimport { useIsMobile } from \"./hooks/use-mobile\"\nimport { useToast } from \"./hooks/use-toast\"\nimport { EditorActions } from \"./reducer/actions\"\nimport { tailwindClasses } from \"./tailwind-classes\"\n\nexport function CustomClassPopover() {\n  const [state, dispatch] = useEditor()\n  const { toast } = useToast()\n  const [searchQuery, setSearchQuery] = useState(\"\")\n  const [isOpen, setIsOpen] = useState(false)\n  const [devMode, setDevMode] = useState(false)\n  const [position, setPosition] = useState<{\n    top: number\n    left: number\n  } | null>(null)\n  const isMobile = useIsMobile()\n\n  // Store the selection in a ref so it persists when focus changes\n  const savedSelectionRef = useRef<{\n    nodeId: string\n    start: number\n    end: number\n    text: string\n  } | null>(null)\n\n  // Filter classes based on search and dev mode\n  const filteredClasses = devMode\n    ? // Dev Mode: Show Tailwind classes\n      searchQuery\n      ? tailwindClasses\n          .map((group) => ({\n            ...group,\n            classes: group.classes.filter((cls) =>\n              cls.toLowerCase().includes(searchQuery.toLowerCase())\n            ),\n          }))\n          .filter((group) => group.classes.length > 0)\n      : tailwindClasses\n    : // User Mode: Show user-friendly names\n      searchQuery\n      ? searchUserFriendlyClasses(searchQuery)\n      : getUserFriendlyClasses()\n\n  // Track selection and position the floating icon\n  useEffect(() => {\n    if (state.currentSelection && state.currentSelection.text.length > 0) {\n      // Save the selection to ref so it persists when focus changes\n      savedSelectionRef.current = {\n        nodeId: state.currentSelection.nodeId,\n        start: state.currentSelection.start,\n        end: state.currentSelection.end,\n        text: state.currentSelection.text,\n      }\n\n      const selection = window.getSelection()\n      if (selection && selection.rangeCount > 0) {\n        const range = selection.getRangeAt(0)\n        const rect = range.getBoundingClientRect()\n\n        // Calculate position relative to document (absolute positioning)\n        // Position the icon above the selection, centered\n        setPosition({\n          top: rect.top + window.scrollY - 45, // 45px above the selection + scroll offset\n          left: rect.left + window.scrollX + rect.width / 2 - 16, // Centered on selection + scroll offset\n        })\n      }\n    } else {\n      // Only clear position if we don't have a saved selection and popover is closed\n      if (!isOpen) {\n        setPosition(null)\n        savedSelectionRef.current = null\n      }\n    }\n  }, [state.currentSelection, state.selectionKey, isOpen])\n\n  // Close keyboard on mobile\n  const closeKeyboard = () => {\n    if (isMobile && document.activeElement instanceof HTMLElement) {\n      document.activeElement.blur()\n    }\n  }\n\n  // Handle opening the popover/sheet\n  const handleOpenChange = (open: boolean) => {\n    if (open && isMobile) {\n      closeKeyboard()\n      // Small delay to ensure keyboard is closed before opening\n      setTimeout(() => setIsOpen(true), 100)\n    } else {\n      setIsOpen(open)\n    }\n  }\n\n  // Handle class application\n  const handleQuickStyle = (className: string) => {\n    // Use saved selection from ref instead of state\n    if (!savedSelectionRef.current) return\n\n    // Temporarily restore the selection in state for the action\n    dispatch(\n      EditorActions.setCurrentSelection({\n        ...savedSelectionRef.current,\n        formats: { bold: false, italic: false, underline: false },\n      })\n    )\n\n    // Apply the custom class\n    setTimeout(() => {\n      dispatch(EditorActions.applyCustomClass(className))\n\n      toast({\n        title: \"Custom Class Applied\",\n        description: `Applied class: ${className}`,\n      })\n\n      setIsOpen(false)\n      setPosition(null)\n      savedSelectionRef.current = null\n    }, 0)\n  }\n\n  // Reusable content component for both Popover and Sheet\n  const ClassPickerContent = () => (\n    <div className=\"space-y-3\">\n      {/* Dev Mode Toggle */}\n      <div className=\"flex items-center justify-between border-b pb-2\">\n        <div className=\"flex items-center gap-2\">\n          <Code2 className=\"text-muted-foreground h-4 w-4\" />\n          <span className=\"text-sm font-medium\">Dev Mode</span>\n        </div>\n        <Switch\n          checked={devMode}\n          onCheckedChange={setDevMode}\n          aria-label=\"Toggle dev mode\"\n        />\n      </div>\n\n      <div className=\"relative\">\n        <Search className=\"text-muted-foreground absolute top-2.5 left-2 h-4 w-4\" />\n        <Input\n          autoFocus\n          placeholder={\n            devMode\n              ? \"Search classes... (e.g., 'text', 'bg', 'flex')\"\n              : \"Search styles... (e.g., 'red', 'bold', 'shadow')\"\n          }\n          value={searchQuery}\n          onChange={(e) => setSearchQuery(e.target.value)}\n          className=\"pl-8\"\n          onMouseDown={(e) => e.stopPropagation()}\n          onClick={(e) => e.stopPropagation()}\n        />\n      </div>\n      <ScrollArea className=\"h-[500px] pr-4\">\n        <div className=\"space-y-4\">\n          {devMode ? (\n            // Dev Mode: Show Tailwind classes\n            <>\n              {filteredClasses.map((group) => (\n                <div key={group.category}>\n                  <h4 className=\"text-muted-foreground mb-2 text-xs font-semibold\">\n                    {group.category}\n                  </h4>\n                  <div className=\"flex flex-wrap gap-1.5\">\n                    {(group as any).classes.map((cls: string) => (\n                      <Button\n                        key={cls}\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => handleQuickStyle(cls)}\n                        className=\"h-6 px-2 text-xs\"\n                      >\n                        {cls}\n                      </Button>\n                    ))}\n                  </div>\n                </div>\n              ))}\n            </>\n          ) : (\n            // User Mode: Show user-friendly names\n            <>\n              {filteredClasses.map((group) => (\n                <div key={group.category}>\n                  <h4 className=\"text-muted-foreground mb-2 text-xs font-semibold\">\n                    {group.category}\n                  </h4>\n                  <div className=\"flex flex-wrap gap-1.5\">\n                    {(group as any).items.map(\n                      (item: { label: string; value: string }) => (\n                        <Button\n                          key={item.value}\n                          variant=\"outline\"\n                          size=\"sm\"\n                          onClick={() => handleQuickStyle(item.value)}\n                          className=\"h-6 px-2 text-xs\"\n                          title={`Applies: ${item.value}`}\n                        >\n                          {item.label}\n                        </Button>\n                      )\n                    )}\n                  </div>\n                </div>\n              ))}\n            </>\n          )}\n          {filteredClasses.length === 0 && (\n            <div className=\"text-muted-foreground py-8 text-center text-sm\">\n              No classes found matching &quot;{searchQuery}&quot;\n            </div>\n          )}\n        </div>\n      </ScrollArea>\n    </div>\n  )\n\n  // Trigger button component\n  const TriggerButton = () => (\n    <button\n      className=\"bg-background border-border hover:border-primary flex h-8 w-8 items-center justify-center rounded-full border-2 shadow-lg transition-all hover:scale-110\"\n      onMouseDown={(e) => {\n        // Prevent default to keep the selection\n        e.preventDefault()\n        e.stopPropagation()\n      }}\n      onClick={(e) => {\n        // Prevent default to keep the selection\n        e.preventDefault()\n        e.stopPropagation()\n        if (isMobile) {\n          closeKeyboard()\n        }\n        setIsOpen(true)\n      }}\n    >\n      <Pencil className=\"size-4\" />\n    </button>\n  )\n\n  return (\n    <motion.div\n      layoutId=\"custom-class-popover\"\n      className={`${position ? \"opacity-100\" : \"!opacity-0\"} pointer-events-auto absolute z-[10000]`}\n      style={{\n        top: `${position?.top || 0}px`,\n        left: `${position?.left || 0}px`,\n      }}\n    >\n      {isMobile ? (\n        // Mobile: Use Sheet (drawer from bottom)\n        <Sheet open={isOpen} onOpenChange={handleOpenChange}>\n          <SheetTrigger asChild>\n            <TriggerButton />\n          </SheetTrigger>\n          <SheetContent\n            side=\"bottom\"\n            className=\"h-[85vh] rounded-t-xl\"\n            onOpenAutoFocus={(e) => {\n              // Prevent auto-focus to avoid reopening keyboard\n              e.preventDefault()\n            }}\n          >\n            <SheetHeader>\n              <SheetTitle>Custom Classes</SheetTitle>\n            </SheetHeader>\n            <div className=\"mt-4 h-[calc(100%-60px)] overflow-y-auto\">\n              <ClassPickerContent />\n            </div>\n          </SheetContent>\n        </Sheet>\n      ) : (\n        // Desktop: Use Popover\n        <Popover open={isOpen} onOpenChange={setIsOpen}>\n          <PopoverTrigger asChild>\n            <TriggerButton />\n          </PopoverTrigger>\n          <PopoverContent\n            className=\"max-h-[600px] lg:w-[500px]\"\n            align=\"start\"\n            onOpenAutoFocus={(e) => {\n              // Prevent the popover from stealing focus and losing selection\n              e.preventDefault()\n            }}\n          >\n            <ClassPickerContent />\n          </PopoverContent>\n        </Popover>\n      )}\n    </motion.div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/font-size-picker.tsx",
      "content": "\"use client\"\n\nimport React, { useEffect, useState } from \"react\"\nimport { Minus, Plus } from \"lucide-react\"\n\nimport { Button } from \"../button\"\nimport { Input } from \"../input\"\n\ninterface FontSizePickerProps {\n  disabled?: boolean\n  onFontSizeSelect: (fontSize: string) => void\n  currentFontSize?: string\n}\n\n// Extract numeric value from inline style fontSize value\nconst extractFontSize = (fontSizeValue?: string): number => {\n  if (!fontSizeValue) return 16 // default\n\n  // Check if it's a pixel value\n  if (fontSizeValue.includes(\"px\")) {\n    return parseInt(fontSizeValue.replace(\"px\", \"\")) || 16\n  }\n\n  // If it's just a number\n  const parsed = parseInt(fontSizeValue)\n  if (!isNaN(parsed)) {\n    return parsed\n  }\n\n  return 16\n}\n\nexport function FontSizePicker({\n  disabled = false,\n  onFontSizeSelect,\n  currentFontSize,\n}: FontSizePickerProps) {\n  const [fontSize, setFontSize] = useState<number>(\n    extractFontSize(currentFontSize)\n  )\n\n  // Update fontSize when currentFontSize changes (selection changes)\n  useEffect(() => {\n    const extractedSize = extractFontSize(currentFontSize)\n    setFontSize(extractedSize)\n  }, [currentFontSize])\n\n  const handleIncrement = () => {\n    const newSize = Math.min(fontSize + 2, 128)\n    setFontSize(newSize)\n    onFontSizeSelect(`${newSize}px`)\n  }\n\n  const handleDecrement = () => {\n    const newSize = Math.max(fontSize - 2, 8)\n    setFontSize(newSize)\n    onFontSizeSelect(`${newSize}px`)\n  }\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = parseInt(e.target.value) || 16\n    const clampedValue = Math.max(8, Math.min(value, 128))\n    setFontSize(clampedValue)\n  }\n\n  const handleInputBlur = () => {\n    onFontSizeSelect(`${fontSize}px`)\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>): void => {\n    if (e.key === \"Enter\") {\n      onFontSizeSelect(`${fontSize}px`)\n      e.currentTarget.blur()\n    }\n  }\n\n  return (\n    <div className=\"bg-muted/50 flex items-center gap-0.5 rounded-md\">\n      <Button\n        variant=\"ghost\"\n        size=\"icon\"\n        onClick={handleDecrement}\n        disabled={disabled || fontSize <= 8}\n        className=\"hover:bg-muted h-7 w-6 rounded-r-none md:h-8 md:w-7\"\n        title=\"Decrease font size\"\n      >\n        <Minus className=\"size-3 md:size-3.5\" />\n      </Button>\n\n      <Input\n        type=\"number\"\n        value={fontSize}\n        onChange={handleInputChange}\n        onBlur={handleInputBlur}\n        onKeyDown={handleKeyDown}\n        disabled={disabled}\n        min={8}\n        max={128}\n        className=\"h-7 w-10 [appearance:textfield] rounded-none border-0 bg-transparent px-0.5 text-center text-xs focus-visible:ring-0 focus-visible:ring-offset-0 md:h-8 md:w-14 md:px-1 md:text-sm [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none\"\n        title=\"Font size in pixels\"\n      />\n\n      <Button\n        variant=\"ghost\"\n        size=\"icon\"\n        onClick={handleIncrement}\n        disabled={disabled || fontSize >= 128}\n        className=\"hover:bg-muted h-7 w-6 rounded-l-none md:h-8 md:w-7\"\n        title=\"Increase font size\"\n      >\n        <Plus className=\"size-3 md:size-3.5\" />\n      </Button>\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/group-images-button.tsx",
      "content": "/**\n * Group Images Button Component\n *\n * Floating button that appears when multiple images are selected\n * Allows grouping selected images into a flex container\n */\n\n\"use client\"\n\nimport React from \"react\"\nimport { AnimatePresence, motion } from \"framer-motion\"\nimport { ArrowLeftRight, Images, Package, X } from \"lucide-react\"\n\nimport { Button } from \"../button\"\n\ninterface GroupImagesButtonProps {\n  selectedCount: number\n  inSameFlex: boolean\n  onGroup: () => void\n  onReverse?: () => void\n  onExtract?: () => void\n  onClear: () => void\n}\n\nexport function GroupImagesButton({\n  selectedCount,\n  inSameFlex,\n  onGroup,\n  onReverse,\n  onExtract,\n  onClear,\n}: GroupImagesButtonProps) {\n  if (selectedCount < 2) return null\n\n  return (\n    <AnimatePresence>\n      <motion.div\n        initial={{ opacity: 0, y: 20, scale: 0.9 }}\n        animate={{ opacity: 1, y: 0, scale: 1 }}\n        exit={{ opacity: 0, y: 20, scale: 0.9 }}\n        transition={{ duration: 0.2 }}\n        className=\"fixed bottom-8 left-1/2 z-50 -translate-x-1/2\"\n      >\n        <div className=\"bg-background border-border flex items-center gap-2 rounded-lg border p-2 shadow-2xl\">\n          {/* Selection count */}\n          <div className=\"text-muted-foreground px-3 py-2 text-sm font-medium\">\n            {selectedCount} {selectedCount === 1 ? \"image\" : \"images\"} selected\n          </div>\n\n          {/* Show different actions based on whether in flex */}\n          {inSameFlex ? (\n            <>\n              {/* Reverse button */}\n              {onReverse && (\n                <Button\n                  onClick={onReverse}\n                  size=\"sm\"\n                  variant=\"secondary\"\n                  className=\"gap-2\"\n                >\n                  <ArrowLeftRight className=\"h-4 w-4\" />\n                  Reverse Order\n                </Button>\n              )}\n\n              {/* Extract button */}\n              {onExtract && (\n                <Button\n                  onClick={onExtract}\n                  size=\"sm\"\n                  variant=\"secondary\"\n                  className=\"gap-2\"\n                >\n                  <Package className=\"h-4 w-4\" />\n                  Extract from Flex\n                </Button>\n              )}\n            </>\n          ) : (\n            /* Group button */\n            <Button onClick={onGroup} size=\"sm\" className=\"gap-2\">\n              <Images className=\"h-4 w-4\" />\n              Group into Flex\n            </Button>\n          )}\n\n          {/* Clear button */}\n          <Button\n            onClick={onClear}\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"h-8 w-8\"\n          >\n            <X className=\"h-4 w-4\" />\n          </Button>\n        </div>\n      </motion.div>\n    </AnimatePresence>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/link-popover.tsx",
      "content": "/**\n * LinkPopover Component\n *\n * A floating popover that appears on text selection, allowing users to add/edit/remove links\n * Uses useEditor internally to access and modify the editor state\n */\n\n\"use client\"\n\nimport React, { useEffect, useRef, useState } from \"react\"\nimport { motion } from \"framer-motion\"\nimport { Link as LinkIcon, Trash2 } from \"lucide-react\"\n\nimport { Button } from \"../button\"\nimport { Input } from \"../input\"\nimport { Label } from \"../label\"\nimport { Popover, PopoverContent, PopoverTrigger } from \"../popover\"\nimport { useToast } from \"./hooks/use-toast\"\nimport { EditorActions, useEditor } from \"./index\"\n\nexport function LinkPopover() {\n  const [state, dispatch] = useEditor()\n  const [hrefInput, setHrefInput] = useState(\"\")\n  const [isOpen, setIsOpen] = useState(false)\n  const [position, setPosition] = useState<{\n    top: number\n    left: number\n  } | null>(null)\n\n  const { toast } = useToast()\n  // Store the selection in a ref so it persists when focus changes\n  const savedSelectionRef = useRef<{\n    nodeId: string\n    start: number\n    end: number\n    text: string\n    href?: string | null\n    formats: {\n      bold: boolean\n      italic: boolean\n      underline: boolean\n    }\n    elementType?:\n      | \"p\"\n      | \"h1\"\n      | \"h2\"\n      | \"h3\"\n      | \"h4\"\n      | \"h5\"\n      | \"h6\"\n      | \"code\"\n      | \"blockquote\"\n      | null\n    className?: string | null\n  } | null>(null)\n\n  // Track selection and position the floating icon\n  useEffect(() => {\n    if (state.currentSelection && state.currentSelection.text.length > 0) {\n      // Save the selection to ref so it persists when focus changes\n      savedSelectionRef.current = {\n        nodeId: state.currentSelection.nodeId,\n        start: state.currentSelection.start,\n        end: state.currentSelection.end,\n        text: state.currentSelection.text,\n        href: state.currentSelection.href,\n        formats: state.currentSelection.formats,\n        elementType: state.currentSelection.elementType,\n        className: state.currentSelection.className,\n      }\n\n      // Pre-fill the href input if selection has an existing link\n      if (state.currentSelection.href && !isOpen) {\n        setHrefInput(state.currentSelection.href)\n      }\n\n      const selection = window.getSelection()\n      if (selection && selection.rangeCount > 0) {\n        const range = selection.getRangeAt(0)\n        const rect = range.getBoundingClientRect()\n\n        // Calculate position relative to document (absolute positioning)\n        // Position the icon above the selection, offset to the right of custom class icon\n        setPosition({\n          top: rect.top + window.scrollY - 45, // 45px above the selection + scroll offset\n          left: rect.left + window.scrollX + rect.width / 2 + 16, // Offset to the right + scroll offset\n        })\n      }\n    } else {\n      // Only clear position if we don't have a saved selection and popover is closed\n      if (!isOpen) {\n        setPosition(null)\n        savedSelectionRef.current = null\n      }\n    }\n  }, [state.currentSelection, state.selectionKey, isOpen])\n\n  // Handle link application\n  const handleApplyLink = () => {\n    // Use saved selection from ref instead of state\n    if (!savedSelectionRef.current || !hrefInput.trim()) return\n\n    // Temporarily restore the selection in state for the action\n    dispatch(EditorActions.setCurrentSelection(savedSelectionRef.current))\n\n    // Apply the link\n    setTimeout(() => {\n      dispatch(EditorActions.applyLink(hrefInput.trim()))\n\n      toast({\n        title: \"Link Applied\",\n        description: `Linked to: ${hrefInput}`,\n      })\n\n      setHrefInput(\"\")\n      setIsOpen(false)\n      setPosition(null)\n      savedSelectionRef.current = null\n    }, 0)\n  }\n\n  // Handle link removal\n  const handleRemoveLink = () => {\n    // Use saved selection from ref instead of state\n    if (!savedSelectionRef.current) return\n\n    // Temporarily restore the selection in state for the action\n    dispatch(EditorActions.setCurrentSelection(savedSelectionRef.current))\n\n    // Remove the link\n    setTimeout(() => {\n      dispatch(EditorActions.removeLink())\n\n      toast({\n        title: \"Link Removed\",\n        description: \"Link has been removed from selection\",\n      })\n\n      setHrefInput(\"\")\n      setIsOpen(false)\n      setPosition(null)\n      savedSelectionRef.current = null\n    }, 0)\n  }\n\n  // if (!position) return null;\n\n  const hasExistingLink = savedSelectionRef.current?.href\n\n  return (\n    <motion.div\n      className={`${position ? \"opacity-100\" : \"!opacity-0\"} pointer-events-auto absolute z-50 transition-opacity duration-300`}\n      style={{\n        top: `${position?.top || 0}px`,\n        left: `${position?.left || 0}px`,\n      }}\n      layoutId=\"link-popover\"\n    >\n      <Popover open={isOpen} onOpenChange={setIsOpen}>\n        <PopoverTrigger asChild>\n          <button\n            className={`bg-background flex h-8 w-8 items-center justify-center rounded-full border-2 shadow-lg transition-all hover:scale-110 ${\n              hasExistingLink\n                ? \"border-blue-500 text-blue-500\"\n                : \"border-border hover:border-primary\"\n            }`}\n            onMouseDown={(e) => {\n              // Prevent default to keep the selection\n              e.preventDefault()\n              e.stopPropagation()\n            }}\n            onClick={(e) => {\n              // Prevent default to keep the selection\n              e.preventDefault()\n              e.stopPropagation()\n              setIsOpen(true)\n            }}\n          >\n            <LinkIcon className=\"size-4\" />\n          </button>\n        </PopoverTrigger>\n        <PopoverContent\n          className=\"w-80\"\n          align=\"start\"\n          onOpenAutoFocus={(e) => {\n            // Prevent the popover from stealing focus and losing selection\n            e.preventDefault()\n          }}\n        >\n          <div className=\"space-y-3\">\n            <div>\n              <h4 className=\"mb-1 text-sm font-medium\">\n                {hasExistingLink ? \"Edit Link\" : \"Add Link\"}\n              </h4>\n              <p className=\"text-muted-foreground text-xs\">\n                Selected text: \"{savedSelectionRef.current?.text}\"\n              </p>\n            </div>\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"href-input\" className=\"text-xs\">\n                Link URL\n              </Label>\n              <Input\n                id=\"href-input\"\n                placeholder=\"https://example.com\"\n                value={hrefInput}\n                onChange={(e) => setHrefInput(e.target.value)}\n                onKeyDown={(e) => {\n                  if (e.key === \"Enter\") {\n                    handleApplyLink()\n                  }\n                }}\n                className=\"flex-1\"\n                onMouseDown={(e) => e.stopPropagation()}\n                onClick={(e) => e.stopPropagation()}\n              />\n            </div>\n            <div className=\"flex gap-2\">\n              <Button\n                onClick={handleApplyLink}\n                disabled={!hrefInput.trim()}\n                size=\"sm\"\n                className=\"flex-1\"\n              >\n                <LinkIcon className=\"mr-1.5 size-3.5\" />\n                {hasExistingLink ? \"Update\" : \"Add Link\"}\n              </Button>\n              {hasExistingLink && (\n                <Button\n                  onClick={handleRemoveLink}\n                  variant=\"destructive\"\n                  size=\"sm\"\n                >\n                  <Trash2 className=\"size-3.5\" />\n                </Button>\n              )}\n            </div>\n          </div>\n        </PopoverContent>\n      </Popover>\n    </motion.div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/table-builder.tsx",
      "content": "\"use client\"\n\nimport React, { useRef, useState } from \"react\"\nimport { GripVertical, Plus, X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nimport { Button } from \"../button\"\nimport {\n  ContainerNode,\n  StructuralNode,\n  TextNode,\n  type EditorNode,\n} from \"./types\"\n\ninterface TableBuilderProps {\n  node: ContainerNode\n  onUpdate: (id: string, updates: Partial<EditorNode>) => void\n  readOnly?: boolean\n  onBlockDragStart?: (nodeId: string) => void\n}\n\nexport function TableBuilder({\n  node,\n  onUpdate,\n  readOnly = false,\n  onBlockDragStart,\n}: TableBuilderProps) {\n  const [hoveredCol, setHoveredCol] = useState<number | null>(null)\n  const [hoveredRow, setHoveredRow] = useState<number | null>(null)\n  const [showColControls, setShowColControls] = useState(false)\n  const [showRowControls, setShowRowControls] = useState(false)\n  const [isHovering, setIsHovering] = useState(false)\n  const [columnWidths, setColumnWidths] = useState<number[]>([])\n  const [resizingCol, setResizingCol] = useState<number | null>(null)\n  const [startX, setStartX] = useState(0)\n  const [startWidth, setStartWidth] = useState(0)\n  const [draggingCol, setDraggingCol] = useState<number | null>(null)\n  const [draggingRow, setDraggingRow] = useState<number | null>(null)\n  const [dragOverCol, setDragOverCol] = useState<number | null>(null)\n  const [dragOverRow, setDragOverRow] = useState<number | null>(null)\n  const tableRef = useRef<HTMLTableElement>(null)\n\n  // Helper to find table structure\n  const table = node.children.find((child) => child.type === \"table\") as\n    | StructuralNode\n    | undefined\n  if (!table) return null\n\n  const thead = table.children.find((child) => child.type === \"thead\") as\n    | StructuralNode\n    | undefined\n  const tbody = table.children.find((child) => child.type === \"tbody\") as\n    | StructuralNode\n    | undefined\n\n  const headerRow = thead?.children[0] as StructuralNode | undefined\n  const bodyRows = tbody?.children as StructuralNode[] | undefined\n\n  const numCols = headerRow?.children.length || 0\n  const numRows = (bodyRows?.length || 0) + 1 // +1 for header\n\n  // Initialize column widths if not set (using 'auto' for natural sizing)\n  React.useEffect(() => {\n    if (columnWidths.length === 0 && numCols > 0) {\n      // Start with auto-sizing (0 means auto)\n      setColumnWidths(Array(numCols).fill(0))\n    }\n  }, [numCols, columnWidths.length])\n\n  // Handle resize start\n  const handleResizeStart = (colIndex: number, e: React.MouseEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    // Get actual width from DOM if it's auto-sized (0)\n    const actualWidth =\n      columnWidths[colIndex] ||\n      tableRef.current\n        ?.querySelector(`th:nth-child(${colIndex + 1})`)\n        ?.getBoundingClientRect().width ||\n      150\n\n    setResizingCol(colIndex)\n    setStartX(e.clientX)\n    setStartWidth(actualWidth)\n  }\n\n  // Handle resize move\n  React.useEffect(() => {\n    if (resizingCol === null) return\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const diff = e.clientX - startX\n      const newWidth = Math.max(80, startWidth + diff) // Minimum width 80px\n\n      setColumnWidths((prev) => {\n        const newWidths = [...prev]\n        newWidths[resizingCol] = newWidth\n        return newWidths\n      })\n    }\n\n    const handleMouseUp = () => {\n      setResizingCol(null)\n    }\n\n    document.addEventListener(\"mousemove\", handleMouseMove)\n    document.addEventListener(\"mouseup\", handleMouseUp)\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove)\n      document.removeEventListener(\"mouseup\", handleMouseUp)\n    }\n  }, [resizingCol, startX, startWidth])\n\n  // Column drag handlers\n  const handleColumnDragStart = (colIndex: number, e: React.DragEvent) => {\n    if (readOnly) return\n    e.stopPropagation()\n    setDraggingCol(colIndex)\n    e.dataTransfer.effectAllowed = \"move\"\n  }\n\n  const handleColumnDragOver = (colIndex: number, e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    if (draggingCol === null || draggingCol === colIndex) return\n    setDragOverCol(colIndex)\n  }\n\n  const handleColumnDrop = (targetColIndex: number, e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    if (\n      draggingCol === null ||\n      draggingCol === targetColIndex ||\n      !headerRow ||\n      !bodyRows\n    )\n      return\n\n    // Swap columns in header\n    const newHeaderChildren = [...headerRow.children]\n    const [draggedHeader] = newHeaderChildren.splice(draggingCol, 1)\n    newHeaderChildren.splice(targetColIndex, 0, draggedHeader)\n\n    const newHeaderRow: StructuralNode = {\n      ...headerRow,\n      children: newHeaderChildren,\n    }\n\n    // Swap columns in all body rows\n    const newBodyRows = bodyRows.map((row) => {\n      const newRowChildren = [...row.children]\n      const [draggedCell] = newRowChildren.splice(draggingCol, 1)\n      newRowChildren.splice(targetColIndex, 0, draggedCell)\n      return {\n        ...row,\n        children: newRowChildren,\n      }\n    })\n\n    // Swap column widths\n    const newWidths = [...columnWidths]\n    const [draggedWidth] = newWidths.splice(draggingCol, 1)\n    newWidths.splice(targetColIndex, 0, draggedWidth)\n    setColumnWidths(newWidths)\n\n    // Update table\n    const newThead: StructuralNode = {\n      ...thead!,\n      children: [newHeaderRow],\n    }\n\n    const newTbody: StructuralNode = {\n      ...tbody!,\n      children: newBodyRows,\n    }\n\n    const newTable: StructuralNode = {\n      ...table,\n      children: [newThead, newTbody],\n    }\n\n    onUpdate(node.id, {\n      children: [newTable],\n    })\n\n    setDraggingCol(null)\n    setDragOverCol(null)\n  }\n\n  const handleColumnDragEnd = () => {\n    setDraggingCol(null)\n    setDragOverCol(null)\n  }\n\n  // Row drag handlers\n  const handleRowDragStart = (rowIndex: number, e: React.DragEvent) => {\n    if (readOnly) return\n    e.stopPropagation()\n    setDraggingRow(rowIndex)\n    e.dataTransfer.effectAllowed = \"move\"\n  }\n\n  const handleRowDragOver = (rowIndex: number, e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    if (draggingRow === null || draggingRow === rowIndex) return\n    setDragOverRow(rowIndex)\n  }\n\n  const handleRowDrop = (targetRowIndex: number, e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    if (draggingRow === null || draggingRow === targetRowIndex || !bodyRows)\n      return\n\n    // Reorder rows\n    const newBodyRows = [...bodyRows]\n    const [draggedRow] = newBodyRows.splice(draggingRow, 1)\n    newBodyRows.splice(targetRowIndex, 0, draggedRow)\n\n    const newTbody: StructuralNode = {\n      ...tbody!,\n      children: newBodyRows,\n    }\n\n    const newTable: StructuralNode = {\n      ...table,\n      children: [thead!, newTbody],\n    }\n\n    onUpdate(node.id, {\n      children: [newTable],\n    })\n\n    setDraggingRow(null)\n    setDragOverRow(null)\n  }\n\n  const handleRowDragEnd = () => {\n    setDraggingRow(null)\n    setDragOverRow(null)\n  }\n\n  const addColumn = () => {\n    if (!headerRow || !bodyRows || readOnly) return\n\n    // Add th to header\n    const newHeader: StructuralNode = {\n      ...headerRow,\n      children: [\n        ...headerRow.children,\n        {\n          id: `th-${Date.now()}`,\n          type: \"th\" as const,\n          content: `Column ${numCols + 1}`,\n          attributes: {},\n        } as TextNode,\n      ],\n    }\n\n    // Add td to each body row\n    const newBodyRows = bodyRows.map((row, idx) => ({\n      ...row,\n      children: [\n        ...row.children,\n        {\n          id: `td-${Date.now()}-${idx}`,\n          type: \"td\" as const,\n          content: \"\",\n          attributes: {},\n        } as TextNode,\n      ],\n    }))\n\n    const newThead: StructuralNode = {\n      ...thead!,\n      children: [newHeader],\n    }\n\n    const newTbody: StructuralNode = {\n      ...tbody!,\n      children: newBodyRows,\n    }\n\n    const newTable: StructuralNode = {\n      ...table,\n      children: [newThead, newTbody],\n    }\n\n    onUpdate(node.id, {\n      children: [newTable],\n    })\n\n    // Add width for new column (default 150px for empty columns)\n    setColumnWidths((prev) => [...prev, 150])\n  }\n\n  const addRow = () => {\n    if (!bodyRows || !headerRow || readOnly) return\n\n    const newCells = Array.from({ length: numCols }, (_, idx) => ({\n      id: `td-${Date.now()}-${idx}`,\n      type: \"td\" as const,\n      content: \"\",\n      attributes: {},\n    }))\n\n    const newRow: StructuralNode = {\n      id: `tr-${Date.now()}`,\n      type: \"tr\",\n      children: newCells,\n      attributes: {},\n    }\n\n    const newTbody: StructuralNode = {\n      ...tbody!,\n      children: [...bodyRows, newRow],\n    }\n\n    const newTable: StructuralNode = {\n      ...table,\n      children: [thead!, newTbody],\n    }\n\n    onUpdate(node.id, {\n      children: [newTable],\n    })\n  }\n\n  const removeColumn = (colIndex: number) => {\n    if (!headerRow || !bodyRows || readOnly || numCols <= 1) return\n\n    const newHeader: StructuralNode = {\n      ...headerRow,\n      children: headerRow.children.filter((_, idx) => idx !== colIndex),\n    }\n\n    const newBodyRows = bodyRows.map((row) => ({\n      ...row,\n      children: row.children.filter((_, idx) => idx !== colIndex),\n    }))\n\n    const newThead: StructuralNode = {\n      ...thead!,\n      children: [newHeader],\n    }\n\n    const newTbody: StructuralNode = {\n      ...tbody!,\n      children: newBodyRows,\n    }\n\n    const newTable: StructuralNode = {\n      ...table,\n      children: [newThead, newTbody],\n    }\n\n    onUpdate(node.id, {\n      children: [newTable],\n    })\n\n    // Remove width for deleted column\n    setColumnWidths((prev) => prev.filter((_, idx) => idx !== colIndex))\n  }\n\n  const removeRow = (rowIndex: number) => {\n    if (!bodyRows || readOnly || bodyRows.length <= 1) return\n\n    const newBodyRows = bodyRows.filter((_, idx) => idx !== rowIndex)\n\n    const newTbody: StructuralNode = {\n      ...tbody!,\n      children: newBodyRows,\n    }\n\n    const newTable: StructuralNode = {\n      ...table,\n      children: [thead!, newTbody],\n    }\n\n    onUpdate(node.id, {\n      children: [newTable],\n    })\n  }\n\n  const handleCellChange = (\n    rowIndex: number,\n    colIndex: number,\n    content: string,\n    isHeader: boolean\n  ) => {\n    if (readOnly) return\n\n    if (isHeader && headerRow) {\n      const newHeader: StructuralNode = {\n        ...headerRow,\n        children: headerRow.children.map((cell, idx) =>\n          idx === colIndex ? { ...cell, content } : cell\n        ),\n      }\n\n      const newThead: StructuralNode = {\n        ...thead!,\n        children: [newHeader],\n      }\n\n      const newTable: StructuralNode = {\n        ...table,\n        children: [newThead, tbody!],\n      }\n\n      onUpdate(node.id, {\n        children: [newTable],\n      })\n    } else if (bodyRows) {\n      const newBodyRows = bodyRows.map((row, rIdx) => {\n        if (rIdx === rowIndex) {\n          return {\n            ...row,\n            children: row.children.map((cell, cIdx) =>\n              cIdx === colIndex ? { ...cell, content } : cell\n            ),\n          }\n        }\n        return row\n      })\n\n      const newTbody: StructuralNode = {\n        ...tbody!,\n        children: newBodyRows,\n      }\n\n      const newTable: StructuralNode = {\n        ...table,\n        children: [thead!, newTbody],\n      }\n\n      onUpdate(node.id, {\n        children: [newTable],\n      })\n    }\n  }\n\n  // Drag handlers for the entire table\n  const handleTableDragStart = (e: React.DragEvent) => {\n    if (readOnly || !onBlockDragStart) return\n    e.stopPropagation()\n    e.dataTransfer.effectAllowed = \"move\"\n    e.dataTransfer.setData(\"text/plain\", node.id)\n    e.dataTransfer.setData(\n      \"application/json\",\n      JSON.stringify({\n        nodeId: node.id,\n        type: \"table\",\n      })\n    )\n    onBlockDragStart(node.id)\n  }\n\n  const handleTableDragEnd = () => {\n    // Cleanup if needed\n  }\n\n  return (\n    <div\n      className=\"group/table relative\"\n      style={{\n        paddingLeft: readOnly ? \"0\" : \"28px\",\n        marginLeft: readOnly ? \"0\" : \"-28px\",\n      }}\n      onMouseEnter={() => {\n        if (!readOnly) {\n          setShowColControls(true)\n          setShowRowControls(true)\n          setIsHovering(true)\n        }\n      }}\n      onMouseLeave={() => {\n        setShowColControls(false)\n        setShowRowControls(false)\n        setHoveredCol(null)\n        setHoveredRow(null)\n        setIsHovering(false)\n      }}\n    >\n      {/* Drag Handle for entire table */}\n      {!readOnly && isHovering && onBlockDragStart && (\n        <div\n          draggable\n          onDragStart={handleTableDragStart}\n          onDragEnd={handleTableDragEnd}\n          className=\"absolute top-8 left-1 z-20 cursor-grab opacity-0 transition-opacity duration-200 group-hover/table:opacity-100 active:cursor-grabbing\"\n          onClick={(e) => e.stopPropagation()}\n          onMouseDown={(e) => e.stopPropagation()}\n        >\n          <GripVertical\n            className=\"text-muted-foreground hover:text-foreground h-4 w-4 transition-colors duration-200\"\n            strokeWidth={1.5}\n          />\n        </div>\n      )}\n\n      <div className=\"relative mx-auto w-fit\">\n        {/* Column controls - top */}\n        {showColControls && (\n          <div className=\"absolute top-0 right-0 left-8 z-10 flex justify-center gap-1\">\n            {Array.from({ length: numCols }).map((_, idx) => (\n              <div\n                key={idx}\n                className=\"flex flex-col items-center\"\n                style={{ width: `${100 / numCols}%` }}\n                onMouseEnter={() => setHoveredCol(idx)}\n                onMouseLeave={() => setHoveredCol(null)}\n              >\n                {hoveredCol === idx && numCols > 1 && (\n                  <Button\n                    size=\"icon\"\n                    variant=\"destructive\"\n                    className=\"h-5 w-5\"\n                    onClick={() => removeColumn(idx)}\n                    title=\"Remove column\"\n                  >\n                    <X className=\"h-3 w-3\" />\n                  </Button>\n                )}\n              </div>\n            ))}\n            <Button\n              size=\"icon\"\n              variant=\"secondary\"\n              className=\"ml-1 h-6 w-6\"\n              onClick={addColumn}\n              title=\"Add column\"\n            >\n              <Plus className=\"h-3 w-3\" />\n            </Button>\n          </div>\n        )}\n\n        {/* Row controls - left side */}\n        {showRowControls && bodyRows && (\n          <div className=\"absolute top-0 bottom-0 -left-2 z-10 flex flex-col justify-start gap-1 pt-10\">\n            {bodyRows.map((_, idx) => (\n              <div\n                key={idx}\n                className=\"flex items-center justify-center\"\n                style={{ height: \"40px\" }}\n                onMouseEnter={() => setHoveredRow(idx)}\n                onMouseLeave={() => setHoveredRow(null)}\n              >\n                {hoveredRow === idx && bodyRows.length > 1 && (\n                  <Button\n                    size=\"icon\"\n                    variant=\"destructive\"\n                    className=\"h-4 w-4\"\n                    onClick={() => removeRow(idx)}\n                    title=\"Remove row\"\n                  >\n                    <X className=\"h-2.5 w-2.5\" />\n                  </Button>\n                )}\n              </div>\n            ))}\n            <Button\n              size=\"icon\"\n              variant=\"secondary\"\n              className=\"mt-1 h-4 w-4\"\n              onClick={addRow}\n              title=\"Add row\"\n            >\n              <Plus className=\"h-2.5 w-2.5\" />\n            </Button>\n          </div>\n        )}\n\n        <div className=\"relative mx-auto w-fit overflow-x-auto py-5\">\n          {/* Table */}\n          <table\n            ref={tableRef}\n            className=\"border-border border-collapse border\"\n            style={{ width: \"auto\" }}\n          >\n            <thead>\n              {headerRow && (\n                <tr>\n                  {headerRow.children.map((cell, colIdx) => (\n                    <th\n                      key={cell.id}\n                      className={cn(\n                        \"border-border bg-muted/50 group/cell relative border p-2 text-left font-semibold\",\n                        hoveredCol === colIdx && \"bg-muted\",\n                        dragOverCol === colIdx &&\n                          draggingCol !== colIdx &&\n                          \"bg-primary/20\"\n                      )}\n                      style={\n                        columnWidths[colIdx]\n                          ? {\n                              width: columnWidths[colIdx],\n                              minWidth: columnWidths[colIdx],\n                              maxWidth: columnWidths[colIdx],\n                            }\n                          : {\n                              whiteSpace: \"nowrap\",\n                            }\n                      }\n                      draggable={!readOnly}\n                      onDragStart={(e) => handleColumnDragStart(colIdx, e)}\n                      onDragOver={(e) => handleColumnDragOver(colIdx, e)}\n                      onDrop={(e) => handleColumnDrop(colIdx, e)}\n                      onDragEnd={handleColumnDragEnd}\n                    >\n                      <div className=\"flex items-center gap-1\">\n                        {/* Drag handle for column */}\n                        {!readOnly && (\n                          <div\n                            className=\"cursor-grab opacity-0 transition-opacity group-hover/cell:opacity-100 active:cursor-grabbing\"\n                            onMouseDown={(e) => e.stopPropagation()}\n                          >\n                            <GripVertical className=\"text-muted-foreground h-3 w-3\" />\n                          </div>\n                        )}\n\n                        <input\n                          type=\"text\"\n                          value={(cell as TextNode).content || \"\"}\n                          onChange={(e) =>\n                            handleCellChange(0, colIdx, e.target.value, true)\n                          }\n                          onKeyDown={(e) => {\n                            if (\n                              e.key === \"Backspace\" &&\n                              !(cell as TextNode).content &&\n                              numCols > 1\n                            ) {\n                              e.preventDefault()\n                              removeColumn(colIdx)\n                            }\n                          }}\n                          readOnly={readOnly}\n                          className=\"w-full border-none bg-transparent outline-none focus:ring-0 focus:outline-none\"\n                          placeholder={`Column ${colIdx + 1}`}\n                        />\n                      </div>\n\n                      {/* Resize handle */}\n                      {!readOnly && (\n                        <div\n                          className={cn(\n                            \"hover:bg-primary/50 absolute top-0 right-0 bottom-0 w-1 cursor-col-resize transition-colors\",\n                            resizingCol === colIdx && \"bg-primary\"\n                          )}\n                          onMouseDown={(e) => handleResizeStart(colIdx, e)}\n                          style={{ userSelect: \"none\" }}\n                        >\n                          <div className=\"absolute top-1/2 right-0 -translate-x-1/2 -translate-y-1/2 opacity-0 transition-opacity hover:opacity-100\">\n                            <GripVertical className=\"text-muted-foreground h-4 w-4\" />\n                          </div>\n                        </div>\n                      )}\n                    </th>\n                  ))}\n                </tr>\n              )}\n            </thead>\n            <tbody>\n              {bodyRows?.map((row, rowIdx) => (\n                <tr\n                  key={row.id}\n                  className={cn(\n                    \"group/row\",\n                    hoveredRow === rowIdx && \"bg-muted/30\",\n                    dragOverRow === rowIdx &&\n                      draggingRow !== rowIdx &&\n                      \"bg-primary/20\"\n                  )}\n                  draggable={!readOnly}\n                  onDragStart={(e) => handleRowDragStart(rowIdx, e)}\n                  onDragOver={(e) => handleRowDragOver(rowIdx, e)}\n                  onDrop={(e) => handleRowDrop(rowIdx, e)}\n                  onDragEnd={handleRowDragEnd}\n                >\n                  {row.children.map((cell, colIdx) => (\n                    <td\n                      key={cell.id}\n                      className={cn(\n                        \"border-border relative border p-2\",\n                        hoveredCol === colIdx && \"bg-muted/50\"\n                      )}\n                      style={\n                        columnWidths[colIdx]\n                          ? {\n                              width: columnWidths[colIdx],\n                              minWidth: columnWidths[colIdx],\n                              maxWidth: columnWidths[colIdx],\n                            }\n                          : {\n                              whiteSpace: \"nowrap\",\n                            }\n                      }\n                    >\n                      <div className=\"flex items-center gap-1\">\n                        {/* Drag handle for row (only show in first column) */}\n                        {!readOnly && colIdx === 0 && (\n                          <div\n                            className=\"cursor-grab opacity-0 transition-opacity group-hover/row:opacity-100 active:cursor-grabbing\"\n                            onMouseDown={(e) => e.stopPropagation()}\n                          >\n                            <GripVertical className=\"text-muted-foreground h-3 w-3\" />\n                          </div>\n                        )}\n\n                        <input\n                          type=\"text\"\n                          value={(cell as TextNode).content || \"\"}\n                          onChange={(e) =>\n                            handleCellChange(\n                              rowIdx,\n                              colIdx,\n                              e.target.value,\n                              false\n                            )\n                          }\n                          readOnly={readOnly}\n                          className=\"w-full border-none bg-transparent outline-none focus:ring-0 focus:outline-none\"\n                          placeholder=\"Enter text\"\n                        />\n                      </div>\n                    </td>\n                  ))}\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/table-dialog.tsx",
      "content": "\"use client\"\n\nimport React, { useState } from \"react\"\nimport { AlertCircle, Table } from \"lucide-react\"\n\nimport { Button } from \"../button\"\nimport { Checkbox } from \"../checkbox\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"../dialog\"\nimport { Input } from \"../input\"\nimport { Label } from \"../label\"\nimport { Textarea } from \"../textarea\"\nimport { StructuralNode } from \"./types\"\nimport {\n  isMarkdownTable,\n  parseMarkdownTable,\n} from \"./utils/markdown-table-parser\"\n\ninterface TableDialogProps {\n  open: boolean\n  onOpenChange: (open: boolean) => void\n  onCreateTable: (rows: number, cols: number) => void\n  onImportMarkdown: (table: StructuralNode) => void\n}\n\nexport function TableDialog({\n  open,\n  onOpenChange,\n  onCreateTable,\n  onImportMarkdown,\n}: TableDialogProps) {\n  const [rows, setRows] = useState(3)\n  const [cols, setCols] = useState(3)\n  const [useMarkdown, setUseMarkdown] = useState(false)\n  const [markdownText, setMarkdownText] = useState(\"\")\n  const [error, setError] = useState<string | null>(null)\n\n  const handleCreate = () => {\n    if (useMarkdown) {\n      // Parse and import markdown\n      const result = parseMarkdownTable(markdownText)\n      if (result.success && result.table) {\n        onImportMarkdown(result.table)\n        onOpenChange(false)\n        // Reset\n        setMarkdownText(\"\")\n        setUseMarkdown(false)\n        setError(null)\n      } else {\n        setError(result.error || \"Failed to parse markdown table\")\n      }\n    } else {\n      // Create empty table\n      if (rows > 0 && cols > 0 && rows <= 20 && cols <= 10) {\n        onCreateTable(rows, cols)\n        onOpenChange(false)\n        // Reset to defaults\n        setRows(3)\n        setCols(3)\n        setError(null)\n      }\n    }\n  }\n\n  const handleMarkdownChange = (value: string) => {\n    setMarkdownText(value)\n    setError(null)\n  }\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-[425px]\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            <Table className=\"h-5 w-5\" />\n            Create Table\n          </DialogTitle>\n          <DialogDescription>\n            Create a new table or import from markdown\n          </DialogDescription>\n        </DialogHeader>\n        <div className=\"grid gap-4 py-4\">\n          {/* Markdown checkbox */}\n          <div className=\"flex items-center space-x-2\">\n            <Checkbox\n              id=\"markdown\"\n              checked={useMarkdown}\n              onCheckedChange={(checked: boolean) => {\n                setUseMarkdown(checked as boolean)\n                setError(null)\n              }}\n            />\n            <Label\n              htmlFor=\"markdown\"\n              className=\"cursor-pointer text-sm leading-none font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n            >\n              I have a markdown table\n            </Label>\n          </div>\n\n          {useMarkdown ? (\n            <>\n              {/* Markdown input */}\n              <div className=\"grid gap-2\">\n                <Label htmlFor=\"markdown-input\">Paste Markdown Table</Label>\n                <Textarea\n                  id=\"markdown-input\"\n                  placeholder={`| Header 1 | Header 2 | Header 3 |\n|----------|----------|----------|\n| Cell 1   | Cell 2   | Cell 3   |\n| Cell 4   | Cell 5   | Cell 6   |`}\n                  value={markdownText}\n                  onChange={(e) => handleMarkdownChange(e.target.value)}\n                  className=\"max-h-[400px] min-h-[150px] font-mono text-xs\"\n                />\n                <div className=\"text-muted-foreground text-xs\">\n                  Paste your markdown table above. Must include header and\n                  separator rows.\n                </div>\n              </div>\n\n              {/* Error message */}\n              {error && (\n                <div className=\"text-destructive bg-destructive/10 flex items-start gap-2 rounded p-2 text-xs\">\n                  <AlertCircle className=\"mt-0.5 h-4 w-4 flex-shrink-0\" />\n                  <span>{error}</span>\n                </div>\n              )}\n            </>\n          ) : (\n            <>\n              {/* Manual input */}\n              <div className=\"grid grid-cols-4 items-center gap-4\">\n                <Label htmlFor=\"rows\" className=\"text-right\">\n                  Rows\n                </Label>\n                <Input\n                  id=\"rows\"\n                  type=\"number\"\n                  min=\"1\"\n                  max=\"20\"\n                  value={rows}\n                  onChange={(e) => setRows(parseInt(e.target.value) || 1)}\n                  className=\"col-span-3\"\n                />\n              </div>\n              <div className=\"grid grid-cols-4 items-center gap-4\">\n                <Label htmlFor=\"cols\" className=\"text-right\">\n                  Columns\n                </Label>\n                <Input\n                  id=\"cols\"\n                  type=\"number\"\n                  min=\"1\"\n                  max=\"10\"\n                  value={cols}\n                  onChange={(e) => setCols(parseInt(e.target.value) || 1)}\n                  className=\"col-span-3\"\n                />\n              </div>\n              <div className=\"text-muted-foreground px-1 text-xs\">\n                Maximum: 20 rows × 10 columns\n              </div>\n            </>\n          )}\n        </div>\n        <div className=\"flex justify-end gap-2\">\n          <Button variant=\"outline\" onClick={() => onOpenChange(false)}>\n            Cancel\n          </Button>\n          <Button\n            onClick={handleCreate}\n            disabled={\n              useMarkdown\n                ? !markdownText.trim() || !isMarkdownTable(markdownText)\n                : rows <= 0 || cols <= 0 || rows > 20 || cols > 10\n            }\n          >\n            {useMarkdown ? \"Import Table\" : \"Create Table\"}\n          </Button>\n        </div>\n      </DialogContent>\n    </Dialog>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/class-mappings.ts",
      "content": "/**\n * User-friendly class names mapped to Tailwind classes\n * Used when dev mode is OFF to show simplified, readable class names\n */\n\nexport interface ClassMapping {\n  userFriendly: string\n  tailwindClass: string\n  category: string\n}\n\nexport const classMappings: ClassMapping[] = [\n  // Text Color\n  {\n    userFriendly: \"Red Text\",\n    tailwindClass: \"text-red-500\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Dark Red Text\",\n    tailwindClass: \"text-red-600\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Darker Red Text\",\n    tailwindClass: \"text-red-700\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Blue Text\",\n    tailwindClass: \"text-blue-500\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Dark Blue Text\",\n    tailwindClass: \"text-blue-600\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Darker Blue Text\",\n    tailwindClass: \"text-blue-700\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Green Text\",\n    tailwindClass: \"text-green-500\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Dark Green Text\",\n    tailwindClass: \"text-green-600\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Darker Green Text\",\n    tailwindClass: \"text-green-700\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Yellow Text\",\n    tailwindClass: \"text-yellow-500\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Dark Yellow Text\",\n    tailwindClass: \"text-yellow-600\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Darker Yellow Text\",\n    tailwindClass: \"text-yellow-700\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Purple Text\",\n    tailwindClass: \"text-purple-500\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Dark Purple Text\",\n    tailwindClass: \"text-purple-600\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Darker Purple Text\",\n    tailwindClass: \"text-purple-700\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Pink Text\",\n    tailwindClass: \"text-pink-500\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Dark Pink Text\",\n    tailwindClass: \"text-pink-600\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Darker Pink Text\",\n    tailwindClass: \"text-pink-700\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Indigo Text\",\n    tailwindClass: \"text-indigo-500\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Dark Indigo Text\",\n    tailwindClass: \"text-indigo-600\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Darker Indigo Text\",\n    tailwindClass: \"text-indigo-700\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Gray Text\",\n    tailwindClass: \"text-gray-500\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Dark Gray Text\",\n    tailwindClass: \"text-gray-600\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Darker Gray Text\",\n    tailwindClass: \"text-gray-700\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Very Dark Gray Text\",\n    tailwindClass: \"text-gray-800\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Black Gray Text\",\n    tailwindClass: \"text-gray-900\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"White Text\",\n    tailwindClass: \"text-white\",\n    category: \"Text Color\",\n  },\n  {\n    userFriendly: \"Black Text\",\n    tailwindClass: \"text-black\",\n    category: \"Text Color\",\n  },\n\n  // Background Color\n  {\n    userFriendly: \"Light Red Background\",\n    tailwindClass: \"bg-red-50\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Lighter Red Background\",\n    tailwindClass: \"bg-red-100\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Soft Red Background\",\n    tailwindClass: \"bg-red-200\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Red Background\",\n    tailwindClass: \"bg-red-500\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Light Blue Background\",\n    tailwindClass: \"bg-blue-50\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Lighter Blue Background\",\n    tailwindClass: \"bg-blue-100\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Soft Blue Background\",\n    tailwindClass: \"bg-blue-200\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Blue Background\",\n    tailwindClass: \"bg-blue-500\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Light Green Background\",\n    tailwindClass: \"bg-green-50\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Lighter Green Background\",\n    tailwindClass: \"bg-green-100\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Soft Green Background\",\n    tailwindClass: \"bg-green-200\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Green Background\",\n    tailwindClass: \"bg-green-500\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Light Yellow Background\",\n    tailwindClass: \"bg-yellow-50\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Lighter Yellow Background\",\n    tailwindClass: \"bg-yellow-100\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Soft Yellow Background\",\n    tailwindClass: \"bg-yellow-200\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Yellow Background\",\n    tailwindClass: \"bg-yellow-500\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Light Purple Background\",\n    tailwindClass: \"bg-purple-50\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Lighter Purple Background\",\n    tailwindClass: \"bg-purple-100\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Soft Purple Background\",\n    tailwindClass: \"bg-purple-200\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Purple Background\",\n    tailwindClass: \"bg-purple-500\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Light Pink Background\",\n    tailwindClass: \"bg-pink-50\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Lighter Pink Background\",\n    tailwindClass: \"bg-pink-100\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Soft Pink Background\",\n    tailwindClass: \"bg-pink-200\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Pink Background\",\n    tailwindClass: \"bg-pink-500\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Light Indigo Background\",\n    tailwindClass: \"bg-indigo-50\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Lighter Indigo Background\",\n    tailwindClass: \"bg-indigo-100\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Soft Indigo Background\",\n    tailwindClass: \"bg-indigo-200\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Indigo Background\",\n    tailwindClass: \"bg-indigo-500\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Light Gray Background\",\n    tailwindClass: \"bg-gray-50\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Lighter Gray Background\",\n    tailwindClass: \"bg-gray-100\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Soft Gray Background\",\n    tailwindClass: \"bg-gray-200\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Gray Background\",\n    tailwindClass: \"bg-gray-500\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"White Background\",\n    tailwindClass: \"bg-white\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Black Background\",\n    tailwindClass: \"bg-black\",\n    category: \"Background Color\",\n  },\n  {\n    userFriendly: \"Transparent Background\",\n    tailwindClass: \"bg-transparent\",\n    category: \"Background Color\",\n  },\n\n  // Font Size\n  {\n    userFriendly: \"Extra Small Text\",\n    tailwindClass: \"text-xs\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"Small Text\",\n    tailwindClass: \"text-sm\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"Normal Text\",\n    tailwindClass: \"text-base\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"Large Text\",\n    tailwindClass: \"text-lg\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"Extra Large Text\",\n    tailwindClass: \"text-xl\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"2X Large Text\",\n    tailwindClass: \"text-2xl\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"3X Large Text\",\n    tailwindClass: \"text-3xl\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"4X Large Text\",\n    tailwindClass: \"text-4xl\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"5X Large Text\",\n    tailwindClass: \"text-5xl\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"6X Large Text\",\n    tailwindClass: \"text-6xl\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"7X Large Text\",\n    tailwindClass: \"text-7xl\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"8X Large Text\",\n    tailwindClass: \"text-8xl\",\n    category: \"Font Size\",\n  },\n  {\n    userFriendly: \"9X Large Text\",\n    tailwindClass: \"text-9xl\",\n    category: \"Font Size\",\n  },\n\n  // Font Weight\n  {\n    userFriendly: \"Thin Weight\",\n    tailwindClass: \"font-thin\",\n    category: \"Font Weight\",\n  },\n  {\n    userFriendly: \"Extra Light Weight\",\n    tailwindClass: \"font-extralight\",\n    category: \"Font Weight\",\n  },\n  {\n    userFriendly: \"Light Weight\",\n    tailwindClass: \"font-light\",\n    category: \"Font Weight\",\n  },\n  {\n    userFriendly: \"Normal Weight\",\n    tailwindClass: \"font-normal\",\n    category: \"Font Weight\",\n  },\n  {\n    userFriendly: \"Medium Weight\",\n    tailwindClass: \"font-medium\",\n    category: \"Font Weight\",\n  },\n  {\n    userFriendly: \"Semi Bold\",\n    tailwindClass: \"font-semibold\",\n    category: \"Font Weight\",\n  },\n  { userFriendly: \"Bold\", tailwindClass: \"font-bold\", category: \"Font Weight\" },\n  {\n    userFriendly: \"Extra Bold\",\n    tailwindClass: \"font-extrabold\",\n    category: \"Font Weight\",\n  },\n  {\n    userFriendly: \"Black Weight\",\n    tailwindClass: \"font-black\",\n    category: \"Font Weight\",\n  },\n\n  // Text Decoration\n  {\n    userFriendly: \"Underline\",\n    tailwindClass: \"underline\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Overline\",\n    tailwindClass: \"overline\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Line Through\",\n    tailwindClass: \"line-through\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"No Underline\",\n    tailwindClass: \"no-underline\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Solid Decoration\",\n    tailwindClass: \"decoration-solid\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Double Decoration\",\n    tailwindClass: \"decoration-double\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Dotted Decoration\",\n    tailwindClass: \"decoration-dotted\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Dashed Decoration\",\n    tailwindClass: \"decoration-dashed\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Wavy Decoration\",\n    tailwindClass: \"decoration-wavy\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Small Offset\",\n    tailwindClass: \"underline-offset-1\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Medium Offset\",\n    tailwindClass: \"underline-offset-2\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Large Offset\",\n    tailwindClass: \"underline-offset-4\",\n    category: \"Text Decoration\",\n  },\n  {\n    userFriendly: \"Extra Large Offset\",\n    tailwindClass: \"underline-offset-8\",\n    category: \"Text Decoration\",\n  },\n\n  // Text Alignment\n  {\n    userFriendly: \"Align Left\",\n    tailwindClass: \"text-left\",\n    category: \"Text Alignment\",\n  },\n  {\n    userFriendly: \"Align Center\",\n    tailwindClass: \"text-center\",\n    category: \"Text Alignment\",\n  },\n  {\n    userFriendly: \"Align Right\",\n    tailwindClass: \"text-right\",\n    category: \"Text Alignment\",\n  },\n  {\n    userFriendly: \"Justify\",\n    tailwindClass: \"text-justify\",\n    category: \"Text Alignment\",\n  },\n  {\n    userFriendly: \"Align Start\",\n    tailwindClass: \"text-start\",\n    category: \"Text Alignment\",\n  },\n  {\n    userFriendly: \"Align End\",\n    tailwindClass: \"text-end\",\n    category: \"Text Alignment\",\n  },\n\n  // Text Transform\n  {\n    userFriendly: \"Uppercase\",\n    tailwindClass: \"uppercase\",\n    category: \"Text Transform\",\n  },\n  {\n    userFriendly: \"Lowercase\",\n    tailwindClass: \"lowercase\",\n    category: \"Text Transform\",\n  },\n  {\n    userFriendly: \"Capitalize\",\n    tailwindClass: \"capitalize\",\n    category: \"Text Transform\",\n  },\n  {\n    userFriendly: \"Normal Case\",\n    tailwindClass: \"normal-case\",\n    category: \"Text Transform\",\n  },\n\n  // Padding (Simplified - showing most common ones)\n  { userFriendly: \"No Padding\", tailwindClass: \"p-0\", category: \"Padding\" },\n  { userFriendly: \"Tiny Padding\", tailwindClass: \"p-1\", category: \"Padding\" },\n  { userFriendly: \"Small Padding\", tailwindClass: \"p-2\", category: \"Padding\" },\n  { userFriendly: \"Medium Padding\", tailwindClass: \"p-4\", category: \"Padding\" },\n  { userFriendly: \"Large Padding\", tailwindClass: \"p-6\", category: \"Padding\" },\n  {\n    userFriendly: \"Extra Large Padding\",\n    tailwindClass: \"p-8\",\n    category: \"Padding\",\n  },\n  {\n    userFriendly: \"Small Horizontal Padding\",\n    tailwindClass: \"px-2\",\n    category: \"Padding\",\n  },\n  {\n    userFriendly: \"Medium Horizontal Padding\",\n    tailwindClass: \"px-4\",\n    category: \"Padding\",\n  },\n  {\n    userFriendly: \"Large Horizontal Padding\",\n    tailwindClass: \"px-6\",\n    category: \"Padding\",\n  },\n  {\n    userFriendly: \"Small Vertical Padding\",\n    tailwindClass: \"py-2\",\n    category: \"Padding\",\n  },\n  {\n    userFriendly: \"Medium Vertical Padding\",\n    tailwindClass: \"py-4\",\n    category: \"Padding\",\n  },\n  {\n    userFriendly: \"Large Vertical Padding\",\n    tailwindClass: \"py-6\",\n    category: \"Padding\",\n  },\n\n  // Margin (Simplified - showing most common ones)\n  { userFriendly: \"No Margin\", tailwindClass: \"m-0\", category: \"Margin\" },\n  { userFriendly: \"Tiny Margin\", tailwindClass: \"m-1\", category: \"Margin\" },\n  { userFriendly: \"Small Margin\", tailwindClass: \"m-2\", category: \"Margin\" },\n  { userFriendly: \"Medium Margin\", tailwindClass: \"m-4\", category: \"Margin\" },\n  { userFriendly: \"Large Margin\", tailwindClass: \"m-6\", category: \"Margin\" },\n  {\n    userFriendly: \"Extra Large Margin\",\n    tailwindClass: \"m-8\",\n    category: \"Margin\",\n  },\n  {\n    userFriendly: \"Center Horizontally\",\n    tailwindClass: \"mx-auto\",\n    category: \"Margin\",\n  },\n  {\n    userFriendly: \"Small Horizontal Margin\",\n    tailwindClass: \"mx-2\",\n    category: \"Margin\",\n  },\n  {\n    userFriendly: \"Medium Horizontal Margin\",\n    tailwindClass: \"mx-4\",\n    category: \"Margin\",\n  },\n  {\n    userFriendly: \"Small Vertical Margin\",\n    tailwindClass: \"my-2\",\n    category: \"Margin\",\n  },\n  {\n    userFriendly: \"Medium Vertical Margin\",\n    tailwindClass: \"my-4\",\n    category: \"Margin\",\n  },\n\n  // Border\n  { userFriendly: \"Border\", tailwindClass: \"border\", category: \"Border\" },\n  { userFriendly: \"No Border\", tailwindClass: \"border-0\", category: \"Border\" },\n  {\n    userFriendly: \"Thick Border\",\n    tailwindClass: \"border-2\",\n    category: \"Border\",\n  },\n  {\n    userFriendly: \"Very Thick Border\",\n    tailwindClass: \"border-4\",\n    category: \"Border\",\n  },\n  { userFriendly: \"Top Border\", tailwindClass: \"border-t\", category: \"Border\" },\n  {\n    userFriendly: \"Bottom Border\",\n    tailwindClass: \"border-b\",\n    category: \"Border\",\n  },\n  {\n    userFriendly: \"Left Border\",\n    tailwindClass: \"border-l\",\n    category: \"Border\",\n  },\n  {\n    userFriendly: \"Right Border\",\n    tailwindClass: \"border-r\",\n    category: \"Border\",\n  },\n  {\n    userFriendly: \"Solid Border\",\n    tailwindClass: \"border-solid\",\n    category: \"Border\",\n  },\n  {\n    userFriendly: \"Dashed Border\",\n    tailwindClass: \"border-dashed\",\n    category: \"Border\",\n  },\n  {\n    userFriendly: \"Dotted Border\",\n    tailwindClass: \"border-dotted\",\n    category: \"Border\",\n  },\n\n  // Border Color\n  {\n    userFriendly: \"Red Border\",\n    tailwindClass: \"border-red-500\",\n    category: \"Border Color\",\n  },\n  {\n    userFriendly: \"Blue Border\",\n    tailwindClass: \"border-blue-500\",\n    category: \"Border Color\",\n  },\n  {\n    userFriendly: \"Green Border\",\n    tailwindClass: \"border-green-500\",\n    category: \"Border Color\",\n  },\n  {\n    userFriendly: \"Yellow Border\",\n    tailwindClass: \"border-yellow-500\",\n    category: \"Border Color\",\n  },\n  {\n    userFriendly: \"Purple Border\",\n    tailwindClass: \"border-purple-500\",\n    category: \"Border Color\",\n  },\n  {\n    userFriendly: \"Gray Border\",\n    tailwindClass: \"border-gray-300\",\n    category: \"Border Color\",\n  },\n\n  // Border Radius\n  {\n    userFriendly: \"No Rounded\",\n    tailwindClass: \"rounded-none\",\n    category: \"Border Radius\",\n  },\n  {\n    userFriendly: \"Small Rounded\",\n    tailwindClass: \"rounded-sm\",\n    category: \"Border Radius\",\n  },\n  {\n    userFriendly: \"Rounded\",\n    tailwindClass: \"rounded\",\n    category: \"Border Radius\",\n  },\n  {\n    userFriendly: \"Medium Rounded\",\n    tailwindClass: \"rounded-md\",\n    category: \"Border Radius\",\n  },\n  {\n    userFriendly: \"Large Rounded\",\n    tailwindClass: \"rounded-lg\",\n    category: \"Border Radius\",\n  },\n  {\n    userFriendly: \"Extra Large Rounded\",\n    tailwindClass: \"rounded-xl\",\n    category: \"Border Radius\",\n  },\n  {\n    userFriendly: \"Full Rounded (Circle)\",\n    tailwindClass: \"rounded-full\",\n    category: \"Border Radius\",\n  },\n\n  // Shadow\n  {\n    userFriendly: \"No Shadow\",\n    tailwindClass: \"shadow-none\",\n    category: \"Shadow\",\n  },\n  {\n    userFriendly: \"Small Shadow\",\n    tailwindClass: \"shadow-sm\",\n    category: \"Shadow\",\n  },\n  { userFriendly: \"Shadow\", tailwindClass: \"shadow\", category: \"Shadow\" },\n  {\n    userFriendly: \"Medium Shadow\",\n    tailwindClass: \"shadow-md\",\n    category: \"Shadow\",\n  },\n  {\n    userFriendly: \"Large Shadow\",\n    tailwindClass: \"shadow-lg\",\n    category: \"Shadow\",\n  },\n  {\n    userFriendly: \"Extra Large Shadow\",\n    tailwindClass: \"shadow-xl\",\n    category: \"Shadow\",\n  },\n  {\n    userFriendly: \"2X Large Shadow\",\n    tailwindClass: \"shadow-2xl\",\n    category: \"Shadow\",\n  },\n\n  // Opacity\n  {\n    userFriendly: \"Invisible\",\n    tailwindClass: \"opacity-0\",\n    category: \"Opacity\",\n  },\n  {\n    userFriendly: \"Quarter Visible\",\n    tailwindClass: \"opacity-25\",\n    category: \"Opacity\",\n  },\n  {\n    userFriendly: \"Half Visible\",\n    tailwindClass: \"opacity-50\",\n    category: \"Opacity\",\n  },\n  {\n    userFriendly: \"Three-Quarters Visible\",\n    tailwindClass: \"opacity-75\",\n    category: \"Opacity\",\n  },\n  {\n    userFriendly: \"Fully Visible\",\n    tailwindClass: \"opacity-100\",\n    category: \"Opacity\",\n  },\n\n  // Display\n  { userFriendly: \"Block\", tailwindClass: \"block\", category: \"Display\" },\n  {\n    userFriendly: \"Inline Block\",\n    tailwindClass: \"inline-block\",\n    category: \"Display\",\n  },\n  { userFriendly: \"Inline\", tailwindClass: \"inline\", category: \"Display\" },\n  { userFriendly: \"Flex\", tailwindClass: \"flex\", category: \"Display\" },\n  { userFriendly: \"Grid\", tailwindClass: \"grid\", category: \"Display\" },\n  { userFriendly: \"Hidden\", tailwindClass: \"hidden\", category: \"Display\" },\n\n  // Flex\n  { userFriendly: \"Flex Row\", tailwindClass: \"flex-row\", category: \"Flex\" },\n  { userFriendly: \"Flex Column\", tailwindClass: \"flex-col\", category: \"Flex\" },\n  { userFriendly: \"Flex Wrap\", tailwindClass: \"flex-wrap\", category: \"Flex\" },\n  { userFriendly: \"No Wrap\", tailwindClass: \"flex-nowrap\", category: \"Flex\" },\n\n  // Justify Content\n  {\n    userFriendly: \"Justify Start\",\n    tailwindClass: \"justify-start\",\n    category: \"Justify Content\",\n  },\n  {\n    userFriendly: \"Justify Center\",\n    tailwindClass: \"justify-center\",\n    category: \"Justify Content\",\n  },\n  {\n    userFriendly: \"Justify End\",\n    tailwindClass: \"justify-end\",\n    category: \"Justify Content\",\n  },\n  {\n    userFriendly: \"Justify Between\",\n    tailwindClass: \"justify-between\",\n    category: \"Justify Content\",\n  },\n  {\n    userFriendly: \"Justify Around\",\n    tailwindClass: \"justify-around\",\n    category: \"Justify Content\",\n  },\n\n  // Align Items\n  {\n    userFriendly: \"Align Start\",\n    tailwindClass: \"items-start\",\n    category: \"Align Items\",\n  },\n  {\n    userFriendly: \"Align Center\",\n    tailwindClass: \"items-center\",\n    category: \"Align Items\",\n  },\n  {\n    userFriendly: \"Align End\",\n    tailwindClass: \"items-end\",\n    category: \"Align Items\",\n  },\n  {\n    userFriendly: \"Align Stretch\",\n    tailwindClass: \"items-stretch\",\n    category: \"Align Items\",\n  },\n\n  // Gap\n  { userFriendly: \"No Gap\", tailwindClass: \"gap-0\", category: \"Gap\" },\n  { userFriendly: \"Tiny Gap\", tailwindClass: \"gap-1\", category: \"Gap\" },\n  { userFriendly: \"Small Gap\", tailwindClass: \"gap-2\", category: \"Gap\" },\n  { userFriendly: \"Medium Gap\", tailwindClass: \"gap-4\", category: \"Gap\" },\n  { userFriendly: \"Large Gap\", tailwindClass: \"gap-6\", category: \"Gap\" },\n  { userFriendly: \"Extra Large Gap\", tailwindClass: \"gap-8\", category: \"Gap\" },\n\n  // Transitions\n  {\n    userFriendly: \"No Transition\",\n    tailwindClass: \"transition-none\",\n    category: \"Transitions\",\n  },\n  {\n    userFriendly: \"Transition All\",\n    tailwindClass: \"transition-all\",\n    category: \"Transitions\",\n  },\n  {\n    userFriendly: \"Transition\",\n    tailwindClass: \"transition\",\n    category: \"Transitions\",\n  },\n  {\n    userFriendly: \"Transition Colors\",\n    tailwindClass: \"transition-colors\",\n    category: \"Transitions\",\n  },\n  {\n    userFriendly: \"Fast Duration\",\n    tailwindClass: \"duration-150\",\n    category: \"Transitions\",\n  },\n  {\n    userFriendly: \"Normal Duration\",\n    tailwindClass: \"duration-300\",\n    category: \"Transitions\",\n  },\n  {\n    userFriendly: \"Slow Duration\",\n    tailwindClass: \"duration-500\",\n    category: \"Transitions\",\n  },\n\n  // Cursor\n  {\n    userFriendly: \"Pointer Cursor\",\n    tailwindClass: \"cursor-pointer\",\n    category: \"Cursor\",\n  },\n  {\n    userFriendly: \"Default Cursor\",\n    tailwindClass: \"cursor-default\",\n    category: \"Cursor\",\n  },\n  {\n    userFriendly: \"Not Allowed Cursor\",\n    tailwindClass: \"cursor-not-allowed\",\n    category: \"Cursor\",\n  },\n\n  // Position\n  { userFriendly: \"Static\", tailwindClass: \"static\", category: \"Position\" },\n  { userFriendly: \"Relative\", tailwindClass: \"relative\", category: \"Position\" },\n  { userFriendly: \"Absolute\", tailwindClass: \"absolute\", category: \"Position\" },\n  { userFriendly: \"Fixed\", tailwindClass: \"fixed\", category: \"Position\" },\n  { userFriendly: \"Sticky\", tailwindClass: \"sticky\", category: \"Position\" },\n\n  // Overflow\n  {\n    userFriendly: \"Overflow Auto\",\n    tailwindClass: \"overflow-auto\",\n    category: \"Overflow\",\n  },\n  {\n    userFriendly: \"Overflow Hidden\",\n    tailwindClass: \"overflow-hidden\",\n    category: \"Overflow\",\n  },\n  {\n    userFriendly: \"Overflow Scroll\",\n    tailwindClass: \"overflow-scroll\",\n    category: \"Overflow\",\n  },\n\n  // Letter Spacing\n  {\n    userFriendly: \"Tight Spacing\",\n    tailwindClass: \"tracking-tight\",\n    category: \"Letter Spacing\",\n  },\n  {\n    userFriendly: \"Normal Spacing\",\n    tailwindClass: \"tracking-normal\",\n    category: \"Letter Spacing\",\n  },\n  {\n    userFriendly: \"Wide Spacing\",\n    tailwindClass: \"tracking-wide\",\n    category: \"Letter Spacing\",\n  },\n  {\n    userFriendly: \"Wider Spacing\",\n    tailwindClass: \"tracking-wider\",\n    category: \"Letter Spacing\",\n  },\n\n  // Line Height\n  {\n    userFriendly: \"Tight Line Height\",\n    tailwindClass: \"leading-tight\",\n    category: \"Line Height\",\n  },\n  {\n    userFriendly: \"Normal Line Height\",\n    tailwindClass: \"leading-normal\",\n    category: \"Line Height\",\n  },\n  {\n    userFriendly: \"Relaxed Line Height\",\n    tailwindClass: \"leading-relaxed\",\n    category: \"Line Height\",\n  },\n  {\n    userFriendly: \"Loose Line Height\",\n    tailwindClass: \"leading-loose\",\n    category: \"Line Height\",\n  },\n]\n\n/**\n * Get grouped classes with user-friendly names\n */\nexport function getUserFriendlyClasses(): {\n  category: string\n  items: { label: string; value: string }[]\n}[] {\n  const grouped = new Map<string, { label: string; value: string }[]>()\n\n  classMappings.forEach(({ category, userFriendly, tailwindClass }) => {\n    if (!grouped.has(category)) {\n      grouped.set(category, [])\n    }\n    grouped.get(category)!.push({\n      label: userFriendly,\n      value: tailwindClass,\n    })\n  })\n\n  return Array.from(grouped.entries()).map(([category, items]) => ({\n    category,\n    items,\n  }))\n}\n\n/**\n * Search user-friendly classes\n */\nexport function searchUserFriendlyClasses(query: string) {\n  const lowerQuery = query.toLowerCase()\n  const grouped = new Map<string, { label: string; value: string }[]>()\n\n  classMappings\n    .filter(\n      ({ userFriendly, tailwindClass }) =>\n        userFriendly.toLowerCase().includes(lowerQuery) ||\n        tailwindClass.toLowerCase().includes(lowerQuery)\n    )\n    .forEach(({ category, userFriendly, tailwindClass }) => {\n      if (!grouped.has(category)) {\n        grouped.set(category, [])\n      }\n      grouped.get(category)!.push({\n        label: userFriendly,\n        value: tailwindClass,\n      })\n    })\n\n  return Array.from(grouped.entries()).map(([category, items]) => ({\n    category,\n    items,\n  }))\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/tailwind-classes.ts",
      "content": "/**\n * Comprehensive Tailwind CSS classes organized by category\n * for use in the Custom Class Popover\n */\n\nexport interface TailwindClassGroup {\n  category: string\n  classes: string[]\n}\n\nexport const tailwindClasses: TailwindClassGroup[] = [\n  {\n    category: \"Text Color\",\n    classes: [\n      \"text-red-500\",\n      \"text-red-600\",\n      \"text-red-700\",\n      \"text-blue-500\",\n      \"text-blue-600\",\n      \"text-blue-700\",\n      \"text-green-500\",\n      \"text-green-600\",\n      \"text-green-700\",\n      \"text-yellow-500\",\n      \"text-yellow-600\",\n      \"text-yellow-700\",\n      \"text-purple-500\",\n      \"text-purple-600\",\n      \"text-purple-700\",\n      \"text-pink-500\",\n      \"text-pink-600\",\n      \"text-pink-700\",\n      \"text-indigo-500\",\n      \"text-indigo-600\",\n      \"text-indigo-700\",\n      \"text-gray-500\",\n      \"text-gray-600\",\n      \"text-gray-700\",\n      \"text-gray-800\",\n      \"text-gray-900\",\n      \"text-white\",\n      \"text-black\",\n    ],\n  },\n  {\n    category: \"Background Color\",\n    classes: [\n      \"bg-red-50\",\n      \"bg-red-100\",\n      \"bg-red-200\",\n      \"bg-red-500\",\n      \"bg-blue-50\",\n      \"bg-blue-100\",\n      \"bg-blue-200\",\n      \"bg-blue-500\",\n      \"bg-green-50\",\n      \"bg-green-100\",\n      \"bg-green-200\",\n      \"bg-green-500\",\n      \"bg-yellow-50\",\n      \"bg-yellow-100\",\n      \"bg-yellow-200\",\n      \"bg-yellow-500\",\n      \"bg-purple-50\",\n      \"bg-purple-100\",\n      \"bg-purple-200\",\n      \"bg-purple-500\",\n      \"bg-pink-50\",\n      \"bg-pink-100\",\n      \"bg-pink-200\",\n      \"bg-pink-500\",\n      \"bg-indigo-50\",\n      \"bg-indigo-100\",\n      \"bg-indigo-200\",\n      \"bg-indigo-500\",\n      \"bg-gray-50\",\n      \"bg-gray-100\",\n      \"bg-gray-200\",\n      \"bg-gray-500\",\n      \"bg-white\",\n      \"bg-black\",\n      \"bg-transparent\",\n    ],\n  },\n  {\n    category: \"Font Size\",\n    classes: [\n      \"text-xs\",\n      \"text-sm\",\n      \"text-base\",\n      \"text-lg\",\n      \"text-xl\",\n      \"text-2xl\",\n      \"text-3xl\",\n      \"text-4xl\",\n      \"text-5xl\",\n      \"text-6xl\",\n      \"text-7xl\",\n      \"text-8xl\",\n      \"text-9xl\",\n    ],\n  },\n  {\n    category: \"Font Weight\",\n    classes: [\n      \"font-thin\",\n      \"font-extralight\",\n      \"font-light\",\n      \"font-normal\",\n      \"font-medium\",\n      \"font-semibold\",\n      \"font-bold\",\n      \"font-extrabold\",\n      \"font-black\",\n    ],\n  },\n  {\n    category: \"Text Decoration\",\n    classes: [\n      \"underline\",\n      \"overline\",\n      \"line-through\",\n      \"no-underline\",\n      \"decoration-solid\",\n      \"decoration-double\",\n      \"decoration-dotted\",\n      \"decoration-dashed\",\n      \"decoration-wavy\",\n      \"underline-offset-1\",\n      \"underline-offset-2\",\n      \"underline-offset-4\",\n      \"underline-offset-8\",\n    ],\n  },\n  {\n    category: \"Text Alignment\",\n    classes: [\n      \"text-left\",\n      \"text-center\",\n      \"text-right\",\n      \"text-justify\",\n      \"text-start\",\n      \"text-end\",\n    ],\n  },\n  {\n    category: \"Text Transform\",\n    classes: [\"uppercase\", \"lowercase\", \"capitalize\", \"normal-case\"],\n  },\n  {\n    category: \"Padding\",\n    classes: [\n      \"p-0\",\n      \"p-1\",\n      \"p-2\",\n      \"p-3\",\n      \"p-4\",\n      \"p-5\",\n      \"p-6\",\n      \"p-8\",\n      \"p-10\",\n      \"p-12\",\n      \"px-1\",\n      \"px-2\",\n      \"px-3\",\n      \"px-4\",\n      \"px-6\",\n      \"px-8\",\n      \"py-1\",\n      \"py-2\",\n      \"py-3\",\n      \"py-4\",\n      \"py-6\",\n      \"py-8\",\n      \"pt-1\",\n      \"pt-2\",\n      \"pt-4\",\n      \"pt-6\",\n      \"pt-8\",\n      \"pb-1\",\n      \"pb-2\",\n      \"pb-4\",\n      \"pb-6\",\n      \"pb-8\",\n      \"pl-1\",\n      \"pl-2\",\n      \"pl-4\",\n      \"pl-6\",\n      \"pl-8\",\n      \"pr-1\",\n      \"pr-2\",\n      \"pr-4\",\n      \"pr-6\",\n      \"pr-8\",\n    ],\n  },\n  {\n    category: \"Margin\",\n    classes: [\n      \"m-0\",\n      \"m-1\",\n      \"m-2\",\n      \"m-3\",\n      \"m-4\",\n      \"m-5\",\n      \"m-6\",\n      \"m-8\",\n      \"m-10\",\n      \"m-12\",\n      \"mx-1\",\n      \"mx-2\",\n      \"mx-3\",\n      \"mx-4\",\n      \"mx-6\",\n      \"mx-8\",\n      \"mx-auto\",\n      \"my-1\",\n      \"my-2\",\n      \"my-3\",\n      \"my-4\",\n      \"my-6\",\n      \"my-8\",\n      \"mt-1\",\n      \"mt-2\",\n      \"mt-4\",\n      \"mt-6\",\n      \"mt-8\",\n      \"mb-1\",\n      \"mb-2\",\n      \"mb-4\",\n      \"mb-6\",\n      \"mb-8\",\n      \"ml-1\",\n      \"ml-2\",\n      \"ml-4\",\n      \"ml-6\",\n      \"ml-8\",\n      \"mr-1\",\n      \"mr-2\",\n      \"mr-4\",\n      \"mr-6\",\n      \"mr-8\",\n    ],\n  },\n  {\n    category: \"Border\",\n    classes: [\n      \"border\",\n      \"border-0\",\n      \"border-2\",\n      \"border-4\",\n      \"border-8\",\n      \"border-t\",\n      \"border-b\",\n      \"border-l\",\n      \"border-r\",\n      \"border-solid\",\n      \"border-dashed\",\n      \"border-dotted\",\n      \"border-double\",\n      \"border-none\",\n    ],\n  },\n  {\n    category: \"Border Color\",\n    classes: [\n      \"border-red-500\",\n      \"border-blue-500\",\n      \"border-green-500\",\n      \"border-yellow-500\",\n      \"border-purple-500\",\n      \"border-pink-500\",\n      \"border-indigo-500\",\n      \"border-gray-200\",\n      \"border-gray-300\",\n      \"border-gray-400\",\n      \"border-gray-500\",\n      \"border-white\",\n      \"border-black\",\n      \"border-transparent\",\n    ],\n  },\n  {\n    category: \"Border Radius\",\n    classes: [\n      \"rounded-none\",\n      \"rounded-sm\",\n      \"rounded\",\n      \"rounded-md\",\n      \"rounded-lg\",\n      \"rounded-xl\",\n      \"rounded-2xl\",\n      \"rounded-3xl\",\n      \"rounded-full\",\n      \"rounded-t-lg\",\n      \"rounded-b-lg\",\n      \"rounded-l-lg\",\n      \"rounded-r-lg\",\n    ],\n  },\n  {\n    category: \"Shadow\",\n    classes: [\n      \"shadow-none\",\n      \"shadow-sm\",\n      \"shadow\",\n      \"shadow-md\",\n      \"shadow-lg\",\n      \"shadow-xl\",\n      \"shadow-2xl\",\n      \"shadow-inner\",\n    ],\n  },\n  {\n    category: \"Opacity\",\n    classes: [\n      \"opacity-0\",\n      \"opacity-5\",\n      \"opacity-10\",\n      \"opacity-20\",\n      \"opacity-25\",\n      \"opacity-30\",\n      \"opacity-40\",\n      \"opacity-50\",\n      \"opacity-60\",\n      \"opacity-70\",\n      \"opacity-75\",\n      \"opacity-80\",\n      \"opacity-90\",\n      \"opacity-95\",\n      \"opacity-100\",\n    ],\n  },\n  {\n    category: \"Width\",\n    classes: [\n      \"w-auto\",\n      \"w-full\",\n      \"w-screen\",\n      \"w-min\",\n      \"w-max\",\n      \"w-fit\",\n      \"w-1/2\",\n      \"w-1/3\",\n      \"w-2/3\",\n      \"w-1/4\",\n      \"w-3/4\",\n      \"w-1/5\",\n      \"w-2/5\",\n      \"w-3/5\",\n      \"w-4/5\",\n      \"w-32\",\n      \"w-40\",\n      \"w-48\",\n      \"w-56\",\n      \"w-64\",\n      \"w-72\",\n      \"w-80\",\n      \"w-96\",\n    ],\n  },\n  {\n    category: \"Height\",\n    classes: [\n      \"h-auto\",\n      \"h-full\",\n      \"h-screen\",\n      \"h-min\",\n      \"h-max\",\n      \"h-fit\",\n      \"h-32\",\n      \"h-40\",\n      \"h-48\",\n      \"h-56\",\n      \"h-64\",\n      \"h-72\",\n      \"h-80\",\n      \"h-96\",\n    ],\n  },\n  {\n    category: \"Display\",\n    classes: [\n      \"block\",\n      \"inline-block\",\n      \"inline\",\n      \"flex\",\n      \"inline-flex\",\n      \"grid\",\n      \"inline-grid\",\n      \"hidden\",\n    ],\n  },\n  {\n    category: \"Flex\",\n    classes: [\n      \"flex-row\",\n      \"flex-row-reverse\",\n      \"flex-col\",\n      \"flex-col-reverse\",\n      \"flex-wrap\",\n      \"flex-wrap-reverse\",\n      \"flex-nowrap\",\n      \"flex-1\",\n      \"flex-auto\",\n      \"flex-initial\",\n      \"flex-none\",\n    ],\n  },\n  {\n    category: \"Justify Content\",\n    classes: [\n      \"justify-start\",\n      \"justify-end\",\n      \"justify-center\",\n      \"justify-between\",\n      \"justify-around\",\n      \"justify-evenly\",\n    ],\n  },\n  {\n    category: \"Align Items\",\n    classes: [\n      \"items-start\",\n      \"items-end\",\n      \"items-center\",\n      \"items-baseline\",\n      \"items-stretch\",\n    ],\n  },\n  {\n    category: \"Gap\",\n    classes: [\n      \"gap-0\",\n      \"gap-1\",\n      \"gap-2\",\n      \"gap-3\",\n      \"gap-4\",\n      \"gap-5\",\n      \"gap-6\",\n      \"gap-8\",\n      \"gap-10\",\n      \"gap-12\",\n      \"gap-x-1\",\n      \"gap-x-2\",\n      \"gap-x-4\",\n      \"gap-x-6\",\n      \"gap-y-1\",\n      \"gap-y-2\",\n      \"gap-y-4\",\n      \"gap-y-6\",\n    ],\n  },\n  {\n    category: \"Position\",\n    classes: [\"static\", \"fixed\", \"absolute\", \"relative\", \"sticky\"],\n  },\n  {\n    category: \"Z-Index\",\n    classes: [\"z-0\", \"z-10\", \"z-20\", \"z-30\", \"z-40\", \"z-50\", \"z-auto\"],\n  },\n  {\n    category: \"Overflow\",\n    classes: [\n      \"overflow-auto\",\n      \"overflow-hidden\",\n      \"overflow-visible\",\n      \"overflow-scroll\",\n      \"overflow-x-auto\",\n      \"overflow-y-auto\",\n      \"overflow-x-hidden\",\n      \"overflow-y-hidden\",\n    ],\n  },\n  {\n    category: \"Cursor\",\n    classes: [\n      \"cursor-auto\",\n      \"cursor-default\",\n      \"cursor-pointer\",\n      \"cursor-wait\",\n      \"cursor-text\",\n      \"cursor-move\",\n      \"cursor-help\",\n      \"cursor-not-allowed\",\n    ],\n  },\n  {\n    category: \"User Select\",\n    classes: [\"select-none\", \"select-text\", \"select-all\", \"select-auto\"],\n  },\n  {\n    category: \"Transitions\",\n    classes: [\n      \"transition-none\",\n      \"transition-all\",\n      \"transition\",\n      \"transition-colors\",\n      \"transition-opacity\",\n      \"transition-shadow\",\n      \"transition-transform\",\n      \"duration-75\",\n      \"duration-100\",\n      \"duration-150\",\n      \"duration-200\",\n      \"duration-300\",\n      \"duration-500\",\n      \"duration-700\",\n      \"duration-1000\",\n      \"ease-linear\",\n      \"ease-in\",\n      \"ease-out\",\n      \"ease-in-out\",\n    ],\n  },\n  {\n    category: \"Transform\",\n    classes: [\n      \"scale-0\",\n      \"scale-50\",\n      \"scale-75\",\n      \"scale-90\",\n      \"scale-95\",\n      \"scale-100\",\n      \"scale-105\",\n      \"scale-110\",\n      \"scale-125\",\n      \"scale-150\",\n      \"rotate-0\",\n      \"rotate-45\",\n      \"rotate-90\",\n      \"rotate-180\",\n      \"-rotate-45\",\n      \"-rotate-90\",\n      \"-rotate-180\",\n      \"skew-x-3\",\n      \"skew-x-6\",\n      \"skew-x-12\",\n      \"skew-y-3\",\n      \"skew-y-6\",\n      \"skew-y-12\",\n    ],\n  },\n  {\n    category: \"Gradient\",\n    classes: [\n      \"bg-gradient-to-t\",\n      \"bg-gradient-to-tr\",\n      \"bg-gradient-to-r\",\n      \"bg-gradient-to-br\",\n      \"bg-gradient-to-b\",\n      \"bg-gradient-to-bl\",\n      \"bg-gradient-to-l\",\n      \"bg-gradient-to-tl\",\n      \"from-red-500\",\n      \"from-blue-500\",\n      \"from-green-500\",\n      \"from-yellow-500\",\n      \"from-purple-500\",\n      \"via-red-500\",\n      \"via-blue-500\",\n      \"via-green-500\",\n      \"to-red-500\",\n      \"to-blue-500\",\n      \"to-green-500\",\n      \"to-yellow-500\",\n      \"to-purple-500\",\n    ],\n  },\n  {\n    category: \"Letter Spacing\",\n    classes: [\n      \"tracking-tighter\",\n      \"tracking-tight\",\n      \"tracking-normal\",\n      \"tracking-wide\",\n      \"tracking-wider\",\n      \"tracking-widest\",\n    ],\n  },\n  {\n    category: \"Line Height\",\n    classes: [\n      \"leading-none\",\n      \"leading-tight\",\n      \"leading-snug\",\n      \"leading-normal\",\n      \"leading-relaxed\",\n      \"leading-loose\",\n      \"leading-3\",\n      \"leading-4\",\n      \"leading-5\",\n      \"leading-6\",\n      \"leading-7\",\n      \"leading-8\",\n      \"leading-9\",\n      \"leading-10\",\n    ],\n  },\n  {\n    category: \"List Style\",\n    classes: [\n      \"list-none\",\n      \"list-disc\",\n      \"list-decimal\",\n      \"list-inside\",\n      \"list-outside\",\n    ],\n  },\n  {\n    category: \"Whitespace\",\n    classes: [\n      \"whitespace-normal\",\n      \"whitespace-nowrap\",\n      \"whitespace-pre\",\n      \"whitespace-pre-line\",\n      \"whitespace-pre-wrap\",\n    ],\n  },\n  {\n    category: \"Word Break\",\n    classes: [\"break-normal\", \"break-words\", \"break-all\", \"truncate\"],\n  },\n]\n\n/**\n * Get popular/frequently used classes for quick access\n */\nexport const popularClasses = [\n  \"text-red-500\",\n  \"text-blue-500\",\n  \"text-green-500\",\n  \"bg-yellow-100\",\n  \"bg-blue-100\",\n  \"bg-green-100\",\n  \"font-bold\",\n  \"font-semibold\",\n  \"underline\",\n  \"text-2xl\",\n  \"text-xl\",\n  \"opacity-50\",\n  \"rounded-lg\",\n  \"shadow-md\",\n  \"p-4\",\n  \"m-4\",\n  \"border\",\n  \"flex\",\n  \"grid\",\n  \"text-center\",\n]\n\n/**\n * Search classes by keyword\n */\nexport function searchTailwindClasses(query: string): string[] {\n  const lowerQuery = query.toLowerCase()\n  const results: string[] = []\n\n  tailwindClasses.forEach((group) => {\n    group.classes.forEach((className) => {\n      if (className.toLowerCase().includes(lowerQuery)) {\n        results.push(className)\n      }\n    })\n  })\n\n  return results\n}\n\n/**\n * Get all classes as a flat array\n */\nexport function getAllClasses(): string[] {\n  return tailwindClasses.flatMap((group) => group.classes)\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/demo-content.ts",
      "content": "/**\n * Demo Content for Rich Editor\n *\n * Professional showcase document demonstrating all editor features including:\n * - Text formatting (bold, italic, underline)\n * - Element types (h1-h6, p, code, blockquote, lists)\n * - Inline element types for mixed styling\n * - Color support (preset and custom colors)\n * - Font size control\n * - Image support (single and grid layout)\n * - Links with modern popover\n * - Nested blocks (containers)\n * - Drag & drop to reorder blocks and images\n * - Background colors (preset and custom)\n * - HTML export functionality\n * - Ordered and unordered lists\n *\n * @packageDocumentation\n */\n\nimport { ContainerNode, EditorNode, TextNode } from \"./types\"\n\n/**\n * Creates comprehensive demo content showcasing all editor features.\n *\n * @param timestamp - Optional timestamp for unique IDs (defaults to a stable value for demo content)\n * @returns Array of demo nodes ready to be used as editor content\n *\n * @example\n * ```typescript\n * import { createDemoContent } from '@/lib/demo-content';\n *\n * const demoNodes = createDemoContent();\n * const newContainer: ContainerNode = {\n *   id: 'root',\n *   type: 'container',\n *   children: demoNodes,\n *   attributes: {}\n * };\n * ```\n */\nexport function createDemoContent(\n  timestamp: number = 1000000000000\n): EditorNode[] {\n  return [\n    // ========================================\n    // HERO SECTION\n    // ========================================\n    {\n      id: `h1-${timestamp}-1`,\n      type: \"h1\",\n      content: \"✨ Rich Text Editor\",\n      attributes: {},\n    } as TextNode,\n\n    // ========================================\n    // VERSION UPDATE SECTION\n    // ========================================\n    {\n      id: `blockquote-${timestamp}-version-1`,\n      type: \"blockquote\",\n      children: [\n        {\n          content: \"🎉 Version 0.1.0 - Major Update!\",\n          bold: true,\n          className: \"text-green-600 dark:text-green-400 text-lg\",\n        },\n        { content: \" \", italic: true },\n        {\n          content:\n            \"Fresh new features just landed! Check out what's new below.\",\n          italic: true,\n        },\n      ],\n      attributes: {\n        className:\n          \"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-l-4 border-green-500\",\n      },\n    } as TextNode,\n\n    {\n      id: `h2-${timestamp}-version-2`,\n      type: \"h2\",\n      content: \"🆕 What's New in v0.1.0\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-version-3`,\n      type: \"h3\",\n      content: \"📊 Table Support - Full-Featured Spreadsheet-like Tables\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-version-4`,\n      type: \"p\",\n      content:\n        \"Create powerful, interactive tables with comprehensive editing capabilities. Perfect for data presentation, comparisons, and structured content:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-version-5`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-version-5-1`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Create tables\", bold: true },\n            { content: \" with custom rows and columns\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-5-2`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Drag columns\", bold: true },\n            { content: \" to reorder them horizontally\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-5-3`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Drag rows\", bold: true },\n            { content: \" to reorder them vertically\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-5-4`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Resize columns\", bold: true },\n            { content: \" by dragging column borders\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-5-5`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Add/remove\", bold: true },\n            { content: \" rows and columns on the fly\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-5-6`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Drag entire tables\", bold: true },\n            { content: \" to reorder them between blocks\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-5-7`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Import markdown tables\", bold: true },\n            {\n              content: \" - paste from GitHub, Notion, or any markdown source\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `p-${timestamp}-version-6`,\n      type: \"p\",\n      content:\n        \"Here's a live example table - try dragging columns, rows, or resizing:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `table-wrapper-${timestamp}-version-7`,\n      type: \"container\",\n      children: [\n        {\n          id: `table-${timestamp}-version-7`,\n          type: \"table\",\n          children: [\n            {\n              id: `thead-${timestamp}-version-7`,\n              type: \"thead\",\n              children: [\n                {\n                  id: `tr-header-${timestamp}-version-7`,\n                  type: \"tr\",\n                  children: [\n                    {\n                      id: `th-${timestamp}-version-7-0`,\n                      type: \"th\",\n                      content: \"Feature\",\n                      attributes: {},\n                    } as TextNode,\n                    {\n                      id: `th-${timestamp}-version-7-1`,\n                      type: \"th\",\n                      content: \"Status\",\n                      attributes: {},\n                    } as TextNode,\n                    {\n                      id: `th-${timestamp}-version-7-2`,\n                      type: \"th\",\n                      content: \"Version\",\n                      attributes: {},\n                    } as TextNode,\n                  ],\n                  attributes: {},\n                },\n              ],\n              attributes: {},\n            },\n            {\n              id: `tbody-${timestamp}-version-7`,\n              type: \"tbody\",\n              children: [\n                {\n                  id: `tr-${timestamp}-version-7-0`,\n                  type: \"tr\",\n                  children: [\n                    {\n                      id: `td-${timestamp}-version-7-0-0`,\n                      type: \"td\",\n                      content: \"Table Support\",\n                      attributes: {},\n                    } as TextNode,\n                    {\n                      id: `td-${timestamp}-version-7-0-1`,\n                      type: \"td\",\n                      content: \"✅ Released\",\n                      attributes: {},\n                    } as TextNode,\n                    {\n                      id: `td-${timestamp}-version-7-0-2`,\n                      type: \"td\",\n                      content: \"0.1.0\",\n                      attributes: {},\n                    } as TextNode,\n                  ],\n                  attributes: {},\n                },\n                {\n                  id: `tr-${timestamp}-version-7-1`,\n                  type: \"tr\",\n                  children: [\n                    {\n                      id: `td-${timestamp}-version-7-1-0`,\n                      type: \"td\",\n                      content: \"Multi-Select Images\",\n                      attributes: {},\n                    } as TextNode,\n                    {\n                      id: `td-${timestamp}-version-7-1-1`,\n                      type: \"td\",\n                      content: \"✅ Released\",\n                      attributes: {},\n                    } as TextNode,\n                    {\n                      id: `td-${timestamp}-version-7-1-2`,\n                      type: \"td\",\n                      content: \"0.1.0\",\n                      attributes: {},\n                    } as TextNode,\n                  ],\n                  attributes: {},\n                },\n                {\n                  id: `tr-${timestamp}-version-7-2`,\n                  type: \"tr\",\n                  children: [\n                    {\n                      id: `td-${timestamp}-version-7-2-0`,\n                      type: \"td\",\n                      content: \"Enhanced Drag & Drop\",\n                      attributes: {},\n                    } as TextNode,\n                    {\n                      id: `td-${timestamp}-version-7-2-1`,\n                      type: \"td\",\n                      content: \"✅ Released\",\n                      attributes: {},\n                    } as TextNode,\n                    {\n                      id: `td-${timestamp}-version-7-2-2`,\n                      type: \"td\",\n                      content: \"0.1.0\",\n                      attributes: {},\n                    } as TextNode,\n                  ],\n                  attributes: {},\n                },\n              ],\n              attributes: {},\n            },\n          ],\n          attributes: {},\n        },\n      ],\n      attributes: {},\n    } as ContainerNode,\n\n    {\n      id: `h3-${timestamp}-version-8`,\n      type: \"h3\",\n      content: \"🖼️ Multi-Select Images with Ctrl+Click\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-version-9`,\n      type: \"p\",\n      children: [\n        { content: \"Hold \", bold: false },\n        { content: \"Ctrl (⌘ on Mac)\", elementType: \"code\", bold: true },\n        {\n          content: \" and click multiple images to select them, then:\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-version-10`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-version-10-1`,\n          type: \"li\",\n          children: [\n            { content: \"📦 Group images\", bold: true },\n            { content: \" into a side-by-side flex layout\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-10-2`,\n          type: \"li\",\n          children: [\n            { content: \"🔄 Reverse order\", bold: true },\n            { content: \" of images in a grid\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-10-3`,\n          type: \"li\",\n          children: [\n            { content: \"📤 Extract images\", bold: true },\n            { content: \" from their container\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-10-4`,\n          type: \"li\",\n          children: [\n            { content: \"🎨 Visual feedback\", bold: true },\n            {\n              content: \" shows selected images with a blue border\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `blockquote-${timestamp}-version-11`,\n      type: \"blockquote\",\n      children: [\n        { content: \"💡 Pro Tip: \", bold: true },\n        {\n          content:\n            \"Select 2+ images from the same grid to reverse their order, or select images from different locations to group them into a beautiful side-by-side layout!\",\n          italic: true,\n        },\n      ],\n      attributes: {\n        className: \"bg-blue-50 dark:bg-blue-900/20 border-blue-600\",\n      },\n    } as TextNode,\n\n    // Demo: Multi-select showcase container with multiple images\n    {\n      id: `p-${timestamp}-version-11a`,\n      type: \"p\",\n      children: [\n        { content: \"Try it yourself! \", bold: true },\n        { content: \"Hold \", bold: false },\n        { content: \"Ctrl\", elementType: \"code\", bold: true },\n        { content: \" (\", bold: false },\n        { content: \"⌘\", elementType: \"code\", bold: true },\n        {\n          content: \" on Mac) and click on multiple images below:\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-multiselect-demo`,\n      type: \"container\",\n      attributes: {\n        layoutType: \"flex\",\n        gap: \"4\",\n        flexWrap: \"wrap\",\n        className:\n          \"bg-gradient-to-br from-purple-50 to-pink-50 dark:from-purple-900/20 dark:to-pink-900/20 p-6 rounded-lg border-2 border-dashed border-purple-300 dark:border-purple-700\",\n      },\n      children: [\n        {\n          id: `img-${timestamp}-demo-1`,\n          type: \"img\",\n          content: \"\",\n          attributes: {\n            src: \"/images/image_docs/color-picker.png\",\n            alt: \"Color picker demonstration\",\n            caption: \"🎨 Color Picker\",\n          },\n        } as TextNode,\n        {\n          id: `img-${timestamp}-demo-2`,\n          type: \"img\",\n          content: \"\",\n          attributes: {\n            src: \"/images/image_docs/custom-class.png\",\n            alt: \"Custom class feature\",\n            caption: \"✨ Custom Classes\",\n          },\n        } as TextNode,\n        {\n          id: `img-${timestamp}-demo-3`,\n          type: \"img\",\n          content: \"\",\n          attributes: {\n            src: \"/images/image_docs/font-size-controller.png\",\n            alt: \"Font size controller\",\n            caption: \"📏 Font Sizes\",\n          },\n        } as TextNode,\n        {\n          id: `img-${timestamp}-demo-4`,\n          type: \"img\",\n          content: \"\",\n          attributes: {\n            src: \"/images/image_docs/modern-link-popover.png\",\n            alt: \"Modern link popover\",\n            caption: \"🔗 Link Editor\",\n          },\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `h3-${timestamp}-version-12`,\n      type: \"h3\",\n      content: \"🎯 Enhanced Drag & Drop System\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-version-13`,\n      type: \"p\",\n      content:\n        \"Major improvements to the drag and drop experience across the entire editor:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-version-14`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-version-14-1`,\n          type: \"li\",\n          children: [\n            { content: \"🔧 Fixed table dragging\", bold: true },\n            {\n              content: \" - tables now move smoothly between blocks\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-14-2`,\n          type: \"li\",\n          children: [\n            { content: \"🔧 Fixed container blocks\", bold: true },\n            {\n              content: \" - nested content and lists now drag properly\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-14-3`,\n          type: \"li\",\n          children: [\n            { content: \"✨ Smart drop zones\", bold: true },\n            {\n              content:\n                \" - visual indicators show exactly where blocks will land\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-14-4`,\n          type: \"li\",\n          children: [\n            { content: \"🚫 No-op prevention\", bold: true },\n            {\n              content: \" - won't allow drops that don't change position\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-14-5`,\n          type: \"li\",\n          children: [\n            { content: \"🔀 Block swapping\", bold: true },\n            {\n              content: \" - drag any block over another to swap their positions\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `h3-${timestamp}-version-15`,\n      type: \"h3\",\n      content: \"🎨 Improved Image Grid Operations\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-version-16`,\n      type: \"p\",\n      content: \"Working with image grids is now more powerful and intuitive:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-version-17`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-version-17-1`,\n          type: \"li\",\n          children: [\n            { content: \"↔️ Horizontal reordering\", bold: true },\n            { content: \" - drag images left/right within grids\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-17-2`,\n          type: \"li\",\n          children: [\n            { content: \"↕️ Extract vertically\", bold: true },\n            {\n              content: \" - drag images out of grids to make them standalone\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-17-3`,\n          type: \"li\",\n          children: [\n            { content: \"➕ Add to existing grids\", bold: true },\n            {\n              content: \" - drag standalone images into grids to expand them\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-17-4`,\n          type: \"li\",\n          children: [\n            { content: \"🔗 Merge grids\", bold: true },\n            {\n              content:\n                \" - drag images from one grid to another to combine them\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `h3-${timestamp}-version-18`,\n      type: \"h3\",\n      content: \"⚙️ Technical Improvements\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-version-19`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-version-19-1`,\n          type: \"li\",\n          children: [\n            { content: \"🏗️ New structural node types\", bold: true },\n            {\n              content:\n                \" - table, thead, tbody, tr, th, td for proper HTML semantics\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-19-2`,\n          type: \"li\",\n          children: [\n            { content: \"📦 Improved data transfer\", bold: true },\n            {\n              content:\n                \" - all block types now properly communicate during drag operations\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-19-3`,\n          type: \"li\",\n          children: [\n            { content: \"🎯 Better type safety\", bold: true },\n            {\n              content:\n                \" - TypeScript types updated for table structures and multi-select\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-version-19-4`,\n          type: \"li\",\n          children: [\n            { content: \"🧪 Enhanced state management\", bold: true },\n            {\n              content:\n                \" - reducer actions for table updates, column/row reordering\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `code-${timestamp}-version-20`,\n      type: \"code\",\n      content: `// Example: Creating a table programmatically\nconst table: StructuralNode = {\n  id: 'table-1',\n  type: 'table',\n  children: [\n    {\n      id: 'thead-1',\n      type: 'thead',\n      children: [/* header row */]\n    },\n    {\n      id: 'tbody-1',\n      type: 'tbody',\n      children: [/* body rows */]\n    }\n  ]\n};`,\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-version-21a`,\n      type: \"blockquote\",\n      children: [\n        {\n          content: \"💡 Open Source \",\n          bold: true,\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        { content: \" \", italic: true },\n        {\n          content:\n            \"This component is open source and contributions are welcome! \",\n          italic: true,\n        },\n        {\n          content:\n            \"Whether you're fixing bugs, adding features, or improving documentation - your contributions help make this component better for everyone.\",\n          italic: true,\n        },\n      ],\n      attributes: {\n        className:\n          \"bg-gradient-to-r from-blue-50 to-cyan-50 dark:from-blue-900/20 dark:to-cyan-900/20 border-l-4 border-blue-500\",\n      },\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-version-22`,\n      type: \"p\",\n      content: \"---\",\n      attributes: {\n        className: \"text-center text-muted-foreground my-8\",\n      },\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-2`,\n      type: \"p\",\n      children: [\n        { content: \"A powerful \", bold: false },\n        {\n          content: \"block-based rich text editor\",\n          bold: true,\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        { content: \" built with \", bold: false },\n        {\n          content: \"Tailwind CSS\",\n          bold: true,\n          className: \"text-cyan-600 dark:text-cyan-400\",\n        },\n        { content: \" and \", bold: false },\n        {\n          content: \"shadcn/ui\",\n          bold: true,\n          className: \"text-purple-600 dark:text-purple-400\",\n        },\n        { content: \" components.\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-3`,\n      type: \"blockquote\",\n      children: [\n        { content: \"💡 Quick Tip: \", bold: true },\n        { content: \"This entire document is editable! \", italic: true },\n        {\n          content:\n            \"Select any text to format it, drag blocks to reorder them, and press \",\n          italic: true,\n        },\n        { content: \"Shift+Enter\", elementType: \"code\", bold: true },\n        {\n          content: \" to create nested blocks. Have fun exploring!\",\n          italic: true,\n        },\n      ],\n      attributes: {\n        style:\n          \"background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1)); border-left: 4px solid rgb(59, 130, 246);\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // IMPORTANT NOTE\n    // ========================================\n    {\n      id: `blockquote-${timestamp}-9`,\n      type: \"blockquote\",\n      children: [\n        {\n          content: \"💡 Advanced Customization: \",\n          bold: true,\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        { content: \"The editor \", italic: true },\n        { content: \"supports all Tailwind classes\", italic: true, bold: true },\n        {\n          content:\n            \" including gradients, shadows, borders, and custom styles. \",\n          italic: true,\n        },\n        {\n          content:\n            \"You can apply them programmatically through the JSON structure or by using the Custom Class Popover.\",\n          italic: true,\n        },\n      ],\n      attributes: {\n        className: \"bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-600\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // TEXT FORMATTING SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-10`,\n      type: \"h2\",\n      content: \"✨ Text Formatting\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-11`,\n      type: \"p\",\n      content:\n        \"Select any text and use the toolbar to apply rich formatting. The editor supports all standard text styles:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-12`,\n      type: \"p\",\n      children: [\n        { content: \"You can make text \", bold: false },\n        { content: \"bold\", bold: true },\n        { content: \", \", bold: false },\n        { content: \"italic\", italic: true },\n        { content: \", \", bold: false },\n        { content: \"underlined\", underline: true },\n        { content: \", or even \", bold: false },\n        {\n          content: \"combine all three styles\",\n          bold: true,\n          italic: true,\n          underline: true,\n        },\n        {\n          content: \" together! Mix and match to create beautiful content.\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-13`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/images/image_docs/block-bold-italic-underline-color.png\",\n        alt: \"Text formatting toolbar showing bold, italic, underline, and color picker options\",\n        caption:\n          \"🎨 Select text to reveal the formatting toolbar with bold, italic, underline, and color options\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // BLOCK TYPES SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-20`,\n      type: \"h2\",\n      content: \"📋 Block Types\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-21`,\n      type: \"p\",\n      content:\n        \"The editor supports multiple block types. Each block can be changed using the type selector in the toolbar:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h1-${timestamp}-22`,\n      type: \"h1\",\n      content: \"Heading 1 - The largest heading\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h2-${timestamp}-23`,\n      type: \"h2\",\n      content: \"Heading 2 - Major sections\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-24`,\n      type: \"h3\",\n      content: \"Heading 3 - Subsections\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-25`,\n      type: \"p\",\n      content:\n        \"Paragraph - The standard block type for regular text content. Perfect for body text and descriptions.\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-26`,\n      type: \"blockquote\",\n      children: [\n        {\n          content: \"Blockquote - \",\n          italic: true,\n          bold: true,\n        },\n        {\n          content:\n            'Perfect for quotes, tips, and callouts. \"The best way to predict the future is to invent it.\" - Alan Kay',\n          italic: true,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-27`,\n      type: \"code\",\n      content: `// Code Block - For displaying code with proper formatting\nfunction greet(name: string) {\n  return \\`Hello, \\${name}! Welcome to Mina Rich Editor.\\`;\n}\n\nconst message = greet(\"Developer\");\nconsole.log(message);`,\n      attributes: {},\n    } as TextNode,\n\n    // ========================================\n    // LISTS SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-30`,\n      type: \"h2\",\n      content: \"📝 Lists - Ordered & Unordered\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-31`,\n      type: \"p\",\n      content:\n        \"Create ordered lists (numbered) or unordered lists (bullet points) for organized content:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-32`,\n      type: \"h3\",\n      content: \"Ordered List Example (ol)\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-33`,\n      type: \"container\",\n      attributes: {\n        listType: \"ol\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-33-1`,\n          type: \"li\",\n          content: \"First item - Automatically numbered\",\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-33-2`,\n          type: \"li\",\n          content: \"Second item - Numbers increment automatically\",\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-33-3`,\n          type: \"li\",\n          content: \"Third item - Perfect for step-by-step instructions\",\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-33-4`,\n          type: \"li\",\n          children: [\n            { content: \"You can even add \", bold: false },\n            { content: \"formatting\", bold: true },\n            { content: \" to list items!\", italic: true },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `h3-${timestamp}-34`,\n      type: \"h3\",\n      content: \"Unordered List Example (ul)\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-35`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-35-1`,\n          type: \"li\",\n          content: \"Bullet point item\",\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-35-2`,\n          type: \"li\",\n          content: \"Another bullet point\",\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-35-3`,\n          type: \"li\",\n          content: \"Great for feature lists\",\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-35-4`,\n          type: \"li\",\n          children: [\n            { content: \"Supports \", bold: false },\n            {\n              content: \"rich text formatting\",\n              bold: true,\n              className: \"text-blue-600 dark:text-blue-400\",\n            },\n            { content: \" too!\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `code-${timestamp}-36`,\n      type: \"code\",\n      content: `// List structure in the editor\nconst orderedList = {\n  id: 'container-1',\n  type: 'container',\n  attributes: {\n    listType: 'ol'  // 'ol' for ordered, 'ul' for unordered\n  },\n  children: [\n    { id: 'li-1', type: 'li', content: 'First item' },\n    { id: 'li-2', type: 'li', content: 'Second item' },\n    { \n      id: 'li-3',\n      type: 'li',\n      children: [\n        { content: 'Formatted ', bold: false },\n        { content: 'item', bold: true }\n      ]\n    }\n  ]\n};`,\n      attributes: {},\n    } as TextNode,\n\n    // ========================================\n    // INLINE ELEMENT TYPES SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-40`,\n      type: \"h2\",\n      content: \"🎨 Inline Element Types\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-41`,\n      type: \"p\",\n      content:\n        \"Apply heading styles inline within paragraphs. Select text and choose from the element type dropdown to mix different text sizes and styles:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-42`,\n      type: \"p\",\n      children: [\n        { content: \"This paragraph contains \", bold: false },\n        { content: \"H1 styled text\", elementType: \"h1\" },\n        { content: \" and \", bold: false },\n        { content: \"H2 styled text\", elementType: \"h2\" },\n        { content: \" and \", bold: false },\n        { content: \"H3 styled text\", elementType: \"h3\" },\n        { content: \" all mixed together, plus \", bold: false },\n        { content: \"inline code\", elementType: \"code\" },\n        { content: \" support for technical content!\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-43`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/images/image_docs/element-type-select.png\",\n        alt: \"Element type selector dropdown showing options for h1, h2, h3, h4, h5, h6, p, code, and blockquote\",\n        caption:\n          \"📋 Select text and use the element type dropdown to apply heading styles inline\",\n      },\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-44`,\n      type: \"code\",\n      content: `// Inline element types structure\nconst richParagraph = {\n  type: 'p',\n  children: [\n    { content: 'Regular text ' },\n    { content: 'Large heading', elementType: 'h1' },\n    { content: ' and ' },\n    { content: 'inline code', elementType: 'code', bold: true }\n  ]\n};`,\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-45`,\n      type: \"blockquote\",\n      children: [\n        {\n          content: \"🤔 Wait, the block above looks a bit weird, right? \",\n          italic: true,\n        },\n        {\n          content:\n            \"Oh! I wish I could add custom classes using normal Tailwind... \",\n          italic: true,\n          bold: true,\n        },\n        {\n          content: \"Actually, you can! \",\n          italic: true,\n          className: \"text-green-600 dark:text-green-400\",\n        },\n        { content: \"Select your text, then click the \", italic: true },\n        { content: \"pencil ✏️ smart icon\", italic: true, bold: true },\n        {\n          content: \", and type your class or select from preset classes!\",\n          italic: true,\n        },\n      ],\n      attributes: {\n        className:\n          \"bg-gradient-to-r from-amber-50 to-orange-50 dark:from-amber-900/20 dark:to-orange-900/20 border-l-4 border-amber-600\",\n      },\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-46`,\n      type: \"h3\",\n      content: \"✏️ Custom Class Smart Icon\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-47`,\n      type: \"p\",\n      content:\n        \"After selecting text, you'll see a smart pencil icon appear. Click it to access the Custom Class Popover where you can apply any Tailwind CSS class or choose from presets:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-48`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/image_docs/custom-class.png\",\n        alt: \"Pencil icon appearing next to selected text for accessing custom class popover\",\n        caption:\n          \"✏️ The smart pencil icon appears when you select text - click it to customize styles\",\n      },\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-49`,\n      type: \"h3\",\n      content: \"🎨 Custom Class Popover\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-50`,\n      type: \"p\",\n      content:\n        \"The Custom Class Popover gives you complete control over text styling with preset Tailwind classes organized by category:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-51`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/images/image_docs/custom-class-2-popver-opened-state.png\",\n        alt: \"Custom class popover showing text colors, background colors, font sizes, and search functionality\",\n        caption:\n          \"🎨 Custom Class Popover with organized preset classes and search functionality\",\n      },\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-52`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-52-1`,\n          type: \"li\",\n          children: [\n            { content: \"Text Colors\", bold: true },\n            {\n              content: \" - All Tailwind color shades (red, blue, green, etc.)\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-52-2`,\n          type: \"li\",\n          children: [\n            { content: \"Background Colors\", bold: true },\n            { content: \" - Full palette of background colors\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-52-3`,\n          type: \"li\",\n          children: [\n            { content: \"Font Sizes\", bold: true },\n            { content: \" - From xs to 9xl\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-52-4`,\n          type: \"li\",\n          children: [\n            { content: \"Search Functionality\", bold: true },\n            {\n              content: \" - Quick class lookup (e.g., 'text', 'bg', 'flex')\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-52-5`,\n          type: \"li\",\n          children: [\n            { content: \"Custom Input\", bold: true },\n            { content: \" - Type any Tailwind class manually\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    {\n      id: `h3-${timestamp}-53`,\n      type: \"h3\",\n      content: \"✨ Much Better Results!\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-54`,\n      type: \"p\",\n      content:\n        \"With custom classes, you can create stunning text effects and perfect typography:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-55`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/images/image_docs/much-better-result.png\",\n        alt: \"Example of beautifully styled text using custom Tailwind classes with mixed heading styles\",\n        caption:\n          \"✨ Beautiful results with custom Tailwind classes - perfectly styled inline elements\",\n      },\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-56`,\n      type: \"p\",\n      children: [\n        { content: \"Now let's recreate that beautiful text! \", bold: false },\n        { content: \"This paragraph contains \", bold: false },\n        {\n          content: \"H1 styled text\",\n          elementType: \"h1\",\n          className:\n            \"bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent\",\n        },\n        { content: \" and \", bold: false },\n        {\n          content: \"H2 styled text\",\n          elementType: \"h2\",\n          className:\n            \"bg-gradient-to-r from-blue-600 to-cyan-600 bg-clip-text text-transparent\",\n        },\n        { content: \" and \", bold: false },\n        {\n          content: \"H3 styled text\",\n          elementType: \"h3\",\n          className:\n            \"bg-gradient-to-r from-green-600 to-emerald-600 bg-clip-text text-transparent\",\n        },\n        { content: \" all mixed together, plus \", bold: false },\n        {\n          content: \"inline code\",\n          elementType: \"code\",\n          className:\n            \"bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200 px-2 py-1 rounded\",\n        },\n        { content: \" support for technical content!\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-57`,\n      type: \"code\",\n      content: `// Custom classes with inline element types\nconst styledText = {\n  type: 'p',\n  children: [\n    { \n      content: 'Gradient heading',\n      elementType: 'h1',\n      className: 'bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent'\n    },\n    { content: ' and ' },\n    { \n      content: 'custom code',\n      elementType: 'code',\n      className: 'bg-yellow-100 text-yellow-800 px-2 rounded'\n    }\n  ]\n};`,\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-58`,\n      type: \"blockquote\",\n      children: [\n        { content: \"💡 Pro Tip: \", bold: true },\n        { content: \"You can apply \", italic: true },\n        {\n          content: \"any Tailwind class\",\n          italic: true,\n          bold: true,\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        {\n          content:\n            \" including gradients, shadows, borders, spacing, and more! The Custom Class Popover is your gateway to \",\n          italic: true,\n        },\n        {\n          content: \"unlimited styling possibilities\",\n          italic: true,\n          bold: true,\n          className:\n            \"bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent\",\n        },\n        { content: \".\", italic: true },\n      ],\n      attributes: {\n        className: \"bg-blue-50 dark:bg-blue-900/20 border-blue-600\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // COLOR SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-50`,\n      type: \"h2\",\n      content: \"🎨 Color Customization\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-51`,\n      type: \"p\",\n      content:\n        \"The editor includes a powerful color picker with preset colors and custom color selection. Apply colors to any selected text:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-52`,\n      type: \"h3\",\n      content: \"Preset Colors\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-53`,\n      type: \"p\",\n      children: [\n        {\n          content: \"Red \",\n          bold: true,\n          className: \"text-red-600 dark:text-red-400\",\n        },\n        {\n          content: \"Orange \",\n          bold: true,\n          className: \"text-orange-600 dark:text-orange-400\",\n        },\n        {\n          content: \"Amber \",\n          bold: true,\n          className: \"text-amber-600 dark:text-amber-400\",\n        },\n        {\n          content: \"Yellow \",\n          bold: true,\n          className: \"text-yellow-600 dark:text-yellow-400\",\n        },\n        {\n          content: \"Lime \",\n          bold: true,\n          className: \"text-lime-600 dark:text-lime-400\",\n        },\n        {\n          content: \"Green \",\n          bold: true,\n          className: \"text-green-600 dark:text-green-400\",\n        },\n        {\n          content: \"Emerald \",\n          bold: true,\n          className: \"text-emerald-600 dark:text-emerald-400\",\n        },\n        {\n          content: \"Teal \",\n          bold: true,\n          className: \"text-teal-600 dark:text-teal-400\",\n        },\n        {\n          content: \"Cyan \",\n          bold: true,\n          className: \"text-cyan-600 dark:text-cyan-400\",\n        },\n        {\n          content: \"Sky \",\n          bold: true,\n          className: \"text-sky-600 dark:text-sky-400\",\n        },\n        {\n          content: \"Blue \",\n          bold: true,\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        {\n          content: \"Indigo \",\n          bold: true,\n          className: \"text-indigo-600 dark:text-indigo-400\",\n        },\n        {\n          content: \"Violet \",\n          bold: true,\n          className: \"text-violet-600 dark:text-violet-400\",\n        },\n        {\n          content: \"Purple \",\n          bold: true,\n          className: \"text-purple-600 dark:text-purple-400\",\n        },\n        {\n          content: \"Fuchsia \",\n          bold: true,\n          className: \"text-fuchsia-600 dark:text-fuchsia-400\",\n        },\n        {\n          content: \"Pink \",\n          bold: true,\n          className: \"text-pink-600 dark:text-pink-400\",\n        },\n        {\n          content: \"Rose\",\n          bold: true,\n          className: \"text-rose-600 dark:text-rose-400\",\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-54`,\n      type: \"h3\",\n      content: \"Custom Colors\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-55`,\n      type: \"p\",\n      children: [\n        { content: \"You can also use \", bold: false },\n        {\n          content: \"custom hex colors\",\n          bold: true,\n          styles: { color: \"#FF6B6B\" },\n        },\n        { content: \" or \", bold: false },\n        {\n          content: \"RGB values\",\n          bold: true,\n          styles: { color: \"#4ECDC4\" },\n        },\n        { content: \" or even \", bold: false },\n        {\n          content: \"gradient effects\",\n          bold: true,\n          styles: { color: \"#95E1D3\" },\n        },\n        { content: \" by using the color picker!\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-56`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/image_docs/color-picker.png\",\n        alt: \"Color picker popover showing preset Tailwind colors and custom color selector\",\n        caption:\n          \"🎨 Beautiful color picker with preset Tailwind colors and custom color selection\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // FONT SIZE SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-60`,\n      type: \"h2\",\n      content: \"📏 Font Size Control\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-61`,\n      type: \"p\",\n      content:\n        \"Adjust font sizes for any selected text. Choose from preset sizes or enter a custom value:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-62`,\n      type: \"p\",\n      children: [\n        {\n          content: \"Tiny text (12px) \",\n          styles: { fontSize: \"12px\" },\n        },\n        {\n          content: \"Small text (14px) \",\n          styles: { fontSize: \"14px\" },\n        },\n        {\n          content: \"Normal text (16px) \",\n          styles: { fontSize: \"16px\" },\n        },\n        {\n          content: \"Large text (20px) \",\n          bold: true,\n          styles: { fontSize: \"20px\" },\n        },\n        {\n          content: \"Extra Large (24px) \",\n          bold: true,\n          styles: { fontSize: \"24px\" },\n        },\n        {\n          content: \"Huge (32px) \",\n          bold: true,\n          styles: { fontSize: \"32px\" },\n        },\n        {\n          content: \"Massive (48px)\",\n          bold: true,\n          styles: { fontSize: \"48px\" },\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-63`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/image_docs/font-size-controller.png\",\n        alt: \"Font size picker with preset sizes and custom input\",\n        caption:\n          \"📏 Font size controller with preset sizes and custom value input\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // BACKGROUND COLORS SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-70`,\n      type: \"h2\",\n      content: \"🎨 Background Colors\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-71`,\n      type: \"p\",\n      content:\n        \"Apply background colors to entire blocks using preset Tailwind colors or custom colors. Perfect for highlighting important sections:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-72`,\n      type: \"p\",\n      content: \"This block has a blue background!\",\n      attributes: {\n        className: \"bg-blue-100 dark:bg-blue-900/30 p-4 rounded-lg\",\n      },\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-73`,\n      type: \"p\",\n      content: \"This block has a green background with rounded corners!\",\n      attributes: {\n        className: \"bg-green-100 dark:bg-green-900/30 p-4 rounded-lg\",\n      },\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-74`,\n      type: \"p\",\n      content: \"This block has a custom gradient background!\",\n      attributes: {\n        style:\n          \"background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(59, 130, 246, 0.2)); padding: 1rem; border-radius: 0.5rem;\",\n      },\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-75`,\n      type: \"blockquote\",\n      children: [\n        { content: \"💡 Pro Tip: \", bold: true },\n        {\n          content:\n            \"Background colors work with any block type including headings, paragraphs, quotes, and code blocks!\",\n          italic: true,\n        },\n      ],\n      attributes: {\n        className: \"bg-purple-100 dark:bg-purple-900/30 border-purple-600\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // LINKS SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-80`,\n      type: \"h2\",\n      content: \"🔗 Link Support\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-81`,\n      type: \"p\",\n      content:\n        \"Create beautiful, clickable links with the modern link popover. Select text and add a URL to make it interactive:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-82`,\n      type: \"p\",\n      children: [\n        { content: \"Visit \", bold: false },\n        {\n          content: \"shadcn/ui\",\n          bold: true,\n          underline: true,\n          href: \"https://ui-v4-livid.vercel.app/\",\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        { content: \" for more components, or check out the \", bold: false },\n        {\n          content: \"documentation\",\n          bold: true,\n          underline: true,\n          href: \"https://ui-v4-livid.vercel.app/docs\",\n          className: \"text-purple-600 dark:text-purple-400\",\n        },\n        { content: \" to learn more!\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-83`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/image_docs/modern-link-popover.png\",\n        alt: \"Modern link popover with URL input and save button\",\n        caption: \"🔗 Modern link popover for adding and editing URLs\",\n      },\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-84`,\n      type: \"p\",\n      children: [\n        { content: \"Useful Links: \", bold: true },\n        {\n          content: \"Components\",\n          href: \"https://ui-v4-livid.vercel.app/docs/components\",\n          underline: true,\n          className: \"text-gray-800 dark:text-gray-200\",\n        },\n        { content: \" • \", bold: false },\n        {\n          content: \"Examples\",\n          href: \"https://ui-v4-livid.vercel.app/examples\",\n          underline: true,\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        { content: \" • \", bold: false },\n        {\n          content: \"Themes\",\n          href: \"https://ui-v4-livid.vercel.app/themes\",\n          underline: true,\n          className: \"text-purple-600 dark:text-purple-400\",\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    // ========================================\n    // IMAGES SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-90`,\n      type: \"h2\",\n      content: \"🖼️ Image Support\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-91`,\n      type: \"p\",\n      content:\n        \"Upload and manage images with ease. The editor supports single images, grid layouts, and drag-and-drop reordering:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-92`,\n      type: \"h3\",\n      content: \"Single Image\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-93`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/images/image_docs/preview-export-code.png\",\n        alt: \"Preview of HTML export feature with formatted code\",\n        caption: \"📤 Example of the HTML export preview feature\",\n      },\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-94`,\n      type: \"h3\",\n      content: \"Image Grid Layout\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-95`,\n      type: \"p\",\n      content:\n        \"Create beautiful image galleries with automatic grid layout. Drag and drop images to reorder them:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-96`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/images/image_docs/image-grid.png\",\n        alt: \"Image grid layout showing multiple images in a responsive grid\",\n        caption: \"📸 Image grid with drag-and-drop reordering support\",\n      },\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-97`,\n      type: \"blockquote\",\n      children: [\n        { content: \"💡 Image Features: \", bold: true },\n        {\n          content:\n            \"Drag to reorder • Click to upload • Add captions • Responsive grid layout • Support for multiple formats (jpg, png, gif, webp)\",\n          italic: true,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    // ========================================\n    // NESTED BLOCKS SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-100`,\n      type: \"h2\",\n      content: \"🪆 Nested Blocks\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-101`,\n      type: \"p\",\n      children: [\n        { content: \"Press \", bold: false },\n        { content: \"Shift+Enter\", elementType: \"code\", bold: true },\n        {\n          content:\n            \" to create nested blocks. Maximum nesting level is 1. Great for grouping related content together:\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-102`,\n      type: \"container\",\n      children: [\n        {\n          id: `p-${timestamp}-103`,\n          type: \"p\",\n          children: [\n            { content: \"📦 This is a \", bold: false },\n            {\n              content: \"nested container\",\n              bold: true,\n              className: \"text-blue-600 dark:text-blue-400\",\n            },\n            {\n              content:\n                \"! It groups related content together and can contain any block type.\",\n              bold: false,\n            },\n          ],\n          attributes: {\n            className: \"bg-blue-50 dark:bg-blue-900/20 p-3 rounded\",\n          },\n        } as TextNode,\n\n        {\n          id: `p-${timestamp}-104`,\n          type: \"p\",\n          content:\n            \"Each nested block maintains its own formatting, type, and attributes. You can have paragraphs, headings, code, lists, and more!\",\n          attributes: {},\n        } as TextNode,\n\n        {\n          id: `code-${timestamp}-105`,\n          type: \"code\",\n          content: `// Code blocks work perfectly in nested containers\nconst nestedBlock = {\n  type: 'container',\n  children: [\n    { type: 'p', content: 'First nested item' },\n    { type: 'code', content: 'const x = 1;' },\n    { type: 'blockquote', content: 'Quote in nest' }\n  ]\n};`,\n          attributes: {},\n        } as TextNode,\n\n        {\n          id: `blockquote-${timestamp}-106`,\n          type: \"blockquote\",\n          children: [\n            {\n              content: \"Even blockquotes work in nested containers! \",\n              italic: true,\n            },\n            {\n              content: \"Perfect for organizing complex content hierarchically.\",\n              italic: true,\n              bold: true,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n\n        {\n          id: `container-${timestamp}-107`,\n          type: \"container\",\n          attributes: {\n            listType: \"ul\",\n          },\n          children: [\n            {\n              id: `li-${timestamp}-107-1`,\n              type: \"li\",\n              content: \"Nested lists are supported\",\n              attributes: {},\n            } as TextNode,\n            {\n              id: `li-${timestamp}-107-2`,\n              type: \"li\",\n              content: \"Drag handles work in nested blocks too\",\n              attributes: {},\n            } as TextNode,\n            {\n              id: `li-${timestamp}-107-3`,\n              type: \"li\",\n              content: \"All formatting features available\",\n              attributes: {},\n            } as TextNode,\n          ],\n        } as ContainerNode,\n      ],\n      attributes: {\n        style:\n          \"border: 2px dashed rgba(59, 130, 246, 0.3); padding: 1rem; border-radius: 0.5rem; background: rgba(59, 130, 246, 0.05);\",\n      },\n    } as ContainerNode,\n\n    // ========================================\n    // DRAG & DROP SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-110`,\n      type: \"h2\",\n      content: \"🎯 Drag & Drop\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-111`,\n      type: \"p\",\n      content:\n        \"Every block has a drag handle (⋮⋮). Click and drag to reorder blocks, swap images in grids, or reorganize your entire document:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-112`,\n      type: \"p\",\n      content: \"🎪 Try dragging this block!\",\n      attributes: {\n        className:\n          \"bg-gradient-to-r from-purple-100 to-pink-100 dark:from-purple-900/30 dark:to-pink-900/30 p-4 rounded-lg\",\n      },\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-113`,\n      type: \"p\",\n      content: \"🎨 Or drag this one!\",\n      attributes: {\n        className:\n          \"bg-gradient-to-r from-blue-100 to-cyan-100 dark:from-blue-900/30 dark:to-cyan-900/30 p-4 rounded-lg\",\n      },\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-114`,\n      type: \"p\",\n      content: \"🚀 Drag and drop works everywhere!\",\n      attributes: {\n        className:\n          \"bg-gradient-to-r from-green-100 to-emerald-100 dark:from-green-900/30 dark:to-emerald-900/30 p-4 rounded-lg\",\n      },\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-115`,\n      type: \"blockquote\",\n      children: [\n        { content: \"💡 Drag & Drop Features: \", bold: true },\n        {\n          content:\n            \"Reorder any block • Swap images in grids • Move blocks in and out of containers • Visual feedback during drag • Auto-scroll support\",\n          italic: true,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    // ========================================\n    // CUSTOM CLASSES SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-120`,\n      type: \"h2\",\n      content: \"✨ Custom Tailwind Classes\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-121`,\n      type: \"p\",\n      content:\n        \"Apply any Tailwind CSS class to your text. This is where the editor truly shines - unlimited customization with the full power of Tailwind:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-122`,\n      type: \"p\",\n      children: [\n        { content: \"Add \", bold: false },\n        {\n          content: \"gradients\",\n          bold: true,\n          className:\n            \"bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent\",\n        },\n        { content: \", \", bold: false },\n        {\n          content: \"shadows\",\n          bold: true,\n          className: \"drop-shadow-lg text-blue-600\",\n        },\n        { content: \", \", bold: false },\n        {\n          content: \"borders\",\n          bold: true,\n          className: \"border-2 border-green-600 px-2 rounded\",\n        },\n        { content: \", \", bold: false },\n        {\n          content: \"backgrounds\",\n          bold: true,\n          className: \"bg-yellow-200 dark:bg-yellow-800 px-2 py-1 rounded\",\n        },\n        { content: \", and \", bold: false },\n        {\n          content: \"any Tailwind class\",\n          bold: true,\n          className: \"ring-2 ring-purple-600 ring-offset-2 px-2 rounded\",\n        },\n        { content: \"!\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-123`,\n      type: \"code\",\n      content: `// Custom classes in the data structure\nconst styledText = {\n  content: 'Gradient text',\n  bold: true,\n  className: 'bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent'\n};`,\n      attributes: {},\n    } as TextNode,\n\n    // ========================================\n    // EXPORT SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-130`,\n      type: \"h2\",\n      content: \"📤 HTML Export\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-131`,\n      type: \"p\",\n      content:\n        \"Export your entire document to clean, semantic HTML with all Tailwind classes preserved. Perfect for blogs, documentation, and content management:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-132`,\n      type: \"code\",\n      content: `import { serializeToHtml } from '@/lib/utils/serialize-to-html';\nimport { useEditor } from '@/lib';\n\nfunction MyComponent() {\n  const { state } = useEditor();\n  \n  // Export to HTML\n  const html = serializeToHtml(state.history[state.historyIndex]);\n  \n  // Returns formatted HTML like:\n  // <h1>Title</h1>\n  // <p>This is <strong>bold</strong> and <em>italic</em> text.</p>\n  // <div class=\"bg-blue-100 p-4\">Custom styled block</div>\n  \n  return <div dangerouslySetInnerHTML={{ __html: html }} />;\n}`,\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `img-${timestamp}-133`,\n      type: \"img\",\n      content: \"\",\n      attributes: {\n        src: \"/images/image_docs/preview-export-code.png\",\n        alt: \"HTML export preview showing formatted code output\",\n        caption: \"📤 Preview and copy HTML export code with one click\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // KEYBOARD SHORTCUTS SECTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-140`,\n      type: \"h2\",\n      content: \"⌨️ Keyboard Shortcuts\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-141`,\n      type: \"p\",\n      content:\n        \"Master these keyboard shortcuts for a blazing-fast editing experience:\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-142`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-142-1`,\n          type: \"li\",\n          children: [\n            { content: \"Enter\", elementType: \"code\", bold: true },\n            { content: \" - Create new block after current one\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-142-2`,\n          type: \"li\",\n          children: [\n            { content: \"Shift + Enter\", elementType: \"code\", bold: true },\n            {\n              content: \" - Create nested block or add to existing container\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-142-3`,\n          type: \"li\",\n          children: [\n            { content: \"Ctrl/Cmd + A\", elementType: \"code\", bold: true },\n            { content: \" - Select all content for copying\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-142-4`,\n          type: \"li\",\n          children: [\n            { content: \"Backspace/Delete\", elementType: \"code\", bold: true },\n            { content: \" - Delete current block (when empty)\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-142-5`,\n          type: \"li\",\n          children: [\n            { content: \"Ctrl/Cmd + B\", elementType: \"code\", bold: true },\n            {\n              content: \" - Toggle bold formatting on selected text\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-142-6`,\n          type: \"li\",\n          children: [\n            { content: \"Ctrl/Cmd + I\", elementType: \"code\", bold: true },\n            {\n              content: \" - Toggle italic formatting on selected text\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-142-7`,\n          type: \"li\",\n          children: [\n            { content: \"Ctrl/Cmd + U\", elementType: \"code\", bold: true },\n            {\n              content: \" - Toggle underline formatting on selected text\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-142-8`,\n          type: \"li\",\n          children: [\n            { content: \"Ctrl/Cmd + Z\", elementType: \"code\", bold: true },\n            { content: \" - Undo last action\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-142-9`,\n          type: \"li\",\n          children: [\n            {\n              content: \"Ctrl/Cmd + Shift + Z\",\n              elementType: \"code\",\n              bold: true,\n            },\n            { content: \" - Redo last undone action\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    // ========================================\n    // KEY FEATURES SUMMARY\n    // ========================================\n    {\n      id: `h2-${timestamp}-150`,\n      type: \"h2\",\n      content: \"🎯 Complete Feature List\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-151`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-151-1`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Block-Based Architecture\", bold: true },\n            {\n              content: \" - Each element is an independent, draggable block\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-2`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Rich Text Formatting\", bold: true },\n            {\n              content: \" - Bold, italic, underline, and combinations\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-3`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Multiple Block Types\", bold: true },\n            {\n              content: \" - h1-h6, paragraph, code, blockquote, lists (ol/ul)\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-4`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Inline Element Types\", bold: true },\n            { content: \" - Mix heading styles within paragraphs\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-5`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Color Support\", bold: true },\n            {\n              content: \" - Preset Tailwind colors + custom hex/RGB colors\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-6`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Font Size Control\", bold: true },\n            { content: \" - Preset sizes + custom pixel values\", bold: false },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-7`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Background Colors\", bold: true },\n            {\n              content:\n                \" - Apply backgrounds to any block with presets or custom colors\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-8`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Link Support\", bold: true },\n            {\n              content: \" - Beautiful link popover with URL management\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-9`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Image Upload\", bold: true },\n            {\n              content: \" - Single images and grid layouts with drag-to-reorder\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-10`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Nested Blocks\", bold: true },\n            {\n              content: \" - Create containers for organizing related content\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-11`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Drag & Drop\", bold: true },\n            {\n              content: \" - Reorder blocks, swap images, reorganize everything\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-12`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Custom Tailwind Classes\", bold: true },\n            {\n              content:\n                \" - Unlimited styling possibilities with full Tailwind support\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-13`,\n          type: \"li\",\n          children: [\n            { content: \"✅ HTML Export\", bold: true },\n            {\n              content: \" - Clean, semantic HTML with preserved styling\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-14`,\n          type: \"li\",\n          children: [\n            { content: \"✅ TypeScript-First\", bold: true },\n            {\n              content: \" - Fully typed API with excellent IntelliSense\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-15`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Immutable State\", bold: true },\n            {\n              content: \" - Built with reducers for predictable updates\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-16`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Undo/Redo\", bold: true },\n            {\n              content: \" - Full history management for all actions\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-17`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Read-Only Mode\", bold: true },\n            {\n              content: \" - Perfect for displaying published content\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-18`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Dark Mode\", bold: true },\n            {\n              content: \" - Beautiful themes that work everywhere\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-19`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Keyboard Shortcuts\", bold: true },\n            {\n              content: \" - Efficient editing with common shortcuts\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-151-20`,\n          type: \"li\",\n          children: [\n            { content: \"✅ Context Menu\", bold: true },\n            {\n              content:\n                \" - Right-click for quick actions (duplicate, delete, move)\",\n              bold: false,\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    // ========================================\n    // INSTALLATION & USAGE\n    // ========================================\n    {\n      id: `h2-${timestamp}-160`,\n      type: \"h2\",\n      content: \"🚀 Quick Start\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-161`,\n      type: \"h3\",\n      content: \"Installation\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-162`,\n      type: \"code\",\n      content: `\n# Clone the repository      \ngit clone https://github.com/Mina-Massoud/mina-rich-editor.git\n\n# Install and run\nnpm install\nnpm run dev`,\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-163`,\n      type: \"h3\",\n      content: \"Basic Usage\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-164`,\n      type: \"code\",\n      content: `import { EditorProvider } from '@/lib';\nimport { SimpleEditor } from '@/components/SimpleEditor';\n\nexport default function App() {\n  return (\n    <EditorProvider>\n      <SimpleEditor />\n    </EditorProvider>\n  );\n}`,\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-165`,\n      type: \"h3\",\n      content: \"Read-Only Mode\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-166`,\n      type: \"code\",\n      content: `// Display content without editing\n<SimpleEditor readOnly={true} />`,\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-167`,\n      type: \"h3\",\n      content: \"With Initial Content\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `code-${timestamp}-168`,\n      type: \"code\",\n      content: `import { createDemoContent } from '@/lib/demo-content';\n\nconst initialContent = {\n  id: 'root',\n  type: 'container',\n  children: createDemoContent(),\n  attributes: {}\n};\n\n<EditorProvider initialContainer={initialContent}>\n  <SimpleEditor />\n</EditorProvider>`,\n      attributes: {},\n    } as TextNode,\n\n    // ========================================\n    // LEARN MORE\n    // ========================================\n    {\n      id: `h2-${timestamp}-180`,\n      type: \"h2\",\n      content: \"📚 Learn More\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-181`,\n      type: \"p\",\n      children: [\n        { content: \"This rich editor component is part of \", bold: false },\n        {\n          content: \"shadcn/ui\",\n          bold: true,\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        {\n          content:\n            \" - a collection of beautifully designed, accessible components built with Radix UI and Tailwind CSS.\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `h3-${timestamp}-183`,\n      type: \"h3\",\n      content: \"Useful Resources\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `container-${timestamp}-184`,\n      type: \"container\",\n      attributes: {\n        listType: \"ul\",\n      },\n      children: [\n        {\n          id: `li-${timestamp}-184-1`,\n          type: \"li\",\n          children: [\n            { content: \"📖 Documentation: \", bold: false },\n            {\n              content: \"ui-v4-livid.vercel.app\",\n              bold: true,\n              underline: true,\n              href: \"https://ui-v4-livid.vercel.app/\",\n              className: \"text-blue-600 dark:text-blue-400\",\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-184-2`,\n          type: \"li\",\n          children: [\n            { content: \"💻 GitHub: \", bold: false },\n            {\n              content: \"github.com/shadcn-ui/ui\",\n              bold: true,\n              underline: true,\n              href: \"https://github.com/shadcn-ui/ui\",\n              className: \"text-blue-600 dark:text-blue-400\",\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-184-3`,\n          type: \"li\",\n          children: [\n            { content: \"🎨 Themes: \", bold: false },\n            {\n              content: \"ui-v4-livid.vercel.app/themes\",\n              bold: true,\n              underline: true,\n              href: \"https://ui-v4-livid.vercel.app/themes\",\n              className: \"text-blue-600 dark:text-blue-400\",\n            },\n          ],\n          attributes: {},\n        } as TextNode,\n      ],\n    } as ContainerNode,\n\n    // ========================================\n    // CALL TO ACTION\n    // ========================================\n    {\n      id: `h2-${timestamp}-200`,\n      type: \"h2\",\n      content: \"🎨 Start Creating!\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-201`,\n      type: \"p\",\n      children: [\n        { content: \"👉 \", bold: false },\n        {\n          content: \"Select any text\",\n          bold: true,\n          className: \"text-blue-600 dark:text-blue-400\",\n        },\n        {\n          content:\n            \" and use the toolbar to format it with bold, italic, colors, fonts, and more\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-202`,\n      type: \"p\",\n      children: [\n        { content: \"👉 Press \", bold: false },\n        { content: \"Enter\", elementType: \"code\" },\n        { content: \" to create new blocks at any time\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-203`,\n      type: \"p\",\n      children: [\n        { content: \"👉 Press \", bold: false },\n        { content: \"Shift+Enter\", elementType: \"code\" },\n        { content: \" for nested blocks and hierarchical content\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-204`,\n      type: \"p\",\n      children: [\n        { content: \"👉 Use the \", bold: false },\n        { content: \"drag handles (⋮⋮)\", bold: true },\n        {\n          content: \" to reorder blocks and reorganize your document\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-205`,\n      type: \"p\",\n      children: [\n        { content: \"👉 Toggle \", bold: false },\n        { content: \"View Only\", bold: true },\n        {\n          content: \" mode in the top-right to see the read-only version\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-206`,\n      type: \"p\",\n      children: [\n        { content: \"👉 Switch to \", bold: false },\n        { content: \"Dark Mode\", bold: true },\n        {\n          content: \" using the theme toggle for a different experience\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-207`,\n      type: \"p\",\n      children: [\n        { content: \"👉 Check the \", bold: false },\n        { content: \"debug panel below\", bold: true },\n        { content: \" to see JSON structure and export HTML\", bold: false },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-208`,\n      type: \"blockquote\",\n      children: [\n        { content: \"🚀 Pro Tip: \", bold: true },\n        {\n          content: \"This is your living documentation! \",\n          italic: true,\n        },\n        {\n          content:\n            \"Feel free to edit, experiment, delete sections, add your own content, and explore all features. \",\n          italic: true,\n        },\n        {\n          content:\n            \"The editor is designed to be intuitive and powerful - discover features as you use it!\",\n          italic: true,\n          bold: true,\n        },\n      ],\n      attributes: {\n        className:\n          \"bg-gradient-to-r from-green-100 to-emerald-100 dark:from-green-900/30 dark:to-emerald-900/30 border-l-4 border-green-600\",\n      },\n    } as TextNode,\n\n    // ========================================\n    // CLOSING\n    // ========================================\n    {\n      id: `h2-${timestamp}-210`,\n      type: \"h2\",\n      content: \"🎉 Get Started\",\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `p-${timestamp}-211`,\n      type: \"p\",\n      children: [\n        { content: \"Thank you for exploring the \", bold: false },\n        {\n          content: \"Rich Text Editor\",\n          bold: true,\n          className: \"text-purple-600 dark:text-purple-400\",\n        },\n        { content: \"! This component is built entirely with \", bold: false },\n        {\n          content: \"Tailwind CSS\",\n          bold: true,\n          className: \"text-cyan-600 dark:text-cyan-400\",\n        },\n        { content: \" and \", bold: false },\n        {\n          content: \"shadcn/ui\",\n          bold: true,\n          className: \"text-purple-600 dark:text-purple-400\",\n        },\n        {\n          content:\n            \", making it fully customizable and easy to integrate into your project.\",\n          bold: false,\n        },\n      ],\n      attributes: {},\n    } as TextNode,\n\n    {\n      id: `blockquote-${timestamp}-213`,\n      type: \"blockquote\",\n      children: [\n        { content: \"Ready to use this component? \", italic: true },\n        {\n          content: \"Copy the code and customize it to fit your needs. \",\n          bold: true,\n          italic: true,\n        },\n        {\n          content:\n            \"All components are designed to be flexible and developer-friendly.\",\n          italic: true,\n        },\n      ],\n      attributes: {\n        style:\n          \"background: linear-gradient(135deg, rgba(147, 51, 234, 0.1), rgba(236, 72, 153, 0.1)); border-left: 4px solid rgb(147, 51, 234); text-align: center;\",\n      },\n    } as TextNode,\n  ]\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/context/editor-context.tsx",
      "content": "/**\n * Mina Rich Editor - Context Provider\n *\n * React context provider for managing editor state using useReducer.\n * Provides state and dispatch to all child components.\n *\n * @packageDocumentation\n */\n\n\"use client\"\n\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n} from \"react\"\n\nimport { EditorAction } from \"../reducer/actions\"\nimport { createInitialState, editorReducer } from \"../reducer/editor-reducer\"\nimport { ContainerNode, EditorState, SelectionInfo } from \"../types\"\n\n/**\n * Context for the editor state (read-only).\n */\nconst EditorStateContext = createContext<EditorState | undefined>(undefined)\n\n/**\n * Context for the dispatch function (write operations).\n */\nconst EditorDispatchContext = createContext<\n  React.Dispatch<EditorAction> | undefined\n>(undefined)\n\n/**\n * Interface for selection manager that doesn't cause re-renders\n */\ninterface SelectionManager {\n  /** Get current selection info without triggering re-render */\n  getSelection: () => SelectionInfo | null\n  /** Set selection info without triggering re-render */\n  setSelection: (selection: SelectionInfo | null) => void\n  /** Subscribe to selection changes (for toolbar updates only) */\n  subscribe: (callback: (selection: SelectionInfo | null) => void) => () => void\n}\n\n/**\n * Context for selection management (optimized to avoid re-renders)\n */\nconst SelectionContext = createContext<SelectionManager | undefined>(undefined)\n\n/**\n * Props for the EditorProvider component.\n */\nexport interface EditorProviderProps {\n  /** Child components that will have access to the editor context */\n  children: React.ReactNode\n\n  /** Initial container to populate the editor with */\n  initialContainer?: ContainerNode\n\n  /** Complete initial state (overrides initialContainer if provided) */\n  initialState?: EditorState\n\n  /** Callback fired whenever the state changes */\n  onChange?: (state: EditorState) => void\n\n  /** Enable debug logging for state changes */\n  debug?: boolean\n}\n\n/**\n * EditorProvider component.\n * Wraps your application/components to provide editor state and dispatch.\n *\n * @example\n * ```tsx\n * function App() {\n *   return (\n *     <EditorProvider initialContainer={myDocument} onChange={handleChange}>\n *       <EditorToolbar />\n *       <EditorCanvas />\n *     </EditorProvider>\n *   );\n * }\n * ```\n *\n * @example\n * ```tsx\n * // With debug mode\n * <EditorProvider debug onChange={(state) => console.log('State:', state)}>\n *   <MyEditor />\n * </EditorProvider>\n * ```\n */\nexport function EditorProvider({\n  children,\n  initialContainer,\n  initialState,\n  onChange,\n  debug = false,\n}: EditorProviderProps) {\n  // Use useRef to ensure initialEditorState is only computed once\n  // This prevents createInitialState from being called on every render\n  const initialEditorStateRef = React.useRef<EditorState | null>(null)\n\n  if (initialEditorStateRef.current === null) {\n    initialEditorStateRef.current =\n      initialState || createInitialState(initialContainer)\n  }\n\n  const initialEditorState = initialEditorStateRef.current\n\n  // Set up reducer with useReducer\n  const [state, dispatch] = useReducer(editorReducer, initialEditorState)\n\n  // Create selection manager (doesn't cause re-renders)\n  const selectionRef = useRef<SelectionInfo | null>(null)\n  const selectionSubscribers = useRef<\n    Set<(selection: SelectionInfo | null) => void>\n  >(new Set())\n\n  const selectionManager = useMemo<SelectionManager>(\n    () => ({\n      getSelection: () => selectionRef.current,\n      setSelection: (selection: SelectionInfo | null) => {\n        selectionRef.current = selection\n        // Notify subscribers (e.g., toolbar) but don't trigger full re-render\n        selectionSubscribers.current.forEach((callback) => callback(selection))\n      },\n      subscribe: (callback: (selection: SelectionInfo | null) => void) => {\n        selectionSubscribers.current.add(callback)\n        return () => {\n          selectionSubscribers.current.delete(callback)\n        }\n      },\n    }),\n    []\n  )\n\n  // Create wrapped dispatch that includes onChange and debug logging\n  const enhancedDispatch = useMemo(() => {\n    return (action: EditorAction) => {\n      if (debug) {\n        console.group(`🎬 [Mina Editor] Action: ${action.type}`)\n        if (\"payload\" in action) {\n        }\n        const currentContainer = state.history[state.historyIndex]\n      }\n\n      // Dispatch the action\n      dispatch(action)\n\n      // Note: The new state will be available on the next render\n      // If we need the new state immediately, we'd need to use a ref or middleware\n\n      if (debug) {\n        console.groupEnd()\n      }\n    }\n  }, [dispatch, debug, state])\n\n  // Call onChange when state changes\n  React.useEffect(() => {\n    if (onChange) {\n      onChange(state)\n    }\n  }, [state, onChange])\n\n  return (\n    <EditorStateContext.Provider value={state}>\n      <EditorDispatchContext.Provider value={enhancedDispatch}>\n        <SelectionContext.Provider value={selectionManager}>\n          {children}\n        </SelectionContext.Provider>\n      </EditorDispatchContext.Provider>\n    </EditorStateContext.Provider>\n  )\n}\n\n/**\n * Hook to access the current editor state.\n * Must be used within an EditorProvider.\n *\n * @returns Current editor state\n * @throws Error if used outside of EditorProvider\n *\n * @example\n * ```tsx\n * function EditorStatus() {\n *   const state = useEditorState();\n *   return <div>Version: {state.version}</div>;\n * }\n * ```\n */\nexport function useEditorState(): EditorState {\n  const context = useContext(EditorStateContext)\n\n  if (context === undefined) {\n    throw new Error(\n      \"useEditorState must be used within an EditorProvider. \" +\n        \"Wrap your component tree with <EditorProvider>.\"\n    )\n  }\n\n  return context\n}\n\n/**\n * Hook to access the dispatch function for updating editor state.\n * Must be used within an EditorProvider.\n *\n * @returns Dispatch function to send actions\n * @throws Error if used outside of EditorProvider\n *\n * @example\n * ```tsx\n * function DeleteButton({ nodeId }: { nodeId: string }) {\n *   const dispatch = useEditorDispatch();\n *\n *   return (\n *     <button onClick={() => dispatch({\n *       type: 'DELETE_NODE',\n *       payload: { id: nodeId }\n *     })}>\n *       Delete\n *     </button>\n *   );\n * }\n * ```\n */\nexport function useEditorDispatch(): React.Dispatch<EditorAction> {\n  const context = useContext(EditorDispatchContext)\n\n  if (context === undefined) {\n    throw new Error(\n      \"useEditorDispatch must be used within an EditorProvider. \" +\n        \"Wrap your component tree with <EditorProvider>.\"\n    )\n  }\n\n  return context\n}\n\n/**\n * Convenience hook that returns both state and dispatch.\n * Equivalent to calling useEditorState() and useEditorDispatch() separately.\n *\n * @returns Tuple of [state, dispatch]\n * @throws Error if used outside of EditorProvider\n *\n * @example\n * ```tsx\n * function EditorControls() {\n *   const [state, dispatch] = useEditor();\n *   const container = state.history[state.historyIndex];\n *\n *   const addParagraph = () => {\n *     dispatch({\n *       type: 'INSERT_NODE',\n *       payload: {\n *         node: { id: 'p-new', type: 'p', content: 'New paragraph' },\n *         targetId: container.id,\n *         position: 'append'\n *       }\n *     });\n *   };\n *\n *   return <button onClick={addParagraph}>Add Paragraph</button>;\n * }\n * ```\n */\nexport function useEditor(): [EditorState, React.Dispatch<EditorAction>] {\n  return [useEditorState(), useEditorDispatch()]\n}\n\n/**\n * Hook to select a specific part of the editor state.\n * Helps optimize re-renders by only subscribing to the data you need.\n *\n * @param selector - Function to select data from state\n * @returns Selected data\n *\n * @example\n * ```tsx\n * function NodeCounter() {\n *   const nodeCount = useEditorSelector((state) => {\n *     const container = state.history[state.historyIndex];\n *     let count = 0;\n *     traverseTree(container, () => count++);\n *     return count;\n *   });\n *\n *   return <div>Total nodes: {nodeCount}</div>;\n * }\n * ```\n */\nexport function useEditorSelector<T>(selector: (state: EditorState) => T): T {\n  const state = useEditorState()\n  return useMemo(() => selector(state), [selector, state])\n}\n\n/**\n * Hook to get a specific node by ID.\n * Returns undefined if node is not found.\n *\n * @param nodeId - The ID of the node to find\n * @returns The node or undefined\n *\n * @example\n * ```tsx\n * function NodeEditor({ nodeId }: { nodeId: string }) {\n *   const node = useNode(nodeId);\n *\n *   if (!node) {\n *     return <div>Node not found</div>;\n *   }\n *\n *   return <div>{node.type}: {isTextNode(node) ? node.content : 'Container'}</div>;\n * }\n * ```\n */\nexport function useNode(nodeId: string) {\n  const state = useEditorState()\n\n  return useMemo(() => {\n    const { findNodeById } = require(\"../utils/tree-operations\")\n    const currentContainer = state.history[state.historyIndex]\n    return findNodeById(currentContainer, nodeId)\n  }, [state.history, state.historyIndex, nodeId])\n}\n\n/**\n * Hook to access the selection manager.\n * This provides optimized selection tracking that doesn't cause re-renders.\n *\n * @returns Selection manager\n * @throws Error if used outside of EditorProvider\n *\n * @example\n * ```tsx\n * function MyEditor() {\n *   const selectionManager = useSelectionManager();\n *\n *   // Get selection without causing re-render\n *   const selection = selectionManager.getSelection();\n *\n *   // Update selection without causing re-render\n *   selectionManager.setSelection(newSelection);\n * }\n * ```\n */\nexport function useSelectionManager(): SelectionManager {\n  const context = useContext(SelectionContext)\n\n  if (context === undefined) {\n    throw new Error(\n      \"useSelectionManager must be used within an EditorProvider. \" +\n        \"Wrap your component tree with <EditorProvider>.\"\n    )\n  }\n\n  return context\n}\n\n/**\n * Hook to subscribe to selection changes (for toolbar/UI updates).\n * Only components that need to react to selection changes should use this.\n *\n * @returns Current selection info (reactive - causes re-renders on change)\n *\n * @example\n * ```tsx\n * function FormattingToolbar() {\n *   const selection = useSelection();\n *\n *   if (!selection) return null;\n *\n *   return (\n *     <div>\n *       Selected: {selection.text}\n *       Bold: {selection.formats.bold ? 'Yes' : 'No'}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useSelection(): SelectionInfo | null {\n  const selectionManager = useSelectionManager()\n  const [selection, setSelection] = React.useState<SelectionInfo | null>(\n    selectionManager.getSelection()\n  )\n\n  React.useEffect(() => {\n    const unsubscribe = selectionManager.subscribe(setSelection)\n    return unsubscribe\n  }, [selectionManager])\n\n  return selection\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/reducer/actions.ts",
      "content": "/**\n * Mina Rich Editor - Action Types\n *\n * Defines all possible actions that can be dispatched to modify the editor state.\n * Follows Redux-style action pattern for predictability and debugging.\n *\n * @packageDocumentation\n */\n\nimport {\n  ContainerNode,\n  EditorNode,\n  EditorState,\n  NodeAttributes,\n  SelectionInfo,\n} from \"../types\"\nimport { InsertPosition } from \"../utils/tree-operations\"\n\n/**\n * Updates a node's properties by ID.\n * Performs a shallow merge of the provided updates.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'UPDATE_NODE',\n *   payload: {\n *     id: 'p-1',\n *     updates: {\n *       content: 'New content',\n *       attributes: { className: 'text-blue-500' }\n *     }\n *   }\n * });\n * ```\n */\nexport interface UpdateNodeAction {\n  type: \"UPDATE_NODE\"\n  payload: {\n    id: string\n    updates: Partial<EditorNode>\n  }\n}\n\n/**\n * Updates only the attributes of a node.\n * More convenient than UPDATE_NODE when only changing attributes.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'UPDATE_ATTRIBUTES',\n *   payload: {\n *     id: 'img-1',\n *     attributes: { src: 'new-image.jpg', alt: 'Updated image' }\n *   }\n * });\n * ```\n */\nexport interface UpdateAttributesAction {\n  type: \"UPDATE_ATTRIBUTES\"\n  payload: {\n    id: string\n    attributes: NodeAttributes\n    merge?: boolean // If true, merges with existing attributes; if false, replaces them\n  }\n}\n\n/**\n * Updates the text content of a node.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'UPDATE_CONTENT',\n *   payload: {\n *     id: 'p-1',\n *     content: 'Updated paragraph text'\n *   }\n * });\n * ```\n */\nexport interface UpdateContentAction {\n  type: \"UPDATE_CONTENT\"\n  payload: {\n    id: string\n    content: string\n  }\n}\n\n/**\n * Deletes a node by ID.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'DELETE_NODE',\n *   payload: { id: 'p-2' }\n * });\n * ```\n */\nexport interface DeleteNodeAction {\n  type: \"DELETE_NODE\"\n  payload: {\n    id: string\n  }\n}\n\n/**\n * Inserts a new node relative to a target node.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'INSERT_NODE',\n *   payload: {\n *     node: { id: 'p-new', type: 'p', content: 'New paragraph' },\n *     targetId: 'p-1',\n *     position: 'after'\n *   }\n * });\n * ```\n */\nexport interface InsertNodeAction {\n  type: \"INSERT_NODE\"\n  payload: {\n    node: EditorNode\n    targetId: string\n    position: InsertPosition\n  }\n}\n\n/**\n * Moves a node to a new position in the tree.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'MOVE_NODE',\n *   payload: {\n *     nodeId: 'p-3',\n *     targetId: 'p-1',\n *     position: 'before'\n *   }\n * });\n * ```\n */\nexport interface MoveNodeAction {\n  type: \"MOVE_NODE\"\n  payload: {\n    nodeId: string\n    targetId: string\n    position: InsertPosition\n  }\n}\n\n/**\n * Swaps the positions of two nodes in the tree.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'SWAP_NODES',\n *   payload: {\n *     nodeId1: 'p-1',\n *     nodeId2: 'p-3'\n *   }\n * });\n * ```\n */\nexport interface SwapNodesAction {\n  type: \"SWAP_NODES\"\n  payload: {\n    nodeId1: string\n    nodeId2: string\n  }\n}\n\n/**\n * Duplicates a node and inserts it after the original.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'DUPLICATE_NODE',\n *   payload: {\n *     id: 'p-1',\n *     newId: 'p-1-copy' // Optional\n *   }\n * });\n * ```\n */\nexport interface DuplicateNodeAction {\n  type: \"DUPLICATE_NODE\"\n  payload: {\n    id: string\n    newId?: string\n  }\n}\n\n/**\n * Replaces the entire container with a new one.\n * Useful for loading saved documents or resetting the editor.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'REPLACE_CONTAINER',\n *   payload: { container: loadedDocument }\n * });\n * ```\n */\nexport interface ReplaceContainerAction {\n  type: \"REPLACE_CONTAINER\"\n  payload: {\n    container: ContainerNode\n  }\n}\n\n/**\n * Resets the editor to its initial state.\n *\n * @example\n * ```typescript\n * dispatch({ type: 'RESET' });\n * ```\n */\nexport interface ResetAction {\n  type: \"RESET\"\n}\n\n/**\n * Sets the entire editor state at once.\n * Useful for loading saved documents or replacing the entire state.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'SET_STATE',\n *   payload: { state: loadedState }\n * });\n * ```\n */\nexport interface SetStateAction {\n  type: \"SET_STATE\"\n  payload: {\n    state: EditorState\n  }\n}\n\n/**\n * Batch multiple actions into a single update.\n * Useful for performance when making multiple changes at once.\n *\n * @example\n * ```typescript\n * dispatch({\n *   type: 'BATCH',\n *   payload: {\n *     actions: [\n *       { type: 'UPDATE_CONTENT', payload: { id: 'p-1', content: 'A' } },\n *       { type: 'UPDATE_CONTENT', payload: { id: 'p-2', content: 'B' } },\n *     ]\n *   }\n * });\n * ```\n */\nexport interface BatchAction {\n  type: \"BATCH\"\n  payload: {\n    actions: EditorAction[]\n  }\n}\n\n/**\n * SET_ACTIVE_NODE action - sets the currently active/focused node\n */\nexport interface SetActiveNodeAction {\n  type: \"SET_ACTIVE_NODE\"\n  payload: {\n    nodeId: string | null\n  }\n}\n\n/**\n * SET_SELECTION action - updates selection state\n */\nexport interface SetSelectionAction {\n  type: \"SET_SELECTION\"\n  payload: {\n    hasSelection: boolean\n  }\n}\n\n/**\n * INCREMENT_SELECTION_KEY action - triggers re-render for selection changes\n */\nexport interface IncrementSelectionKeyAction {\n  type: \"INCREMENT_SELECTION_KEY\"\n}\n\n/**\n * SET_CURRENT_SELECTION action - updates the current selection info with formatting states\n */\nexport interface SetCurrentSelectionAction {\n  type: \"SET_CURRENT_SELECTION\"\n  payload: {\n    selection: SelectionInfo | null\n  }\n}\n\n/**\n * TOGGLE_FORMAT action - toggles a format style on the current selection\n */\nexport interface ToggleFormatAction {\n  type: \"TOGGLE_FORMAT\"\n  payload: {\n    format: \"bold\" | \"italic\" | \"underline\"\n  }\n}\n\n/**\n * APPLY_INLINE_ELEMENT_TYPE action - applies element type to selected text inline\n */\nexport interface ApplyInlineElementTypeAction {\n  type: \"APPLY_INLINE_ELEMENT_TYPE\"\n  payload: {\n    elementType:\n      | \"p\"\n      | \"h1\"\n      | \"h2\"\n      | \"h3\"\n      | \"h4\"\n      | \"h5\"\n      | \"h6\"\n      | \"code\"\n      | \"blockquote\"\n  }\n}\n\n/**\n * APPLY_CUSTOM_CLASS action - applies custom Tailwind class to selected text\n */\nexport interface ApplyCustomClassAction {\n  type: \"APPLY_CUSTOM_CLASS\"\n  payload: {\n    className: string\n  }\n}\n\n/**\n * APPLY_INLINE_STYLE action - applies inline CSS style to selected text\n */\nexport interface ApplyInlineStyleAction {\n  type: \"APPLY_INLINE_STYLE\"\n  payload: {\n    property: string // e.g., 'fontSize', 'color'\n    value: string // e.g., '24px', '#ff0000'\n  }\n}\n\n/**\n * APPLY_LINK action - applies link href to selected text\n */\nexport interface ApplyLinkAction {\n  type: \"APPLY_LINK\"\n  payload: {\n    href: string\n  }\n}\n\n/**\n * REMOVE_LINK action - removes link from selected text\n */\nexport interface RemoveLinkAction {\n  type: \"REMOVE_LINK\"\n}\n\n/**\n * SELECT_ALL_BLOCKS action - marks all blocks as selected\n */\nexport interface SelectAllBlocksAction {\n  type: \"SELECT_ALL_BLOCKS\"\n}\n\n/**\n * CLEAR_BLOCK_SELECTION action - clears all block selections\n */\nexport interface ClearBlockSelectionAction {\n  type: \"CLEAR_BLOCK_SELECTION\"\n}\n\n/**\n * DELETE_SELECTED_BLOCKS action - deletes all selected blocks\n */\nexport interface DeleteSelectedBlocksAction {\n  type: \"DELETE_SELECTED_BLOCKS\"\n}\n\n/**\n * UNDO action - moves back one step in history\n */\nexport interface UndoAction {\n  type: \"UNDO\"\n}\n\n/**\n * REDO action - moves forward one step in history\n */\nexport interface RedoAction {\n  type: \"REDO\"\n}\n\n/**\n * Union type of all possible editor actions.\n */\nexport type EditorAction =\n  | UpdateNodeAction\n  | UpdateAttributesAction\n  | UpdateContentAction\n  | DeleteNodeAction\n  | InsertNodeAction\n  | MoveNodeAction\n  | SwapNodesAction\n  | DuplicateNodeAction\n  | ReplaceContainerAction\n  | ResetAction\n  | SetStateAction\n  | BatchAction\n  | SetActiveNodeAction\n  | SetSelectionAction\n  | IncrementSelectionKeyAction\n  | SetCurrentSelectionAction\n  | ToggleFormatAction\n  | ApplyInlineElementTypeAction\n  | ApplyCustomClassAction\n  | ApplyInlineStyleAction\n  | ApplyLinkAction\n  | RemoveLinkAction\n  | SelectAllBlocksAction\n  | ClearBlockSelectionAction\n  | DeleteSelectedBlocksAction\n  | UndoAction\n  | RedoAction\n\n/**\n * Action creator helpers for type-safe action creation.\n */\nexport const EditorActions = {\n  /**\n   * Creates an UPDATE_NODE action.\n   */\n  updateNode: (id: string, updates: Partial<EditorNode>): UpdateNodeAction => ({\n    type: \"UPDATE_NODE\",\n    payload: { id, updates },\n  }),\n\n  /**\n   * Creates an UPDATE_ATTRIBUTES action.\n   */\n  updateAttributes: (\n    id: string,\n    attributes: NodeAttributes,\n    merge = true\n  ): UpdateAttributesAction => ({\n    type: \"UPDATE_ATTRIBUTES\",\n    payload: { id, attributes, merge },\n  }),\n\n  /**\n   * Creates an UPDATE_CONTENT action.\n   */\n  updateContent: (id: string, content: string): UpdateContentAction => ({\n    type: \"UPDATE_CONTENT\",\n    payload: { id, content },\n  }),\n\n  /**\n   * Creates a DELETE_NODE action.\n   */\n  deleteNode: (id: string): DeleteNodeAction => ({\n    type: \"DELETE_NODE\",\n    payload: { id },\n  }),\n\n  /**\n   * Creates an INSERT_NODE action.\n   */\n  insertNode: (\n    node: EditorNode,\n    targetId: string,\n    position: InsertPosition\n  ): InsertNodeAction => ({\n    type: \"INSERT_NODE\",\n    payload: { node, targetId, position },\n  }),\n\n  /**\n   * Creates a MOVE_NODE action.\n   */\n  moveNode: (\n    nodeId: string,\n    targetId: string,\n    position: InsertPosition\n  ): MoveNodeAction => ({\n    type: \"MOVE_NODE\",\n    payload: { nodeId, targetId, position },\n  }),\n\n  /**\n   * Creates a SWAP_NODES action.\n   */\n  swapNodes: (nodeId1: string, nodeId2: string): SwapNodesAction => ({\n    type: \"SWAP_NODES\",\n    payload: { nodeId1, nodeId2 },\n  }),\n\n  /**\n   * Creates a DUPLICATE_NODE action.\n   */\n  duplicateNode: (id: string, newId?: string): DuplicateNodeAction => ({\n    type: \"DUPLICATE_NODE\",\n    payload: { id, newId },\n  }),\n\n  /**\n   * Creates a REPLACE_CONTAINER action.\n   */\n  replaceContainer: (container: ContainerNode): ReplaceContainerAction => ({\n    type: \"REPLACE_CONTAINER\",\n    payload: { container },\n  }),\n\n  /**\n   * Creates a RESET action.\n   */\n  reset: (): ResetAction => ({\n    type: \"RESET\",\n  }),\n\n  /**\n   * Creates a SET_STATE action.\n   */\n  setState: (state: EditorState): SetStateAction => ({\n    type: \"SET_STATE\",\n    payload: { state },\n  }),\n\n  /**\n   * Creates a BATCH action.\n   */\n  batch: (actions: EditorAction[]): BatchAction => ({\n    type: \"BATCH\",\n    payload: { actions },\n  }),\n\n  /**\n   * Creates a SET_ACTIVE_NODE action.\n   */\n  setActiveNode: (nodeId: string | null): SetActiveNodeAction => ({\n    type: \"SET_ACTIVE_NODE\",\n    payload: { nodeId },\n  }),\n\n  /**\n   * Creates a SET_SELECTION action.\n   */\n  setSelection: (hasSelection: boolean): SetSelectionAction => ({\n    type: \"SET_SELECTION\",\n    payload: { hasSelection },\n  }),\n\n  /**\n   * Creates an INCREMENT_SELECTION_KEY action.\n   */\n  incrementSelectionKey: (): IncrementSelectionKeyAction => ({\n    type: \"INCREMENT_SELECTION_KEY\",\n  }),\n\n  /**\n   * Creates a SET_CURRENT_SELECTION action.\n   */\n  setCurrentSelection: (\n    selection: SelectionInfo | null\n  ): SetCurrentSelectionAction => ({\n    type: \"SET_CURRENT_SELECTION\",\n    payload: { selection },\n  }),\n\n  /**\n   * Creates a TOGGLE_FORMAT action.\n   */\n  toggleFormat: (\n    format: \"bold\" | \"italic\" | \"underline\"\n  ): ToggleFormatAction => ({\n    type: \"TOGGLE_FORMAT\",\n    payload: { format },\n  }),\n\n  /**\n   * Creates an APPLY_INLINE_ELEMENT_TYPE action.\n   */\n  applyInlineElementType: (\n    elementType:\n      | \"p\"\n      | \"h1\"\n      | \"h2\"\n      | \"h3\"\n      | \"h4\"\n      | \"h5\"\n      | \"h6\"\n      | \"code\"\n      | \"blockquote\"\n  ): ApplyInlineElementTypeAction => ({\n    type: \"APPLY_INLINE_ELEMENT_TYPE\",\n    payload: { elementType },\n  }),\n\n  /**\n   * Creates an APPLY_CUSTOM_CLASS action.\n   */\n  applyCustomClass: (className: string): ApplyCustomClassAction => ({\n    type: \"APPLY_CUSTOM_CLASS\",\n    payload: { className },\n  }),\n\n  /**\n   * Creates an APPLY_INLINE_STYLE action.\n   */\n  applyInlineStyle: (\n    property: string,\n    value: string\n  ): ApplyInlineStyleAction => ({\n    type: \"APPLY_INLINE_STYLE\",\n    payload: { property, value },\n  }),\n\n  /**\n   * Creates an APPLY_LINK action.\n   */\n  applyLink: (href: string): ApplyLinkAction => ({\n    type: \"APPLY_LINK\",\n    payload: { href },\n  }),\n\n  /**\n   * Creates a REMOVE_LINK action.\n   */\n  removeLink: (): RemoveLinkAction => ({\n    type: \"REMOVE_LINK\",\n  }),\n\n  /**\n   * Creates a SELECT_ALL_BLOCKS action.\n   */\n  selectAllBlocks: (): SelectAllBlocksAction => ({\n    type: \"SELECT_ALL_BLOCKS\",\n  }),\n\n  /**\n   * Creates a CLEAR_BLOCK_SELECTION action.\n   */\n  clearBlockSelection: (): ClearBlockSelectionAction => ({\n    type: \"CLEAR_BLOCK_SELECTION\",\n  }),\n\n  /**\n   * Creates a DELETE_SELECTED_BLOCKS action.\n   */\n  deleteSelectedBlocks: (): DeleteSelectedBlocksAction => ({\n    type: \"DELETE_SELECTED_BLOCKS\",\n  }),\n\n  /**\n   * Creates an UNDO action.\n   */\n  undo: (): UndoAction => ({\n    type: \"UNDO\",\n  }),\n\n  /**\n   * Creates a REDO action.\n   */\n  redo: (): RedoAction => ({\n    type: \"REDO\",\n  }),\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/reducer/editor-reducer.ts",
      "content": "/**\n * Mina Rich Editor - Reducer\n *\n * Pure reducer function that handles all state transformations.\n * Follows immutable update patterns for predictable state management.\n * Includes history tracking for undo/redo functionality.\n *\n * @packageDocumentation\n */\n\nimport {\n  ContainerNode,\n  EditorState,\n  hasInlineChildren,\n  isTextNode,\n  TextNode,\n} from \"../types\"\nimport { applyFormatting } from \"../utils/inline-formatting\"\nimport {\n  cloneNode,\n  deleteNodeById,\n  findNodeById,\n  insertNode,\n  moveNode,\n  updateNodeById,\n} from \"../utils/tree-operations\"\nimport { EditorAction } from \"./actions\"\n\n/**\n * Maximum number of history states to keep\n */\nconst MAX_HISTORY_SIZE = 100\n\n/**\n * Deep clone a container node to preserve history immutability\n */\nfunction deepCloneContainer(container: ContainerNode): ContainerNode {\n  return JSON.parse(JSON.stringify(container))\n}\n\n/**\n * Add a new container state to history\n * This truncates any \"future\" history if we're not at the end\n */\nfunction addToHistory(\n  state: EditorState,\n  newContainer: ContainerNode\n): EditorState {\n  // Clone the new container to ensure immutability\n  const clonedContainer = deepCloneContainer(newContainer)\n\n  // Get current history up to the current index\n  const newHistory = state.history.slice(0, state.historyIndex + 1)\n\n  // Add the new state\n  newHistory.push(clonedContainer)\n\n  // Limit history size\n  if (newHistory.length > MAX_HISTORY_SIZE) {\n    newHistory.shift() // Remove oldest entry\n    return {\n      ...state,\n      history: newHistory,\n      historyIndex: newHistory.length - 1,\n    }\n  }\n\n  return {\n    ...state,\n    history: newHistory,\n    historyIndex: newHistory.length - 1,\n  }\n}\n\n/**\n * The main reducer function for the editor.\n * Handles all state transformations immutably.\n *\n * @param state - Current editor state\n * @param action - Action to apply\n * @returns New state after applying the action\n *\n * @example\n * ```typescript\n * const newState = editorReducer(currentState, {\n *   type: 'UPDATE_CONTENT',\n *   payload: { id: 'p-1', content: 'New text' }\n * });\n * ```\n */\nexport function editorReducer(\n  state: EditorState,\n  action: EditorAction\n): EditorState {\n  switch (action.type) {\n    case \"UPDATE_NODE\": {\n      const { id, updates } = action.payload\n      const currentContainer = state.history[state.historyIndex]\n      const newContainer = updateNodeById(\n        currentContainer,\n        id,\n        () => updates\n      ) as ContainerNode\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"UPDATE_ATTRIBUTES\": {\n      const { id, attributes, merge = true } = action.payload\n      const currentContainer = state.history[state.historyIndex]\n      const newContainer = updateNodeById(currentContainer, id, (node) => ({\n        attributes: merge ? { ...node.attributes, ...attributes } : attributes,\n      })) as ContainerNode\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"UPDATE_CONTENT\": {\n      const { id, content } = action.payload\n      const currentContainer = state.history[state.historyIndex]\n      const newContainer = updateNodeById(currentContainer, id, (node) => {\n        if (isTextNode(node)) {\n          return { content }\n        }\n        console.warn(`Cannot update content of container node ${id}`)\n        return {}\n      }) as ContainerNode\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"DELETE_NODE\": {\n      const { id } = action.payload\n      const currentContainer = state.history[state.historyIndex]\n      const result = deleteNodeById(currentContainer, id)\n\n      // If the root container was deleted, prevent it\n      if (result === null) {\n        console.warn(\"Cannot delete the root container\")\n        return state\n      }\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        result as ContainerNode\n      )\n    }\n\n    case \"INSERT_NODE\": {\n      const { node, targetId, position } = action.payload\n      const currentContainer = state.history[state.historyIndex]\n      const newContainer = insertNode(\n        currentContainer,\n        targetId,\n        node,\n        position\n      ) as ContainerNode\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"MOVE_NODE\": {\n      const { nodeId, targetId, position } = action.payload\n      const currentContainer = state.history[state.historyIndex]\n      const newContainer = moveNode(\n        currentContainer,\n        nodeId,\n        targetId,\n        position\n      ) as ContainerNode\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"SWAP_NODES\": {\n      const { nodeId1, nodeId2 } = action.payload\n      const currentContainer = state.history[state.historyIndex]\n\n      // Find indices of both nodes\n      const index1 = currentContainer.children.findIndex(\n        (n) => n.id === nodeId1\n      )\n      const index2 = currentContainer.children.findIndex(\n        (n) => n.id === nodeId2\n      )\n\n      // If either node not found, return current state\n      if (index1 === -1 || index2 === -1) {\n        return state\n      }\n\n      // Clone container and swap positions\n      const newChildren = [...currentContainer.children]\n      ;[newChildren[index1], newChildren[index2]] = [\n        newChildren[index2],\n        newChildren[index1],\n      ]\n\n      const newContainer: ContainerNode = {\n        ...currentContainer,\n        children: newChildren,\n      }\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"DUPLICATE_NODE\": {\n      const { id, newId } = action.payload\n      const currentContainer = state.history[state.historyIndex]\n\n      // Clone the node with a new ID\n      const nodeToClone = updateNodeById(currentContainer, id, (node) => node)\n      const clonedNode = cloneNode(nodeToClone, newId)\n\n      // Insert the cloned node after the original\n      const newContainer = insertNode(\n        currentContainer,\n        id,\n        clonedNode,\n        \"after\"\n      ) as ContainerNode\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"REPLACE_CONTAINER\": {\n      const { container } = action.payload\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        container\n      )\n    }\n\n    case \"RESET\": {\n      return createInitialState()\n    }\n\n    case \"SET_STATE\": {\n      const { state: newState } = action.payload\n      return newState\n    }\n\n    case \"BATCH\": {\n      const { actions } = action.payload\n\n      // Apply all actions sequentially\n      return actions.reduce(\n        (currentState, batchAction) => editorReducer(currentState, batchAction),\n        state\n      )\n    }\n\n    case \"SET_ACTIVE_NODE\": {\n      const { nodeId } = action.payload\n      return {\n        ...state,\n        activeNodeId: nodeId,\n      }\n    }\n\n    case \"SET_SELECTION\": {\n      const { hasSelection } = action.payload\n      return {\n        ...state,\n        hasSelection,\n      }\n    }\n\n    case \"INCREMENT_SELECTION_KEY\": {\n      return {\n        ...state,\n        selectionKey: state.selectionKey + 1,\n      }\n    }\n\n    case \"SET_CURRENT_SELECTION\": {\n      const { selection } = action.payload\n\n      return {\n        ...state,\n        currentSelection: selection,\n        hasSelection: selection !== null,\n      }\n    }\n\n    case \"APPLY_INLINE_ELEMENT_TYPE\": {\n      const { elementType } = action.payload\n\n      console.group(\"🎨 [APPLY_INLINE_ELEMENT_TYPE] Reducer executing\")\n\n      if (!state.currentSelection) {\n        console.warn(\"❌ Cannot apply element type without active selection\")\n        console.groupEnd()\n        return state\n      }\n\n      const { nodeId, start, end } = state.currentSelection\n\n      const currentContainer = state.history[state.historyIndex]\n      const node = findNodeById(currentContainer, nodeId) as\n        | TextNode\n        | undefined\n\n      if (!node || !isTextNode(node)) {\n        console.warn(\"❌ Node not found or not a text node\")\n        console.groupEnd()\n        return state\n      }\n\n      // Convert node to inline children if it's still plain content\n      const children = hasInlineChildren(node)\n        ? node.children!\n        : [{ content: node.content || \"\" }]\n\n      // Build new children array by splitting segments that overlap with selection\n      const newChildren: typeof node.children = []\n      let currentPos = 0\n\n      for (const child of children) {\n        const childLength = (child.content || \"\").length\n        const childStart = currentPos\n        const childEnd = currentPos + childLength\n\n        // Check overlap with selection [start, end)\n        if (childEnd <= start || childStart >= end) {\n          // No overlap - keep as is\n          newChildren.push({ ...child })\n        } else {\n          // There's overlap - need to split this child\n          const overlapStart = Math.max(childStart, start)\n          const overlapEnd = Math.min(childEnd, end)\n\n          // Before overlap (within this child)\n          if (childStart < overlapStart) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(0, overlapStart - childStart),\n            })\n          }\n\n          // Overlapping part - apply the element type\n          newChildren.push({\n            ...child,\n            content: child.content!.substring(\n              overlapStart - childStart,\n              overlapEnd - childStart\n            ),\n            elementType: elementType,\n          })\n\n          // After overlap (within this child)\n          if (childEnd > overlapEnd) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(overlapEnd - childStart),\n            })\n          }\n        }\n\n        currentPos = childEnd\n      }\n\n      // Update the node in the tree\n      const newContainer = updateNodeById(currentContainer, nodeId, () => ({\n        content: undefined, // Clear simple content\n        children: newChildren, // Set inline children\n      })) as ContainerNode\n\n      console.groupEnd()\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"TOGGLE_FORMAT\": {\n      const { format } = action.payload\n\n      if (!state.currentSelection) {\n        console.warn(\"❌ Cannot toggle format without active selection\")\n        console.groupEnd()\n        return state\n      }\n\n      const { nodeId, start, end, formats } = state.currentSelection\n\n      const currentContainer = state.history[state.historyIndex]\n      const node = findNodeById(currentContainer, nodeId) as\n        | TextNode\n        | undefined\n\n      if (!node || !isTextNode(node)) {\n        console.warn(\"❌ Node not found or not a text node\")\n        console.groupEnd()\n        return state\n      }\n\n      const isActive = formats[format]\n\n      // Convert node to inline children if it's still plain content\n      const children = hasInlineChildren(node)\n        ? node.children!\n        : [{ content: node.content || \"\" }]\n\n      // Build new children array by splitting segments that overlap with selection\n      const newChildren: typeof node.children = []\n      let currentPos = 0\n\n      for (const child of children) {\n        const childLength = (child.content || \"\").length\n        const childStart = currentPos\n        const childEnd = currentPos + childLength\n\n        // Check overlap with selection [start, end)\n        if (childEnd <= start || childStart >= end) {\n          // No overlap - keep as is\n          newChildren.push({ ...child })\n        } else {\n          // There's overlap - need to split this child\n          const overlapStart = Math.max(childStart, start)\n          const overlapEnd = Math.min(childEnd, end)\n\n          // Before overlap (within this child)\n          if (childStart < overlapStart) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(0, overlapStart - childStart),\n            })\n          }\n\n          // Overlapping part - toggle the format\n          newChildren.push({\n            ...child,\n            content: child.content!.substring(\n              overlapStart - childStart,\n              overlapEnd - childStart\n            ),\n            bold: format === \"bold\" ? !isActive : child.bold,\n            italic: format === \"italic\" ? !isActive : child.italic,\n            underline: format === \"underline\" ? !isActive : child.underline,\n          })\n\n          // After overlap (within this child)\n          if (childEnd > overlapEnd) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(overlapEnd - childStart),\n            })\n          }\n        }\n\n        currentPos = childEnd\n      }\n\n      // Update the node in the tree\n      const newContainer = updateNodeById(currentContainer, nodeId, () => ({\n        content: undefined, // Clear simple content\n        children: newChildren, // Set inline children\n      })) as ContainerNode\n\n      // Update the selection's format state\n      const newSelection = {\n        ...state.currentSelection,\n        formats: {\n          ...state.currentSelection.formats,\n          [format]: !isActive,\n        },\n      }\n\n      console.groupEnd()\n\n      return addToHistory(\n        {\n          ...state,\n          currentSelection: newSelection,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"APPLY_CUSTOM_CLASS\": {\n      const { className } = action.payload\n\n      console.group(\"🎨 [APPLY_CUSTOM_CLASS] Reducer executing\")\n\n      if (!state.currentSelection) {\n        console.warn(\"❌ Cannot apply custom class without active selection\")\n        console.groupEnd()\n        return state\n      }\n\n      const { nodeId, start, end } = state.currentSelection\n\n      const currentContainer = state.history[state.historyIndex]\n      const node = findNodeById(currentContainer, nodeId) as\n        | TextNode\n        | undefined\n\n      if (!node || !isTextNode(node)) {\n        console.warn(\"❌ Node not found or not a text node\")\n        console.groupEnd()\n        return state\n      }\n\n      // Convert node to inline children if it's still plain content\n      const children = hasInlineChildren(node)\n        ? node.children!\n        : [{ content: node.content || \"\" }]\n\n      // Build new children array by splitting segments that overlap with selection\n      const newChildren: typeof node.children = []\n      let currentPos = 0\n\n      for (const child of children) {\n        const childLength = (child.content || \"\").length\n        const childStart = currentPos\n        const childEnd = currentPos + childLength\n\n        // Check overlap with selection [start, end)\n        if (childEnd <= start || childStart >= end) {\n          // No overlap - keep as is\n          newChildren.push({ ...child })\n        } else {\n          // There's overlap - need to split this child\n          const overlapStart = Math.max(childStart, start)\n          const overlapEnd = Math.min(childEnd, end)\n\n          // Before overlap (within this child)\n          if (childStart < overlapStart) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(0, overlapStart - childStart),\n            })\n          }\n\n          // Overlapping part - merge className (just combine classes now, no styles)\n          const existingClasses = (child.className || \"\")\n            .split(\" \")\n            .filter(Boolean)\n          const newClasses = className.split(\" \").filter(Boolean)\n          const mergedClasses = [\n            ...new Set([...existingClasses, ...newClasses]),\n          ]\n          const mergedClassName = mergedClasses.join(\" \").trim()\n\n          newChildren.push({\n            ...child,\n            content: child.content!.substring(\n              overlapStart - childStart,\n              overlapEnd - childStart\n            ),\n            className: mergedClassName || undefined,\n          })\n\n          // After overlap (within this child)\n          if (childEnd > overlapEnd) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(overlapEnd - childStart),\n            })\n          }\n        }\n\n        currentPos = childEnd\n      }\n\n      // Update the node in the tree\n      const newContainer = updateNodeById(currentContainer, nodeId, () => ({\n        content: undefined, // Clear simple content\n        children: newChildren, // Set inline children\n      })) as ContainerNode\n\n      console.groupEnd()\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"APPLY_INLINE_STYLE\": {\n      const { property, value } = action.payload\n\n      console.group(`🎨 [APPLY_INLINE_STYLE] Applying ${property}: ${value}`)\n\n      if (!state.currentSelection) {\n        console.warn(\"❌ Cannot apply inline style without active selection\")\n        console.groupEnd()\n        return state\n      }\n\n      const { nodeId, start, end } = state.currentSelection\n\n      const currentContainer = state.history[state.historyIndex]\n      const node = findNodeById(currentContainer, nodeId) as\n        | TextNode\n        | undefined\n\n      if (!node || !isTextNode(node)) {\n        console.warn(\"❌ Node not found or not a text node\")\n        console.groupEnd()\n        return state\n      }\n\n      // Convert node to inline children if it's still plain content\n      const children = hasInlineChildren(node)\n        ? node.children!\n        : [{ content: node.content || \"\" }]\n\n      // Build new children array by splitting segments that overlap with selection\n      const newChildren: typeof node.children = []\n      let currentPos = 0\n\n      for (const child of children) {\n        const childLength = (child.content || \"\").length\n        const childStart = currentPos\n        const childEnd = currentPos + childLength\n\n        // Check overlap with selection [start, end)\n        if (childEnd <= start || childStart >= end) {\n          // No overlap - keep as is\n          newChildren.push({ ...child })\n        } else {\n          // There's overlap - need to split this child\n          const overlapStart = Math.max(childStart, start)\n          const overlapEnd = Math.min(childEnd, end)\n\n          // Before overlap (within this child)\n          if (childStart < overlapStart) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(0, overlapStart - childStart),\n            })\n          }\n\n          // Overlapping part - merge inline styles\n          const mergedStyles = {\n            ...child.styles,\n            [property]: value,\n          }\n\n          newChildren.push({\n            ...child,\n            content: child.content!.substring(\n              overlapStart - childStart,\n              overlapEnd - childStart\n            ),\n            styles: mergedStyles,\n          })\n\n          // After overlap (within this child)\n          if (childEnd > overlapEnd) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(overlapEnd - childStart),\n            })\n          }\n        }\n\n        currentPos = childEnd\n      }\n\n      // Update the node in the tree\n      const newContainer = updateNodeById(currentContainer, nodeId, () => ({\n        content: undefined, // Clear simple content\n        children: newChildren, // Set inline children\n      })) as ContainerNode\n\n      console.groupEnd()\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"APPLY_LINK\": {\n      const { href } = action.payload\n\n      console.group(\"🔗 [APPLY_LINK] Reducer executing\")\n\n      if (!state.currentSelection) {\n        console.warn(\"❌ Cannot apply link without active selection\")\n        console.groupEnd()\n        return state\n      }\n\n      const { nodeId, start, end } = state.currentSelection\n\n      const currentContainer = state.history[state.historyIndex]\n      const node = findNodeById(currentContainer, nodeId) as\n        | TextNode\n        | undefined\n\n      if (!node || !isTextNode(node)) {\n        console.warn(\"❌ Node not found or not a text node\")\n        console.groupEnd()\n        return state\n      }\n\n      // Convert node to inline children if it's still plain content\n      const children = hasInlineChildren(node)\n        ? node.children!\n        : [{ content: node.content || \"\" }]\n\n      // Build new children array by splitting segments that overlap with selection\n      const newChildren: typeof node.children = []\n      let currentPos = 0\n\n      for (const child of children) {\n        const childLength = (child.content || \"\").length\n        const childStart = currentPos\n        const childEnd = currentPos + childLength\n\n        // Check overlap with selection [start, end)\n        if (childEnd <= start || childStart >= end) {\n          // No overlap - keep as is\n          newChildren.push({ ...child })\n        } else {\n          // There's overlap - need to split this child\n          const overlapStart = Math.max(childStart, start)\n          const overlapEnd = Math.min(childEnd, end)\n\n          // Before overlap (within this child)\n          if (childStart < overlapStart) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(0, overlapStart - childStart),\n            })\n          }\n\n          // Overlapping part - apply the link\n          newChildren.push({\n            ...child,\n            content: child.content!.substring(\n              overlapStart - childStart,\n              overlapEnd - childStart\n            ),\n            href: href,\n          })\n\n          // After overlap (within this child)\n          if (childEnd > overlapEnd) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(overlapEnd - childStart),\n            })\n          }\n        }\n\n        currentPos = childEnd\n      }\n\n      // Update the node in the tree\n      const newContainer = updateNodeById(currentContainer, nodeId, () => ({\n        content: undefined, // Clear simple content\n        children: newChildren, // Set inline children\n      })) as ContainerNode\n\n      console.groupEnd()\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"REMOVE_LINK\": {\n      console.group(\"🔗 [REMOVE_LINK] Reducer executing\")\n\n      if (!state.currentSelection) {\n        console.warn(\"❌ Cannot remove link without active selection\")\n        console.groupEnd()\n        return state\n      }\n\n      const { nodeId, start, end } = state.currentSelection\n\n      const currentContainer = state.history[state.historyIndex]\n      const node = findNodeById(currentContainer, nodeId) as\n        | TextNode\n        | undefined\n\n      if (!node || !isTextNode(node)) {\n        console.warn(\"❌ Node not found or not a text node\")\n        console.groupEnd()\n        return state\n      }\n\n      // Convert node to inline children if it's still plain content\n      const children = hasInlineChildren(node)\n        ? node.children!\n        : [{ content: node.content || \"\" }]\n\n      // Build new children array by splitting segments that overlap with selection\n      const newChildren: typeof node.children = []\n      let currentPos = 0\n\n      for (const child of children) {\n        const childLength = (child.content || \"\").length\n        const childStart = currentPos\n        const childEnd = currentPos + childLength\n\n        // Check overlap with selection [start, end)\n        if (childEnd <= start || childStart >= end) {\n          // No overlap - keep as is\n          newChildren.push({ ...child })\n        } else {\n          // There's overlap - need to split this child\n          const overlapStart = Math.max(childStart, start)\n          const overlapEnd = Math.min(childEnd, end)\n\n          // Before overlap (within this child)\n          if (childStart < overlapStart) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(0, overlapStart - childStart),\n            })\n          }\n\n          // Overlapping part - remove the link\n          newChildren.push({\n            ...child,\n            content: child.content!.substring(\n              overlapStart - childStart,\n              overlapEnd - childStart\n            ),\n            href: undefined, // Remove the href\n          })\n\n          // After overlap (within this child)\n          if (childEnd > overlapEnd) {\n            newChildren.push({\n              ...child,\n              content: child.content!.substring(overlapEnd - childStart),\n            })\n          }\n        }\n\n        currentPos = childEnd\n      }\n\n      // Update the node in the tree\n      const newContainer = updateNodeById(currentContainer, nodeId, () => ({\n        content: undefined, // Clear simple content\n        children: newChildren, // Set inline children\n      })) as ContainerNode\n\n      console.groupEnd()\n\n      return addToHistory(\n        {\n          ...state,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        newContainer\n      )\n    }\n\n    case \"SELECT_ALL_BLOCKS\": {\n      // Select all block IDs\n      const currentContainer = state.history[state.historyIndex]\n      const allBlockIds = new Set(\n        currentContainer.children.map((child) => child.id)\n      )\n      return {\n        ...state,\n        selectedBlocks: allBlockIds,\n      }\n    }\n\n    case \"CLEAR_BLOCK_SELECTION\": {\n      return {\n        ...state,\n        selectedBlocks: new Set(),\n      }\n    }\n\n    case \"DELETE_SELECTED_BLOCKS\": {\n      if (state.selectedBlocks.size === 0) {\n        return state\n      }\n\n      const currentContainer = state.history[state.historyIndex]\n      // Delete all selected blocks\n      const newChildren = currentContainer.children.filter(\n        (child) => !state.selectedBlocks.has(child.id)\n      )\n\n      // If all blocks were deleted, create a new empty paragraph\n      if (newChildren.length === 0) {\n        const newNode: TextNode = {\n          id: \"p-\" + Date.now(),\n          type: \"p\",\n          content: \"\",\n          attributes: {},\n        }\n        newChildren.push(newNode)\n      }\n\n      return addToHistory(\n        {\n          ...state,\n          selectedBlocks: new Set(),\n          activeNodeId: newChildren[0]?.id || null,\n          metadata: {\n            ...state.metadata,\n            updatedAt: new Date().toISOString(),\n          },\n        },\n        {\n          ...currentContainer,\n          children: newChildren,\n        }\n      )\n    }\n\n    case \"UNDO\": {\n      if (state.historyIndex > 0) {\n        const newIndex = state.historyIndex - 1\n        return {\n          ...state,\n          historyIndex: newIndex,\n        }\n      }\n      return state\n    }\n\n    case \"REDO\": {\n      if (state.historyIndex < state.history.length - 1) {\n        const newIndex = state.historyIndex + 1\n        return {\n          ...state,\n          historyIndex: newIndex,\n        }\n      }\n      return state\n    }\n\n    default:\n      // Exhaustiveness check\n      const _exhaustive: never = action\n      console.warn(\"Unknown action type:\", _exhaustive)\n      return state\n  }\n}\n\n/**\n * Creates the initial state for a new editor instance.\n *\n * @param container - Optional custom root container\n * @returns Initial editor state\n *\n * @example\n * ```typescript\n * const initialState = createInitialState();\n * const [state, dispatch] = useReducer(editorReducer, initialState);\n * ```\n */\nexport function createInitialState(\n  container?: Partial<ContainerNode>\n): EditorState {\n  // If container is provided, use it; otherwise create with at least one empty block\n  let defaultChildren = container?.children\n\n  // If no children provided or empty array, create a default empty paragraph\n  if (!defaultChildren || defaultChildren.length === 0) {\n    const timestamp = Date.now()\n    const defaultNode: TextNode = {\n      id: `p-${timestamp}`,\n      type: \"p\",\n      content: \"\",\n      attributes: {},\n    }\n    defaultChildren = [defaultNode]\n  }\n\n  const initialContainer: ContainerNode = {\n    id: \"root\",\n    type: \"container\",\n    children: defaultChildren,\n    ...container,\n  }\n\n  // Clone the container first, then get the activeNodeId from the cloned version\n  const clonedContainer = deepCloneContainer(initialContainer)\n\n  return {\n    version: \"1.0.0\",\n    history: [clonedContainer],\n    historyIndex: 0,\n    activeNodeId: clonedContainer.children[0].id,\n    hasSelection: false,\n    selectionKey: 0,\n    currentSelection: null,\n    selectedBlocks: new Set(),\n    metadata: {\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    },\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/index.ts",
      "content": "/**\n * Editor Handlers Index\n *\n * Central export point for all editor handler functions\n */\n\n// Selection handlers\nexport * from \"./selection-handlers\"\n\n// Keyboard handlers\nexport * from \"./keyboard-handlers\"\n\n// Drag and drop handlers\nexport * from \"./drag-drop-handlers\"\n\n// File upload handlers\nexport * from \"./file-upload-handlers\"\n\n// Node operation handlers\nexport * from \"./node-operation-handlers\"\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/drag-drop-handlers.ts",
      "content": "/**\n * Drag and Drop Handler Functions\n *\n * Functions for handling drag and drop operations in the editor\n */\n\nimport { EditorActions } from \"../reducer/actions\"\nimport {\n  ContainerNode,\n  EditorNode,\n  isContainerNode,\n  isTextNode,\n  TextNode,\n} from \"../types\"\nimport { findNodeAnywhere } from \"../utils/editor-helpers\"\nimport { uploadImage } from \"../utils/image-upload\"\n\nexport interface DragDropHandlerParams {\n  container: ContainerNode\n  dispatch: React.Dispatch<any>\n  toast: any\n  draggingNodeId: string | null\n  setDraggingNodeId: (id: string | null) => void\n  setDragOverNodeId: (id: string | null) => void\n  setDropPosition: (pos: \"before\" | \"after\" | \"left\" | \"right\" | null) => void\n  setIsUploading: (uploading: boolean) => void\n  onUploadImage?: (file: File) => Promise<string>\n}\n\n/**\n * Handle image drag start\n */\nexport function createHandleImageDragStart(\n  setDraggingNodeId: (id: string) => void\n) {\n  return (nodeId: string) => {\n    setDraggingNodeId(nodeId)\n  }\n}\n\n/**\n * Handle block drag start\n */\nexport function createHandleBlockDragStart(\n  setDraggingNodeId: (id: string) => void\n) {\n  return (nodeId: string) => {\n    setDraggingNodeId(nodeId)\n  }\n}\n\n/**\n * Handle drag enter\n */\nexport function createHandleDragEnter() {\n  return (e: React.DragEvent, nodeId: string) => {\n    e.preventDefault()\n    e.stopPropagation()\n  }\n}\n\n/**\n * Handle drag over\n */\nexport function createHandleDragOver(\n  params: Omit<\n    DragDropHandlerParams,\n    \"toast\" | \"setIsUploading\" | \"onUploadImage\"\n  >\n) {\n  return (e: React.DragEvent, nodeId: string) => {\n    const { container, draggingNodeId, setDragOverNodeId, setDropPosition } =\n      params\n    e.preventDefault()\n    e.stopPropagation()\n\n    // Check if we're dragging an existing block (image) or files from outside\n    const draggedNodeId = e.dataTransfer.getData(\"text/plain\")\n\n    // Don't show drop indicator if we're hovering over the dragged element itself\n    if (draggingNodeId === nodeId) {\n      e.dataTransfer.dropEffect = \"none\"\n      setDragOverNodeId(null)\n      setDropPosition(null)\n      return\n    }\n\n    const targetResult = findNodeAnywhere(nodeId, container)\n    const draggingResult = draggingNodeId\n      ? findNodeAnywhere(draggingNodeId, container)\n      : null\n\n    if (!targetResult) return\n\n    const targetNode = targetResult.node\n    const draggingNode = draggingResult?.node\n    const isTargetImage =\n      isTextNode(targetNode) && (targetNode as TextNode).type === \"img\"\n    const isDraggingImage =\n      draggingNode &&\n      isTextNode(draggingNode) &&\n      (draggingNode as TextNode).type === \"img\"\n\n    // Check if target and dragging nodes are in the same flex container\n    const inSameFlexContainer =\n      targetResult.parentId &&\n      draggingResult?.parentId &&\n      targetResult.parentId === draggingResult.parentId\n\n    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect()\n\n    // If both are images, check for horizontal (left/right) drop zones\n    if (isTargetImage && isDraggingImage) {\n      const edgeThreshold = rect.width * 0.3 // 30% from each edge\n\n      // If in same flex container, allow reordering via horizontal drop\n      if (inSameFlexContainer) {\n        // Get the parent container to check positions\n        const parent = draggingResult?.parentId\n          ? (container.children.find(\n              (c) => c.id === draggingResult.parentId\n            ) as ContainerNode)\n          : null\n\n        if (parent) {\n          const dragIndex = parent.children.findIndex(\n            (c) => c.id === draggingNodeId\n          )\n          const targetIndex = parent.children.findIndex((c) => c.id === nodeId)\n\n          // Check if we're on the left edge\n          if (e.clientX < rect.left + edgeThreshold) {\n            // Prevent dropping to the left of the item immediately to our right\n            if (targetIndex === dragIndex + 1) {\n              e.dataTransfer.dropEffect = \"none\"\n              setDragOverNodeId(null)\n              setDropPosition(null)\n              return\n            }\n            setDragOverNodeId(nodeId)\n            setDropPosition(\"left\")\n            e.dataTransfer.dropEffect = \"move\"\n            return\n          }\n          // Check if we're on the right edge\n          else if (e.clientX > rect.right - edgeThreshold) {\n            // Prevent dropping to the right of the item immediately to our left\n            if (targetIndex === dragIndex - 1) {\n              e.dataTransfer.dropEffect = \"none\"\n              setDragOverNodeId(null)\n              setDropPosition(null)\n              return\n            }\n            setDragOverNodeId(nodeId)\n            setDropPosition(\"right\")\n            e.dataTransfer.dropEffect = \"move\"\n            return\n          }\n        }\n        // If we're in the middle of an item in the same flex container, no drop\n        e.dataTransfer.dropEffect = \"none\"\n        setDragOverNodeId(null)\n        setDropPosition(null)\n        return\n      } else {\n        // Not in same container - allow horizontal merge\n        if (e.clientX < rect.left + edgeThreshold) {\n          setDragOverNodeId(nodeId)\n          setDropPosition(\"left\")\n          e.dataTransfer.dropEffect = \"move\"\n          return\n        } else if (e.clientX > rect.right - edgeThreshold) {\n          setDragOverNodeId(nodeId)\n          setDropPosition(\"right\")\n          e.dataTransfer.dropEffect = \"move\"\n          return\n        }\n      }\n    }\n\n    // Default vertical drop logic\n    const midPoint = rect.top + rect.height / 2\n    const position = e.clientY < midPoint ? \"before\" : \"after\"\n\n    // If dragging an existing block, check if this would result in no movement\n    if (draggingNodeId) {\n      // Find the indices of the dragged node and target node\n      const draggedIndex = container.children.findIndex(\n        (n) => n.id === draggingNodeId\n      )\n      const targetIndex = container.children.findIndex((n) => n.id === nodeId)\n\n      // Don't allow drops that would result in no movement:\n      // - Dropping \"after\" on the previous block (would stay in same position)\n      // - Dropping \"before\" on the next block (would stay in same position)\n      if (\n        (position === \"after\" && targetIndex === draggedIndex - 1) ||\n        (position === \"before\" && targetIndex === draggedIndex + 1)\n      ) {\n        e.dataTransfer.dropEffect = \"none\"\n        setDragOverNodeId(null)\n        setDropPosition(null)\n        return\n      }\n    }\n\n    // Allow drop - this is required for drop to work\n    // Use \"move\" for existing blocks, \"copy\" for external files\n    e.dataTransfer.dropEffect =\n      draggedNodeId || draggingNodeId ? \"move\" : \"copy\"\n\n    setDragOverNodeId(nodeId)\n    setDropPosition(position)\n  }\n}\n\n/**\n * Handle drag leave\n */\nexport function createHandleDragLeave(\n  setDragOverNodeId: (id: string | null) => void,\n  setDropPosition: (pos: \"before\" | \"after\" | \"left\" | \"right\" | null) => void\n) {\n  return (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    // Only clear if we're actually leaving the element (not entering a child)\n    const relatedTarget = e.relatedTarget as HTMLElement\n    const currentTarget = e.currentTarget as HTMLElement\n\n    if (!currentTarget.contains(relatedTarget)) {\n      setDragOverNodeId(null)\n      setDropPosition(null)\n    }\n  }\n}\n\n/**\n * Handle drop - This is a complex function that handles multiple drop scenarios\n * Note: This function should be further broken down in the future\n */\nexport function createHandleDrop(\n  params: DragDropHandlerParams,\n  dropPosition: \"before\" | \"after\" | \"left\" | \"right\" | null\n) {\n  return async (e: React.DragEvent, nodeId: string) => {\n    const {\n      container,\n      dispatch,\n      toast,\n      draggingNodeId,\n      setDraggingNodeId,\n      setDragOverNodeId,\n      setDropPosition,\n      setIsUploading,\n      onUploadImage,\n    } = params\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    // Check if we're moving an existing image block\n    const draggedNodeId = e.dataTransfer.getData(\"text/plain\")\n\n    if (draggedNodeId && draggingNodeId) {\n      // Moving an existing image\n\n      // Don't drop on itself\n      if (draggingNodeId === nodeId) {\n        setDragOverNodeId(null)\n        setDropPosition(null)\n        setDraggingNodeId(null)\n        return\n      }\n\n      const draggingResult = findNodeAnywhere(draggingNodeId, container)\n      const targetResult = findNodeAnywhere(nodeId, container)\n\n      if (!draggingResult || !targetResult) {\n        setDragOverNodeId(null)\n        setDropPosition(null)\n        setDraggingNodeId(null)\n        return\n      }\n\n      const draggingNode = draggingResult.node\n      const targetNode = targetResult.node\n      const inSameFlexContainer =\n        draggingResult.parentId &&\n        targetResult.parentId &&\n        draggingResult.parentId === targetResult.parentId\n\n      // Check if this is a horizontal drop (left/right)\n      if (dropPosition === \"left\" || dropPosition === \"right\") {\n        // Case 1: Reordering images within the same flex container\n        if (\n          inSameFlexContainer &&\n          draggingResult.parent &&\n          targetResult.parent\n        ) {\n          const parent = draggingResult.parent\n          const newChildren = [...parent.children]\n\n          const dragIndex = newChildren.findIndex(\n            (c) => c.id === draggingNodeId\n          )\n          const targetIndex = newChildren.findIndex((c) => c.id === nodeId)\n\n          // Remove the dragged item from its current position\n          const [draggedItem] = newChildren.splice(dragIndex, 1)\n\n          // Calculate the new target index after removal\n          const adjustedTargetIndex =\n            dragIndex < targetIndex ? targetIndex - 1 : targetIndex\n\n          // Insert at the correct position based on drop side\n          if (dropPosition === \"left\") {\n            newChildren.splice(adjustedTargetIndex, 0, draggedItem)\n          } else {\n            // \"right\"\n            newChildren.splice(adjustedTargetIndex + 1, 0, draggedItem)\n          }\n\n          // Update the container with new order (single action for history)\n          dispatch(\n            EditorActions.updateNode(parent.id, {\n              children: newChildren as any,\n            })\n          )\n\n          toast({\n            title: \"Image repositioned!\",\n            description: \"Image order updated in flex layout\",\n          })\n\n          setDragOverNodeId(null)\n          setDropPosition(null)\n          setDraggingNodeId(null)\n          return\n        }\n\n        // Case 2: Merging two separate images into a flex container (or adding to existing one)\n        if (isTextNode(draggingNode) && isTextNode(targetNode)) {\n          // If one of them is already in a flex container, add the dragged one to it\n          if (\n            draggingResult.parentId &&\n            draggingResult.parent?.attributes?.layoutType === \"flex\"\n          ) {\n            // Dragging node is in a flex container, extract it and merge with target\n          } else if (\n            targetResult.parentId &&\n            targetResult.parent?.attributes?.layoutType === \"flex\"\n          ) {\n            // Target is in flex container, add dragged node to it\n            const parent = targetResult.parent\n            const targetIndex = parent.children.findIndex(\n              (c) => c.id === nodeId\n            )\n            const newChildren = [...parent.children]\n\n            // Insert dragged node at the appropriate position\n            if (dropPosition === \"left\") {\n              newChildren.splice(targetIndex, 0, draggingNode as TextNode)\n            } else {\n              newChildren.splice(targetIndex + 1, 0, draggingNode as TextNode)\n            }\n\n            // Batch: delete from old location and update container (single history entry)\n            dispatch(\n              EditorActions.batch([\n                EditorActions.deleteNode(draggingNodeId),\n                EditorActions.updateNode(parent.id, {\n                  children: newChildren as any,\n                }),\n              ])\n            )\n\n            toast({\n              title: \"Image added!\",\n              description: \"Image added to the flex layout\",\n            })\n\n            setDragOverNodeId(null)\n            setDropPosition(null)\n            setDraggingNodeId(null)\n            return\n          }\n\n          // Neither is in a flex container - create a new one\n\n          // Find reference nodes at root level\n          const targetRootIndex = container.children.findIndex(\n            (n) =>\n              n.id === nodeId ||\n              (isContainerNode(n) &&\n                (n as ContainerNode).children.some((c) => c.id === nodeId))\n          )\n          const draggingRootIndex = container.children.findIndex(\n            (n) =>\n              n.id === draggingNodeId ||\n              (isContainerNode(n) &&\n                (n as ContainerNode).children.some(\n                  (c) => c.id === draggingNodeId\n                ))\n          )\n\n          // Find a stable reference node for insertion\n          let referenceNodeId: string | null = null\n          let insertPosition: \"before\" | \"after\" = \"after\"\n\n          const firstIndex = Math.min(targetRootIndex, draggingRootIndex)\n          if (firstIndex > 0) {\n            referenceNodeId = container.children[firstIndex - 1].id\n            insertPosition = \"after\"\n          } else if (container.children.length > 2) {\n            for (let i = 0; i < container.children.length; i++) {\n              if (i !== targetRootIndex && i !== draggingRootIndex) {\n                referenceNodeId = container.children[i].id\n                insertPosition = i < firstIndex ? \"after\" : \"before\"\n                break\n              }\n            }\n          }\n\n          // Create a flex container with both images\n          const timestamp = Date.now()\n          const flexContainer: ContainerNode = {\n            id: `flex-container-${timestamp}`,\n            type: \"container\",\n            children:\n              dropPosition === \"left\"\n                ? [draggingNode as TextNode, targetNode as TextNode]\n                : [targetNode as TextNode, draggingNode as TextNode],\n            attributes: {\n              layoutType: \"flex\",\n              gap: \"4\",\n            },\n          }\n\n          // Batch: delete both images and insert flex container (single history entry)\n          const actions: any[] = [\n            EditorActions.deleteNode(draggingNodeId),\n            EditorActions.deleteNode(nodeId),\n          ]\n\n          if (referenceNodeId) {\n            actions.push(\n              EditorActions.insertNode(\n                flexContainer,\n                referenceNodeId,\n                insertPosition\n              )\n            )\n          } else {\n            actions.push(\n              EditorActions.replaceContainer({\n                ...container,\n                children: [flexContainer],\n              })\n            )\n          }\n\n          dispatch(EditorActions.batch(actions))\n\n          toast({\n            title: \"Images merged!\",\n            description: \"Images placed side by side in a flex layout\",\n          })\n\n          setDragOverNodeId(null)\n          setDropPosition(null)\n          setDraggingNodeId(null)\n          return\n        }\n      }\n\n      // Vertical drop - extract from container or move at root level\n\n      // If the dragging node is in a flex container, we need to extract it\n      if (draggingResult.parentId && draggingResult.parent) {\n        console.log(\"🔍 DEBUG: Extracting from flex container\")\n        console.log(\"  Dragging node ID:\", draggingNodeId)\n        console.log(\"  Target node ID:\", nodeId)\n        console.log(\"  Drop position:\", dropPosition)\n        console.log(\"  Parent container ID:\", draggingResult.parentId)\n\n        const parent = draggingResult.parent\n        const remainingChildren = parent.children.filter(\n          (c) => c.id !== draggingNodeId\n        )\n\n        console.log(\"  Parent children count:\", parent.children.length)\n        console.log(\"  Remaining children count:\", remainingChildren.length)\n\n        const insertPos =\n          dropPosition === \"before\" || dropPosition === \"after\"\n            ? dropPosition\n            : \"after\"\n\n        // Batch all actions for single history entry\n        const actions: any[] = []\n\n        // If only one child remains, unwrap the container\n        if (remainingChildren.length === 1) {\n          console.log(\"  ⚠️ Only 1 child remaining - unwrapping container\")\n          // Find where to insert the remaining child\n          const parentIndex = container.children.findIndex(\n            (c) => c.id === parent.id\n          )\n\n          console.log(\"  Parent index in container:\", parentIndex)\n          console.log(\"  Container children count:\", container.children.length)\n\n          // Check if target is the flex container itself\n          const isTargetTheFlexContainer = nodeId === parent.id\n          console.log(\n            \"  Is target the flex container?\",\n            isTargetTheFlexContainer\n          )\n\n          if (isTargetTheFlexContainer) {\n            // We're trying to drop on the flex container itself\n            // We need to find a better reference point\n            let referenceNodeId: string | null = null\n            let referencePosition: \"before\" | \"after\" =\n              insertPos === \"before\" ? \"before\" : \"after\"\n\n            if (parentIndex > 0) {\n              // Use the previous sibling\n              referenceNodeId = container.children[parentIndex - 1].id\n              referencePosition = \"after\"\n            } else if (parentIndex < container.children.length - 1) {\n              // Use the next sibling\n              referenceNodeId = container.children[parentIndex + 1].id\n              referencePosition = \"before\"\n            }\n\n            if (referenceNodeId) {\n              console.log(\n                \"  Using alternative reference:\",\n                referenceNodeId,\n                referencePosition\n              )\n\n              // Insert remaining child first (it will replace the flex container position)\n              console.log(\n                \"  Action 1: Insert remaining child\",\n                referencePosition,\n                referenceNodeId\n              )\n              actions.push(\n                EditorActions.insertNode(\n                  remainingChildren[0],\n                  referenceNodeId,\n                  referencePosition\n                )\n              )\n\n              // Now insert the dragged node next to the remaining child\n              console.log(\n                \"  Action 2: Insert dragged node\",\n                insertPos,\n                \"remaining child\"\n              )\n              actions.push(\n                EditorActions.insertNode(\n                  draggingNode,\n                  remainingChildren[0].id,\n                  insertPos\n                )\n              )\n\n              // Delete the flex container (which also removes dragging node)\n              console.log(\"  Action 3: Delete flex container:\", parent.id)\n              actions.push(EditorActions.deleteNode(parent.id))\n            } else {\n              // Fallback: no siblings, use container\n              console.log(\"  No siblings found - using container as reference\")\n              actions.push(\n                EditorActions.insertNode(\n                  remainingChildren[0],\n                  container.id,\n                  \"append\"\n                )\n              )\n              actions.push(\n                EditorActions.insertNode(\n                  draggingNode,\n                  remainingChildren[0].id,\n                  insertPos\n                )\n              )\n              actions.push(EditorActions.deleteNode(parent.id))\n            }\n          } else {\n            // Target is NOT the flex container - normal case\n\n            // Check if the target node is right before or after the flex container\n            const targetIndex = container.children.findIndex(\n              (c) => c.id === nodeId\n            )\n            const isTargetBeforeFlex =\n              targetIndex === parentIndex - 1 && insertPos === \"after\"\n            const isTargetAfterFlex =\n              targetIndex === parentIndex + 1 && insertPos === \"before\"\n\n            console.log(\"  Target index:\", targetIndex)\n            console.log(\"  Is target before flex?\", isTargetBeforeFlex)\n            console.log(\"  Is target after flex?\", isTargetAfterFlex)\n\n            if (isTargetBeforeFlex || isTargetAfterFlex) {\n              // We're inserting right next to where the flex container is\n              // Need to be careful about ordering\n              console.log(\"  ⚠️ Inserting adjacent to flex container\")\n\n              // Insert dragged node at the target position\n              console.log(\n                \"  Action 1: Insert dragged node\",\n                draggingNodeId,\n                insertPos,\n                \"target:\",\n                nodeId\n              )\n              actions.push(\n                EditorActions.insertNode(draggingNode, nodeId, insertPos)\n              )\n\n              // Insert remaining child next to the dragged node (maintaining order)\n              if (isTargetBeforeFlex) {\n                // Inserting before flex, so remaining child should be after dragged node\n                console.log(\n                  \"  Action 2: Insert remaining child after dragged node\"\n                )\n                actions.push(\n                  EditorActions.insertNode(\n                    remainingChildren[0],\n                    draggingNodeId,\n                    \"after\"\n                  )\n                )\n              } else {\n                // Inserting after flex, so remaining child should be before dragged node\n                console.log(\n                  \"  Action 2: Insert remaining child before dragged node\"\n                )\n                actions.push(\n                  EditorActions.insertNode(\n                    remainingChildren[0],\n                    draggingNodeId,\n                    \"before\"\n                  )\n                )\n              }\n\n              // Delete the flex container (also removes old dragged node reference)\n              console.log(\"  Action 3: Delete flex container:\", parent.id)\n              actions.push(EditorActions.deleteNode(parent.id))\n            } else {\n              // Target is somewhere else - use standard logic\n              console.log(\"  Standard extraction (target not adjacent)\")\n\n              // Insert dragged node at new position first\n              console.log(\n                \"  Action 1: Insert dragged node\",\n                draggingNodeId,\n                insertPos,\n                \"target:\",\n                nodeId\n              )\n              actions.push(\n                EditorActions.insertNode(draggingNode, nodeId, insertPos)\n              )\n\n              // Delete the dragging node from flex\n              console.log(\n                \"  Action 2: Delete dragged node from original position\"\n              )\n              actions.push(EditorActions.deleteNode(draggingNodeId))\n\n              // Insert remaining child where the flex container was\n              if (parentIndex > 0) {\n                const prevNode = container.children[parentIndex - 1]\n                console.log(\n                  \"  Action 3: Insert remaining child after prevNode:\",\n                  prevNode.id\n                )\n                actions.push(\n                  EditorActions.insertNode(\n                    remainingChildren[0],\n                    prevNode.id,\n                    \"after\"\n                  )\n                )\n              } else if (parentIndex === 0 && container.children.length > 1) {\n                const nextNode = container.children[1]\n                console.log(\n                  \"  Action 3: Insert remaining child before nextNode:\",\n                  nextNode.id\n                )\n                actions.push(\n                  EditorActions.insertNode(\n                    remainingChildren[0],\n                    nextNode.id,\n                    \"before\"\n                  )\n                )\n              } else {\n                // Only the flex container exists, just insert at root\n                console.log(\"  Action 3: Append remaining child to container\")\n                actions.push(\n                  EditorActions.insertNode(\n                    remainingChildren[0],\n                    container.id,\n                    \"append\"\n                  )\n                )\n              }\n\n              // Delete the flex container\n              console.log(\"  Action 4: Delete flex container:\", parent.id)\n              actions.push(EditorActions.deleteNode(parent.id))\n            }\n          }\n        } else {\n          console.log(\"  ✓ Multiple children remain - updating container\")\n          // Multiple children remain, just update the flex container\n          actions.push(\n            EditorActions.updateNode(parent.id, {\n              children: remainingChildren as any,\n            })\n          )\n\n          // Insert dragged node at new position\n          console.log(\n            \"  Action: Insert dragged node\",\n            draggingNodeId,\n            insertPos,\n            \"target:\",\n            nodeId\n          )\n          actions.push(\n            EditorActions.insertNode(draggingNode, nodeId, insertPos)\n          )\n        }\n\n        console.log(\"  📦 Total actions:\", actions.length)\n\n        actions.push(EditorActions.setActiveNode(draggingNodeId))\n\n        dispatch(EditorActions.batch(actions))\n\n        toast({\n          title: \"Image moved!\",\n          description: \"Image extracted and repositioned\",\n        })\n\n        setDragOverNodeId(null)\n        setDropPosition(null)\n        setDraggingNodeId(null)\n        return\n      }\n\n      // Standard move at root level\n      const draggingNodeAtRoot = container.children.find(\n        (n) => n.id === draggingNodeId\n      )\n\n      if (draggingNodeAtRoot) {\n        const targetNodeAtRoot = container.children.find((n) => n.id === nodeId)\n\n        // Check if both are at root level and not images - use swap for blocks\n        const isDraggingImage =\n          isTextNode(draggingNode) && (draggingNode as TextNode).type === \"img\"\n        const isTargetImage =\n          targetNodeAtRoot &&\n          isTextNode(targetNodeAtRoot) &&\n          (targetNodeAtRoot as TextNode).type === \"img\"\n\n        // Use swap for non-image blocks, use move for images\n        if (!isDraggingImage && !isTargetImage && targetNodeAtRoot) {\n          dispatch(EditorActions.swapNodes(draggingNodeId, nodeId))\n          dispatch(EditorActions.setActiveNode(draggingNodeId))\n\n          toast({\n            title: \"Blocks swapped!\",\n            description: \"Block positions exchanged\",\n          })\n        } else {\n          // Convert dropPosition to valid InsertPosition\n          const insertPos =\n            dropPosition === \"before\" || dropPosition === \"after\"\n              ? dropPosition\n              : \"after\"\n\n          dispatch(EditorActions.moveNode(draggingNodeId, nodeId, insertPos))\n          dispatch(EditorActions.setActiveNode(draggingNodeId))\n\n          toast({\n            title: isDraggingImage ? \"Image moved!\" : \"Block moved!\",\n            description: `${isDraggingImage ? \"Image\" : \"Block\"} repositioned ${dropPosition} the block`,\n          })\n        }\n      }\n\n      setDragOverNodeId(null)\n      setDropPosition(null)\n      setDraggingNodeId(null)\n      return\n    }\n\n    // Otherwise, handle file upload\n\n    // Try to get files from dataTransfer\n    let files: File[] = []\n\n    if (e.dataTransfer.items) {\n      // Use DataTransferItemList interface\n      const items = Array.from(e.dataTransfer.items)\n      files = items\n        .filter((item) => item.kind === \"file\")\n        .map((item) => item.getAsFile())\n        .filter((file): file is File => file !== null)\n    } else {\n      // Use DataTransferList interface\n      files = Array.from(e.dataTransfer.files)\n    }\n\n    const imageFile = files.find((file) => file.type.startsWith(\"image/\"))\n\n    if (!imageFile) {\n      setDragOverNodeId(null)\n      setDropPosition(null)\n      setDraggingNodeId(null)\n      return\n    }\n\n    setIsUploading(true)\n\n    try {\n      // Use custom upload handler if provided, otherwise use default\n      let imageUrl: string\n\n      if (onUploadImage) {\n        imageUrl = await onUploadImage(imageFile)\n      } else {\n        const result = await uploadImage(imageFile)\n        if (!result.success || !result.url) {\n          throw new Error(result.error || \"Upload failed\")\n        }\n        imageUrl = result.url\n      }\n\n      const imageNode: TextNode = {\n        id: \"img-\" + Date.now(),\n        type: \"img\",\n        content: \"\", // Optional caption\n        attributes: {\n          src: imageUrl,\n          alt: imageFile.name,\n        },\n      }\n\n      // Insert at the determined position\n      // Convert dropPosition to valid InsertPosition\n      const insertPos =\n        dropPosition === \"before\" || dropPosition === \"after\"\n          ? dropPosition\n          : \"after\"\n\n      dispatch(EditorActions.insertNode(imageNode, nodeId, insertPos))\n      dispatch(EditorActions.setActiveNode(imageNode.id))\n\n      toast({\n        title: \"Image uploaded!\",\n        description: `Image placed ${dropPosition} the block`,\n      })\n    } catch (error) {\n      toast({\n        variant: \"destructive\",\n        title: \"Upload failed\",\n        description:\n          error instanceof Error\n            ? error.message\n            : \"Failed to upload image. Please try again.\",\n      })\n    } finally {\n      setIsUploading(false)\n      setDragOverNodeId(null)\n      setDropPosition(null)\n      setDraggingNodeId(null)\n    }\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/file-upload-handlers.ts",
      "content": "/**\n * File Upload Handler Functions\n *\n * Functions for handling file uploads in the editor\n */\n\nimport { EditorActions } from \"../reducer/actions\"\nimport { ContainerNode, TextNode } from \"../types\"\nimport { uploadImage } from \"../utils/image-upload\"\n\nexport interface FileUploadHandlerParams {\n  container: ContainerNode\n  dispatch: React.Dispatch<any>\n  state: any\n  toast: any\n  setIsUploading: (uploading: boolean) => void\n  fileInputRef: React.RefObject<HTMLInputElement | null>\n  multipleFileInputRef: React.RefObject<HTMLInputElement | null>\n  onUploadImage?: (file: File) => Promise<string>\n}\n\n/**\n * Handle single file change\n */\nexport function createHandleFileChange(params: FileUploadHandlerParams) {\n  return async (e: React.ChangeEvent<HTMLInputElement>) => {\n    const {\n      container,\n      dispatch,\n      state,\n      toast,\n      setIsUploading,\n      fileInputRef,\n      onUploadImage,\n    } = params\n    const file = e.target.files?.[0]\n    if (!file) return\n\n    setIsUploading(true)\n\n    try {\n      // Use custom upload handler if provided, otherwise use default\n      let imageUrl: string\n\n      if (onUploadImage) {\n        imageUrl = await onUploadImage(file)\n      } else {\n        const result = await uploadImage(file)\n        if (!result.success || !result.url) {\n          throw new Error(result.error || \"Upload failed\")\n        }\n        imageUrl = result.url\n      }\n\n      // Create new image node\n      const imageNode: TextNode = {\n        id: \"img-\" + Date.now(),\n        type: \"img\",\n        content: \"\", // Optional caption\n        attributes: {\n          src: imageUrl,\n          alt: file.name,\n        },\n      }\n\n      // Insert image after current node or at end\n      const targetId =\n        state.activeNodeId ||\n        container.children[container.children.length - 1]?.id\n      if (targetId) {\n        dispatch(EditorActions.insertNode(imageNode, targetId, \"after\"))\n      } else {\n        dispatch(EditorActions.insertNode(imageNode, container.id, \"append\"))\n      }\n\n      toast({\n        title: \"Image uploaded\",\n        description: \"Your image has been added to the editor.\",\n      })\n    } catch (error) {\n      toast({\n        variant: \"destructive\",\n        title: \"Upload failed\",\n        description:\n          error instanceof Error\n            ? error.message\n            : \"An unexpected error occurred\",\n      })\n    } finally {\n      setIsUploading(false)\n      // Reset file input\n      if (fileInputRef.current) {\n        fileInputRef.current.value = \"\"\n      }\n    }\n  }\n}\n\n/**\n * Handle multiple files change\n */\nexport function createHandleMultipleFilesChange(\n  params: FileUploadHandlerParams\n) {\n  return async (e: React.ChangeEvent<HTMLInputElement>) => {\n    const {\n      container,\n      dispatch,\n      state,\n      toast,\n      setIsUploading,\n      multipleFileInputRef,\n      onUploadImage,\n    } = params\n    const files = Array.from(e.target.files || [])\n    if (files.length === 0) return\n\n    setIsUploading(true)\n\n    try {\n      // Upload all images\n      const uploadPromises = files.map(async (file) => {\n        if (onUploadImage) {\n          return await onUploadImage(file)\n        } else {\n          const result = await uploadImage(file)\n          if (!result.success || !result.url) {\n            throw new Error(result.error || \"Upload failed\")\n          }\n          return result.url\n        }\n      })\n\n      const imageUrls = await Promise.all(uploadPromises)\n\n      // Create image nodes\n      const timestamp = Date.now()\n      const imageNodes: TextNode[] = imageUrls.map((url, index) => ({\n        id: `img-${timestamp}-${index}`,\n        type: \"img\",\n        content: \"\",\n        attributes: {\n          src: url,\n          alt: files[index].name,\n        },\n      }))\n\n      // Create flex container with images\n      const flexContainer: ContainerNode = {\n        id: `flex-container-${timestamp}`,\n        type: \"container\",\n        children: imageNodes,\n        attributes: {\n          layoutType: \"flex\",\n          gap: \"4\",\n          flexWrap: \"wrap\", // Enable wrapping\n        },\n      }\n\n      // Insert the flex container after current node or at end\n      const targetId =\n        state.activeNodeId ||\n        container.children[container.children.length - 1]?.id\n      if (targetId) {\n        dispatch(EditorActions.insertNode(flexContainer, targetId, \"after\"))\n      } else {\n        dispatch(\n          EditorActions.insertNode(flexContainer, container.id, \"append\")\n        )\n      }\n\n      toast({\n        title: \"Images uploaded\",\n        description: `${imageUrls.length} images added in a flex layout.`,\n      })\n    } catch (error) {\n      toast({\n        variant: \"destructive\",\n        title: \"Upload failed\",\n        description:\n          error instanceof Error\n            ? error.message\n            : \"An unexpected error occurred\",\n      })\n    } finally {\n      setIsUploading(false)\n      // Reset file input\n      if (multipleFileInputRef.current) {\n        multipleFileInputRef.current.value = \"\"\n      }\n    }\n  }\n}\n\n/**\n * Handle image upload click\n */\nexport function createHandleImageUploadClick(\n  fileInputRef: React.RefObject<HTMLInputElement | null>\n) {\n  return () => {\n    fileInputRef.current?.click()\n  }\n}\n\n/**\n * Handle multiple images upload click\n */\nexport function createHandleMultipleImagesUploadClick(\n  multipleFileInputRef: React.RefObject<HTMLInputElement | null>\n) {\n  return () => {\n    multipleFileInputRef.current?.click()\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/flex-container-handlers.ts",
      "content": "/**\n * Flex Container Drag-and-Drop Handlers\n *\n * Handles drag and drop operations for flex containers\n */\n\nimport { EditorActions } from \"../reducer/actions\"\nimport { ContainerNode, isTextNode, TextNode } from \"../types\"\nimport { findNodeAnywhere } from \"../utils/editor-helpers\"\n\nexport interface FlexContainerHandlerParams {\n  container: ContainerNode\n  dispatch: React.Dispatch<any>\n  toast: any\n  draggingNodeId: string | null\n  setDragOverFlexId: (id: string | null) => void\n  setFlexDropPosition: (pos: \"left\" | \"right\" | null) => void\n}\n\n/**\n * Handle drag over on flex container edges\n */\nexport function createHandleFlexContainerDragOver(\n  params: FlexContainerHandlerParams\n) {\n  return (\n    e: React.DragEvent,\n    flexContainerId: string,\n    position: \"left\" | \"right\" | null\n  ) => {\n    const {\n      container,\n      draggingNodeId,\n      setDragOverFlexId,\n      setFlexDropPosition,\n    } = params\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    // Check if we're dragging something\n    const draggedNodeId = e.dataTransfer.getData(\"text/plain\")\n    if (!draggedNodeId && !draggingNodeId) {\n      return\n    }\n\n    const actualDraggingId = draggingNodeId || draggedNodeId\n\n    // Find the dragging node\n    const draggingResult = actualDraggingId\n      ? findNodeAnywhere(actualDraggingId, container)\n      : null\n\n    if (!draggingResult || !isTextNode(draggingResult.node)) {\n      // Not a valid node to drag\n      setDragOverFlexId(null)\n      setFlexDropPosition(null)\n      return\n    }\n\n    const draggingNode = draggingResult.node as TextNode\n\n    // Only allow image nodes\n    if (draggingNode.type !== \"img\") {\n      setDragOverFlexId(null)\n      setFlexDropPosition(null)\n      return\n    }\n\n    // Check if we're in the edge zones\n    if (position) {\n      setDragOverFlexId(flexContainerId)\n      setFlexDropPosition(position)\n      e.dataTransfer.dropEffect = \"move\"\n    } else {\n      setDragOverFlexId(null)\n      setFlexDropPosition(null)\n    }\n  }\n}\n\n/**\n * Handle drag leave on flex container\n */\nexport function createHandleFlexContainerDragLeave(\n  setDragOverFlexId: (id: string | null) => void,\n  setFlexDropPosition: (pos: \"left\" | \"right\" | null) => void\n) {\n  return (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragOverFlexId(null)\n    setFlexDropPosition(null)\n  }\n}\n\n/**\n * Handle drop on flex container edges\n */\nexport function createHandleFlexContainerDrop(\n  params: FlexContainerHandlerParams\n) {\n  return (\n    e: React.DragEvent,\n    flexContainerId: string,\n    position: \"left\" | \"right\" | null\n  ) => {\n    const {\n      container,\n      dispatch,\n      toast,\n      draggingNodeId,\n      setDragOverFlexId,\n      setFlexDropPosition,\n    } = params\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    console.log(\"🎯 Flex Container Drop\")\n    console.log(\"  Flex Container ID:\", flexContainerId)\n    console.log(\"  Drop Position:\", position)\n    console.log(\"  Dragging Node ID:\", draggingNodeId)\n\n    if (!position || !draggingNodeId) {\n      setDragOverFlexId(null)\n      setFlexDropPosition(null)\n      return\n    }\n\n    // Find the dragging node and the flex container\n    const draggingResult = findNodeAnywhere(draggingNodeId, container)\n    const flexResult = findNodeAnywhere(flexContainerId, container)\n\n    if (!draggingResult || !flexResult) {\n      console.log(\"  ❌ Could not find nodes\")\n      setDragOverFlexId(null)\n      setFlexDropPosition(null)\n      return\n    }\n\n    const draggingNode = draggingResult.node as TextNode\n    const flexContainer = flexResult.node as ContainerNode\n\n    // Only handle image nodes\n    if (draggingNode.type !== \"img\") {\n      console.log(\"  ❌ Not an image node\")\n      setDragOverFlexId(null)\n      setFlexDropPosition(null)\n      return\n    }\n\n    // Check if the dragging node is already in this flex container\n    const isInSameContainer = draggingResult.parentId === flexContainerId\n\n    console.log(\"  Is in same container:\", isInSameContainer)\n\n    if (isInSameContainer) {\n      // Case 1: Reordering within the same flex container\n      console.log(\"  📝 Reordering within same container\")\n\n      const currentIndex = flexContainer.children.findIndex(\n        (c) => c.id === draggingNodeId\n      )\n      const newChildren = [...flexContainer.children]\n\n      // Remove from current position\n      const [movedNode] = newChildren.splice(currentIndex, 1)\n\n      // Insert at new position\n      if (position === \"left\") {\n        newChildren.unshift(movedNode)\n        console.log(\"  Moving to start\")\n      } else {\n        newChildren.push(movedNode)\n        console.log(\"  Moving to end\")\n      }\n\n      dispatch(\n        EditorActions.updateNode(flexContainerId, {\n          children: newChildren as any,\n        })\n      )\n\n      toast({\n        title: \"Image repositioned!\",\n        description: \"Image moved within the flex container\",\n      })\n    } else {\n      // Case 2: Adding image from outside to the flex container\n      console.log(\"  ➕ Adding image to container\")\n\n      const newChildren = [...flexContainer.children]\n\n      if (position === \"left\") {\n        newChildren.unshift(draggingNode)\n        console.log(\"  Adding to start\")\n      } else {\n        newChildren.push(draggingNode)\n        console.log(\"  Adding to end\")\n      }\n\n      // Batch: delete from old location and update container\n      const actions = [\n        EditorActions.deleteNode(draggingNodeId),\n        EditorActions.updateNode(flexContainerId, {\n          children: newChildren as any,\n        }),\n      ]\n\n      dispatch(EditorActions.batch(actions))\n\n      toast({\n        title: \"Image added!\",\n        description: \"Image added to the flex container\",\n      })\n    }\n\n    setDragOverFlexId(null)\n    setFlexDropPosition(null)\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/image-selection-handlers.ts",
      "content": "/**\n * Image Selection Handler Functions\n *\n * Functions for handling multi-image selection and flex container creation\n */\n\nimport { EditorActions } from \"../reducer/actions\"\nimport { ContainerNode, TextNode } from \"../types\"\nimport { findNodeAnywhere } from \"../utils/editor-helpers\"\n\nexport interface ImageSelectionHandlerParams {\n  container: ContainerNode\n  dispatch: React.Dispatch<any>\n  toast: any\n}\n\n/**\n * Create flex container from selected images\n */\nexport function createHandleGroupSelectedImages(\n  params: ImageSelectionHandlerParams,\n  selectedImageIds: Set<string>,\n  clearSelection: () => void\n) {\n  return () => {\n    const { container, dispatch, toast } = params\n\n    if (selectedImageIds.size < 2) {\n      toast({\n        variant: \"destructive\",\n        title: \"Not enough images\",\n        description: \"Please select at least 2 images to group\",\n      })\n      return\n    }\n\n    // Find all selected image nodes\n    const imageNodes: TextNode[] = []\n    const imageResults = []\n\n    for (const imageId of selectedImageIds) {\n      const result = findNodeAnywhere(imageId, container)\n      if (result && result.node.type === \"img\") {\n        imageNodes.push(result.node as TextNode)\n        imageResults.push(result)\n      }\n    }\n\n    if (imageNodes.length < 2) {\n      toast({\n        variant: \"destructive\",\n        title: \"Invalid selection\",\n        description: \"Could not find all selected images\",\n      })\n      return\n    }\n\n    // Check if images are in different flex containers - we can't group them\n    const parentIds = new Set(\n      imageResults.map((r) => r.parentId).filter(Boolean)\n    )\n    const hasFlexParent = imageResults.some(\n      (r) => r.parent && r.parent.attributes?.layoutType === \"flex\"\n    )\n\n    // Find the position to insert the new flex container\n    // Use the position of the first selected image (topmost in the document)\n    let referenceNodeId: string | null = null\n    let insertPosition: \"before\" | \"after\" = \"after\"\n\n    // Find the first image in the root container\n    for (const child of container.children) {\n      if (selectedImageIds.has(child.id)) {\n        // Found the first selected image at root level\n        const index = container.children.indexOf(child)\n        if (index > 0) {\n          referenceNodeId = container.children[index - 1].id\n          insertPosition = \"after\"\n        } else if (container.children.length > imageNodes.length) {\n          // Find a non-selected node to use as reference\n          const nextNonSelected = container.children.find(\n            (c) => !selectedImageIds.has(c.id)\n          )\n          if (nextNonSelected) {\n            referenceNodeId = nextNonSelected.id\n            insertPosition = \"before\"\n          }\n        }\n        break\n      }\n    }\n\n    // Create a flex container with all selected images\n    const timestamp = Date.now()\n    const flexContainer: ContainerNode = {\n      id: `flex-container-${timestamp}`,\n      type: \"container\",\n      children: imageNodes,\n      attributes: {\n        layoutType: \"flex\",\n        gap: \"4\",\n        flexWrap: \"wrap\",\n      },\n    }\n\n    // Batch: delete all selected images and insert flex container\n    const actions: any[] = []\n\n    // Delete all selected images\n    for (const imageId of selectedImageIds) {\n      actions.push(EditorActions.deleteNode(imageId))\n    }\n\n    // Insert the flex container\n    if (referenceNodeId) {\n      actions.push(\n        EditorActions.insertNode(flexContainer, referenceNodeId, insertPosition)\n      )\n    } else {\n      // If no reference node, replace entire container\n      actions.push(\n        EditorActions.replaceContainer({\n          ...container,\n          children: [flexContainer],\n        })\n      )\n    }\n\n    dispatch(EditorActions.batch(actions))\n\n    toast({\n      title: \"Images grouped!\",\n      description: `${imageNodes.length} images placed in a flex layout`,\n    })\n\n    clearSelection()\n  }\n}\n\n/**\n * Toggle image selection\n */\nexport function createHandleToggleImageSelection(\n  selectedImageIds: Set<string>,\n  setSelectedImageIds: (ids: Set<string>) => void\n) {\n  return (imageId: string) => {\n    const newSelection = new Set(selectedImageIds)\n    if (newSelection.has(imageId)) {\n      newSelection.delete(imageId)\n    } else {\n      newSelection.add(imageId)\n    }\n    setSelectedImageIds(newSelection)\n  }\n}\n\n/**\n * Clear all image selections\n */\nexport function createHandleClearImageSelection(\n  setSelectedImageIds: (ids: Set<string>) => void\n) {\n  return () => {\n    setSelectedImageIds(new Set())\n  }\n}\n\n/**\n * Check if selected images are in the same flex container\n */\nexport function checkImagesInSameFlex(\n  params: ImageSelectionHandlerParams,\n  selectedImageIds: Set<string>\n): { inSameFlex: boolean; flexParentId: string | null } {\n  const { container } = params\n\n  if (selectedImageIds.size < 2) {\n    return { inSameFlex: false, flexParentId: null }\n  }\n\n  const imageResults = []\n  for (const imageId of selectedImageIds) {\n    const result = findNodeAnywhere(imageId, container)\n    if (result && result.node.type === \"img\") {\n      imageResults.push(result)\n    }\n  }\n\n  // Check if all images have the same parent that is a flex container\n  const firstParentId = imageResults[0]?.parentId\n  const firstParent = imageResults[0]?.parent\n\n  if (\n    !firstParentId ||\n    !firstParent ||\n    firstParent.attributes?.layoutType !== \"flex\"\n  ) {\n    return { inSameFlex: false, flexParentId: null }\n  }\n\n  // Check all images have the same flex parent\n  const allSameParent = imageResults.every(\n    (r) =>\n      r.parentId === firstParentId &&\n      r.parent?.attributes?.layoutType === \"flex\"\n  )\n\n  return {\n    inSameFlex: allSameParent,\n    flexParentId: allSameParent ? firstParentId : null,\n  }\n}\n\n/**\n * Reverse order of selected images in flex container\n */\nexport function createHandleReverseImagesInFlex(\n  params: ImageSelectionHandlerParams,\n  selectedImageIds: Set<string>,\n  flexParentId: string\n) {\n  return () => {\n    const { container, dispatch, toast } = params\n\n    // Find the flex container\n    const flexResult = findNodeAnywhere(flexParentId, container)\n    if (!flexResult || flexResult.node.type !== \"container\") {\n      return\n    }\n\n    const flexContainer = flexResult.node as ContainerNode\n    const children = [...flexContainer.children]\n\n    // Separate selected and non-selected images\n    const selectedIndices: number[] = []\n    const selectedNodes: TextNode[] = []\n\n    children.forEach((child, index) => {\n      if (selectedImageIds.has(child.id)) {\n        selectedIndices.push(index)\n        selectedNodes.push(child as TextNode)\n      }\n    })\n\n    // Reverse only the selected images\n    selectedNodes.reverse()\n\n    // Put them back in their positions\n    selectedIndices.forEach((originalIndex, i) => {\n      children[originalIndex] = selectedNodes[i]\n    })\n\n    // Update the flex container\n    dispatch(\n      EditorActions.updateNode(flexParentId, {\n        children: children as any,\n      })\n    )\n\n    toast({\n      title: \"Images reversed!\",\n      description: `Order of ${selectedImageIds.size} images reversed`,\n    })\n  }\n}\n\n/**\n * Extract selected images from flex container\n */\nexport function createHandleExtractFromFlex(\n  params: ImageSelectionHandlerParams,\n  selectedImageIds: Set<string>,\n  flexParentId: string,\n  clearSelection: () => void\n) {\n  return () => {\n    const { container, dispatch, toast } = params\n\n    // Find the flex container\n    const flexResult = findNodeAnywhere(flexParentId, container)\n    if (!flexResult || flexResult.node.type !== \"container\") {\n      return\n    }\n\n    const flexContainer = flexResult.node as ContainerNode\n    const imagesToExtract: TextNode[] = []\n    const remainingChildren = flexContainer.children.filter((child) => {\n      if (selectedImageIds.has(child.id)) {\n        imagesToExtract.push(child as TextNode)\n        return false\n      }\n      return true\n    })\n\n    const actions: any[] = []\n\n    // If only one or no children remain, unwrap the flex container\n    if (remainingChildren.length <= 1) {\n      // Find the flex container's position in root\n      const flexIndex = container.children.findIndex(\n        (c) => c.id === flexParentId\n      )\n\n      if (flexIndex > 0) {\n        const prevNode = container.children[flexIndex - 1]\n\n        // Insert remaining child if exists\n        if (remainingChildren.length === 1) {\n          actions.push(\n            EditorActions.insertNode(remainingChildren[0], prevNode.id, \"after\")\n          )\n        }\n\n        // Insert extracted images\n        let lastNodeId =\n          remainingChildren.length === 1 ? remainingChildren[0].id : prevNode.id\n        imagesToExtract.forEach((image) => {\n          actions.push(EditorActions.insertNode(image, lastNodeId, \"after\"))\n          lastNodeId = image.id\n        })\n\n        // Delete the flex container\n        actions.push(EditorActions.deleteNode(flexParentId))\n      } else {\n        // First position - just delete flex and add all children\n        actions.push(EditorActions.deleteNode(flexParentId))\n\n        if (remainingChildren.length === 1) {\n          actions.push(\n            EditorActions.insertNode(\n              remainingChildren[0],\n              container.children[1]?.id || container.id,\n              container.children[1]?.id ? \"before\" : \"append\"\n            )\n          )\n        }\n\n        imagesToExtract.forEach((image) => {\n          actions.push(\n            EditorActions.insertNode(\n              image,\n              container.children[1]?.id || container.id,\n              container.children[1]?.id ? \"before\" : \"append\"\n            )\n          )\n        })\n      }\n    } else {\n      // Update flex container with remaining children\n      actions.push(\n        EditorActions.updateNode(flexParentId, {\n          children: remainingChildren as any,\n        })\n      )\n\n      // Insert extracted images after the flex container\n      let lastNodeId = flexParentId\n      imagesToExtract.forEach((image) => {\n        actions.push(EditorActions.insertNode(image, lastNodeId, \"after\"))\n        lastNodeId = image.id\n      })\n    }\n\n    dispatch(EditorActions.batch(actions))\n\n    toast({\n      title: \"Images extracted!\",\n      description: `${imagesToExtract.length} images removed from flex container`,\n    })\n\n    clearSelection()\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/keyboard-handlers.ts",
      "content": "/**\n * Keyboard Event Handlers\n *\n * Functions for handling keyboard events in the editor\n */\n\nimport { EditorActions } from \"../reducer/actions\"\nimport {\n  ContainerNode,\n  getNodeTextContent,\n  hasInlineChildren,\n  isTextNode,\n  TextNode,\n} from \"../types\"\nimport { findNodeInTree } from \"../utils/editor-helpers\"\n\nexport interface KeyboardHandlerParams {\n  container: ContainerNode\n  dispatch: React.Dispatch<any>\n  nodeRefs: React.MutableRefObject<Map<string, HTMLElement>>\n  lastEnterTime: React.MutableRefObject<number>\n  onToggleImageSelection?: (nodeId: string) => void\n}\n\n/**\n * Handle content change in a node\n */\nexport function createHandleContentChange(\n  params: KeyboardHandlerParams,\n  contentUpdateTimers: React.MutableRefObject<Map<string, NodeJS.Timeout>>\n) {\n  return (nodeId: string, element: HTMLElement) => {\n    const { container, dispatch } = params\n    const result = findNodeInTree(nodeId, container)\n    if (!result || !isTextNode(result.node)) return\n    const node = result.node as TextNode\n\n    const newContent = element.textContent || \"\"\n\n    // Get the current text content (from plain content or inline children)\n    const currentContent = getNodeTextContent(node)\n\n    // Only update if content actually changed\n    if (newContent !== currentContent) {\n      // Clear any existing timer for this node\n      const existingTimer = contentUpdateTimers.current.get(nodeId)\n      if (existingTimer) {\n        clearTimeout(existingTimer)\n      }\n\n      // Debounce the state update - only update after user stops typing for 150ms\n      const timer = setTimeout(() => {\n        // Auto-detect ordered list pattern: \"1. \", \"2. \", etc. (only with space)\n        const orderedListMatch = newContent.match(/^(\\d+)\\.\\s(.+)$/)\n\n        if (orderedListMatch && node.type === \"p\") {\n          // Convert to list item and remove only the number prefix\n          const [_, number, content] = orderedListMatch\n\n          dispatch(\n            EditorActions.updateNode(node.id, {\n              type: \"li\",\n              content: content,\n            })\n          )\n        } else if (\n          node.type === \"li\" &&\n          (node.lines || newContent.includes(\"\\n\"))\n        ) {\n          // List items with line breaks should always use lines structure\n          const textLines = newContent\n            .split(\"\\n\")\n            .filter((line) => line.trim() !== \"\")\n\n          if (textLines.length > 1) {\n            // Multiple lines - use lines structure\n            const updatedLines = textLines.map((lineText) => {\n              // Remove number prefix if present (e.g., \"1. text\" -> \"text\")\n              const cleanedText = lineText.replace(/^\\d+\\.\\s*/, \"\")\n              return { content: cleanedText }\n            })\n\n            dispatch(\n              EditorActions.updateNode(node.id, {\n                lines: updatedLines,\n                content: undefined, // Clear simple content\n                children: undefined, // Clear children\n              })\n            )\n          } else {\n            // Single line - use simple content\n            dispatch(EditorActions.updateContent(node.id, newContent))\n          }\n        } else if (!hasInlineChildren(node)) {\n          // Simple content node - just update the text\n          dispatch(EditorActions.updateContent(node.id, newContent))\n        } else {\n          // Node has inline children with formatting - parse DOM to preserve formatting\n          const {\n            parseDOMToInlineChildren,\n          } = require(\"../utils/editor-helpers\")\n          const parsedChildren = parseDOMToInlineChildren(element)\n\n          dispatch(\n            EditorActions.updateNode(node.id, {\n              children: parsedChildren,\n            })\n          )\n        }\n\n        // Clean up the timer reference\n        contentUpdateTimers.current.delete(nodeId)\n      }, 150)\n\n      // Store the timer reference\n      contentUpdateTimers.current.set(nodeId, timer)\n    }\n  }\n}\n\n/**\n * Handle click events with modifier keys (Ctrl/Cmd + Click)\n */\nexport function createHandleClickWithModifier(params: KeyboardHandlerParams) {\n  return (e: React.MouseEvent, nodeId: string) => {\n    const { container, onToggleImageSelection } = params\n\n    // Check if Ctrl (Windows/Linux) or Cmd (Mac) is pressed\n    const isCtrlOrCmd = e.ctrlKey || e.metaKey\n\n    if (isCtrlOrCmd && onToggleImageSelection) {\n      // Find the node to check if it's an image\n      const result = findNodeInTree(nodeId, container)\n      if (result && isTextNode(result.node)) {\n        const node = result.node as TextNode\n\n        // Only toggle selection for image nodes\n        if (node.type === \"img\") {\n          e.preventDefault()\n          e.stopPropagation()\n          onToggleImageSelection(nodeId)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Handle key down events\n */\nexport function createHandleKeyDown(params: KeyboardHandlerParams) {\n  return (e: React.KeyboardEvent<HTMLElement>, nodeId: string) => {\n    const { container, dispatch, nodeRefs, lastEnterTime } = params\n    // CRITICAL: Get the actual node ID from the DOM element's data attribute\n    // This ensures we get the correct ID for nested list items, not the container's ID\n    const actualNodeId =\n      (e.currentTarget as HTMLElement).getAttribute(\"data-node-id\") || nodeId\n\n    if (e.key === \"Enter\") {\n      const result = findNodeInTree(actualNodeId, container)\n      if (!result || !isTextNode(result.node)) {\n        return\n      }\n      const node = result.node as TextNode\n\n      // Shift+Enter: For list items, add a line break within the same item\n      // For other blocks, insert a line break within the block\n      if (e.shiftKey) {\n        // For list items (ul, ol, or li), just insert a line break within the same item\n        if (node.type === \"ul\" || node.type === \"ol\" || node.type === \"li\") {\n          // preventDefault is already called in Block.tsx\n\n          const selection = window.getSelection()\n          if (selection && selection.rangeCount > 0) {\n            const range = selection.getRangeAt(0)\n            range.deleteContents()\n            const br = document.createElement(\"br\")\n            range.insertNode(br)\n            range.setStartAfter(br)\n            range.collapse(true)\n            selection.removeAllRanges()\n            selection.addRange(range)\n\n            const element = nodeRefs.current.get(actualNodeId)\n            if (element) {\n              const {\n                createHandleContentChange,\n              } = require(\"./keyboard-handlers\")\n              // This would need contentUpdateTimers which is not available here\n              // So we need to pass it from the calling context\n            }\n          }\n        } else {\n          // For non-list items, just insert a line break within the block\n          e.preventDefault()\n          const selection = window.getSelection()\n          if (selection && selection.rangeCount > 0) {\n            const range = selection.getRangeAt(0)\n            range.deleteContents()\n            const br = document.createElement(\"br\")\n            range.insertNode(br)\n            range.setStartAfter(br)\n            range.collapse(true)\n            selection.removeAllRanges()\n            selection.addRange(range)\n\n            const element = nodeRefs.current.get(actualNodeId)\n            // Content change handling would be done by the parent\n          }\n        }\n\n        return\n      }\n\n      e.preventDefault()\n\n      const currentTime = Date.now()\n      const timeSinceLastEnter = currentTime - lastEnterTime.current\n\n      // Get cursor position\n      const selection = window.getSelection()\n      const element = nodeRefs.current.get(actualNodeId)\n\n      if (!element || !selection) return\n\n      // Calculate cursor position in text\n      let cursorPosition = 0\n      if (selection.rangeCount > 0) {\n        const range = selection.getRangeAt(0)\n        const preSelectionRange = range.cloneRange()\n        preSelectionRange.selectNodeContents(element)\n        preSelectionRange.setEnd(range.startContainer, range.startOffset)\n        cursorPosition = preSelectionRange.toString().length\n      }\n\n      // Get the full text content\n      const fullText = getNodeTextContent(node)\n\n      // Check if this is a list item (ul or ol)\n      if (node.type === \"ul\" || node.type === \"ol\" || node.type === \"li\") {\n        const listType = \"li\" // Always create li elements when pressing Enter in a list\n\n        // Split content at cursor position\n        const beforeCursor = fullText.substring(0, cursorPosition)\n        const afterCursor = fullText.substring(cursorPosition)\n\n        // If the current item is empty (no text before or after cursor), exit the list\n        if (!beforeCursor.trim() && !afterCursor.trim()) {\n          // Convert to paragraph and exit list\n          const newNode: TextNode = {\n            id: \"p-\" + Date.now(),\n            type: \"p\",\n            content: \"\",\n            attributes: {},\n          }\n\n          dispatch(EditorActions.deleteNode(actualNodeId))\n          dispatch(EditorActions.insertNode(newNode, actualNodeId, \"after\"))\n          dispatch(EditorActions.setActiveNode(newNode.id))\n\n          setTimeout(() => {\n            const newElement = nodeRefs.current.get(newNode.id)\n            if (newElement) {\n              newElement.focus()\n            }\n          }, 10)\n\n          return\n        }\n\n        // Create new list item after current one at the SAME LEVEL\n\n        // Update current node with content before cursor\n        dispatch(\n          EditorActions.updateNode(actualNodeId, {\n            content: beforeCursor,\n            children: undefined, // Clear inline formatting when splitting\n            lines: undefined, // Clear multiline structure\n          })\n        )\n\n        // Create new list item with content after cursor, same type as current\n        const newNode: TextNode = {\n          id: `${listType}-${Date.now()}`,\n          type: listType,\n          content: afterCursor,\n          attributes: {},\n        }\n\n        dispatch(EditorActions.insertNode(newNode, actualNodeId, \"after\"))\n        dispatch(EditorActions.setActiveNode(newNode.id))\n\n        lastEnterTime.current = currentTime\n\n        setTimeout(() => {\n          const newElement = nodeRefs.current.get(newNode.id)\n          if (newElement) {\n            newElement.focus()\n            const range = document.createRange()\n            const sel = window.getSelection()\n            if (newElement.childNodes.length > 0) {\n              const firstNode = newElement.childNodes[0]\n              range.setStart(firstNode, 0)\n              range.collapse(true)\n              sel?.removeAllRanges()\n              sel?.addRange(range)\n            }\n          }\n        }, 10)\n\n        return\n      }\n\n      // Regular paragraph/heading - create normal block\n      {\n        // Split content at cursor position\n        const beforeCursor = fullText.substring(0, cursorPosition)\n        const afterCursor = fullText.substring(cursorPosition)\n\n        // Check if node has inline children (formatted content)\n        const nodeHasInlineChildren = hasInlineChildren(node)\n\n        if (nodeHasInlineChildren && node.children) {\n          // Split inline children at cursor position\n          let currentPos = 0\n          const beforeChildren: typeof node.children = []\n          const afterChildren: typeof node.children = []\n          let splitDone = false\n\n          for (const child of node.children) {\n            const childLength = (child.content || \"\").length\n            const childStart = currentPos\n            const childEnd = currentPos + childLength\n\n            if (splitDone) {\n              // Everything after the split goes to the new node\n              afterChildren.push({ ...child })\n            } else if (cursorPosition <= childStart) {\n              // Cursor is before this child - entire child goes to new node\n              afterChildren.push({ ...child })\n              splitDone = true\n            } else if (cursorPosition >= childEnd) {\n              // Cursor is after this child - entire child stays in current node\n              beforeChildren.push({ ...child })\n            } else {\n              // Cursor is in the middle of this child - need to split it\n              const offsetInChild = cursorPosition - childStart\n\n              // Part before cursor stays in current node\n              if (offsetInChild > 0) {\n                beforeChildren.push({\n                  ...child,\n                  content: child.content!.substring(0, offsetInChild),\n                })\n              }\n\n              // Part after cursor goes to new node\n              if (offsetInChild < childLength) {\n                afterChildren.push({\n                  ...child,\n                  content: child.content!.substring(offsetInChild),\n                })\n              }\n\n              splitDone = true\n            }\n\n            currentPos = childEnd\n          }\n\n          // Update current node with children before cursor\n          dispatch(\n            EditorActions.updateNode(actualNodeId, {\n              children: beforeChildren.length > 0 ? beforeChildren : undefined,\n              content:\n                beforeChildren.length === 0 ? beforeCursor : node.content,\n            })\n          )\n\n          // Create new node with children after cursor (deep copy with all properties)\n          const newNode: TextNode = {\n            id: `${node.type}-` + Date.now(),\n            type: node.type,\n            content: afterChildren.length === 0 ? afterCursor : node.content,\n            children: afterChildren.length > 0 ? afterChildren : undefined,\n            attributes: { ...node.attributes },\n          }\n\n          dispatch(EditorActions.insertNode(newNode, actualNodeId, \"after\"))\n          dispatch(EditorActions.setActiveNode(newNode.id))\n        } else {\n          // Simple case: no inline children, just plain text\n          // Update current node with content before cursor\n          dispatch(\n            EditorActions.updateNode(actualNodeId, {\n              content: beforeCursor,\n            })\n          )\n\n          // Create new node with content after cursor (deep copy all properties)\n          const newNode: TextNode = {\n            id: `${node.type}-` + Date.now(),\n            type: node.type,\n            content: afterCursor,\n            attributes: { ...node.attributes },\n          }\n\n          dispatch(EditorActions.insertNode(newNode, actualNodeId, \"after\"))\n          dispatch(EditorActions.setActiveNode(newNode.id))\n        }\n\n        lastEnterTime.current = currentTime\n\n        // Focus the new node after a brief delay and place cursor at start\n        setTimeout(() => {\n          const newElement = nodeRefs.current.get(`${node.type}-` + currentTime)\n          if (newElement) {\n            newElement.focus()\n            // Place cursor at the start of the new node\n            const range = document.createRange()\n            const sel = window.getSelection()\n            if (newElement.childNodes.length > 0) {\n              const firstNode = newElement.childNodes[0]\n              range.setStart(firstNode, 0)\n              range.collapse(true)\n              sel?.removeAllRanges()\n              sel?.addRange(range)\n            }\n          }\n        }, 10)\n      }\n    } else if (e.key === \"Backspace\" || e.key === \"Delete\") {\n      const result = findNodeInTree(nodeId, container)\n      if (!result || !isTextNode(result.node)) return\n\n      const node = result.node as TextNode\n      const { siblings } = result\n\n      const selection = window.getSelection()\n      const cursorAtStart =\n        selection && selection.anchorOffset === 0 && selection.isCollapsed\n\n      // Get the full text content (handles both simple content and inline children)\n      const fullTextContent = getNodeTextContent(node)\n      const isNodeEmpty = !fullTextContent || fullTextContent.trim() === \"\"\n\n      // If cursor is at the start and node is empty or BR, delete the node\n      if ((cursorAtStart && isNodeEmpty) || node.type === \"br\") {\n        e.preventDefault()\n\n        const currentIndex = siblings.findIndex((n) => n.id === nodeId)\n\n        // Don't delete if it's the only node in the container\n        if (siblings.length === 1) {\n          // Just clear the content instead\n          if (hasInlineChildren(node)) {\n            dispatch(EditorActions.updateNode(node.id, { children: [] }))\n          } else if (node.content) {\n            dispatch(EditorActions.updateContent(node.id, \"\"))\n          }\n          return\n        }\n\n        // Count non-image blocks\n        const nonImageBlocks = siblings.filter((n) => {\n          if (!isTextNode(n)) return true // Container nodes are not images\n          return (n as TextNode).type !== \"img\"\n        })\n\n        // Don't delete if this is the last non-image block\n        if (nonImageBlocks.length === 1 && node.type !== \"img\") {\n          // Just clear the content instead\n          if (hasInlineChildren(node)) {\n            dispatch(EditorActions.updateNode(node.id, { children: [] }))\n          } else if (node.content) {\n            dispatch(EditorActions.updateContent(node.id, \"\"))\n          }\n          return\n        }\n\n        // Delete the current node\n        dispatch(EditorActions.deleteNode(nodeId))\n\n        // Focus the previous node if it exists, otherwise the next one\n        const prevNode = siblings[currentIndex - 1]\n        const nextNode = siblings[currentIndex + 1]\n        const nodeToFocus = prevNode || nextNode\n\n        if (nodeToFocus) {\n          dispatch(EditorActions.setActiveNode(nodeToFocus.id))\n        }\n      }\n    }\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/node-operation-handlers.ts",
      "content": "/**\n * Node Operation Handler Functions\n *\n * Functions for handling node operations (add, delete, create nested, etc.)\n */\n\nimport { EditorActions } from \"../reducer/actions\"\nimport {\n  ContainerNode,\n  EditorNode,\n  isContainerNode,\n  isTextNode,\n  StructuralNode,\n  TextNode,\n} from \"../types\"\nimport { findNodeInTree } from \"../utils/editor-helpers\"\n\nexport interface NodeOperationHandlerParams {\n  container: ContainerNode\n  dispatch: React.Dispatch<any>\n  toast: any\n  nodeRefs: React.MutableRefObject<Map<string, HTMLElement>>\n  editorContentRef: React.RefObject<HTMLDivElement | null>\n}\n\n/**\n * Handle node click\n */\nexport function createHandleNodeClick(\n  params: Pick<NodeOperationHandlerParams, \"container\" | \"dispatch\">\n) {\n  return (nodeId: string) => {\n    const { container, dispatch } = params\n    // Don't set container nodes as active - they're not focusable\n    // Only text nodes and image nodes can be focused\n    const result = findNodeInTree(nodeId, container)\n    if (result && isContainerNode(result.node)) {\n      // For container nodes, don't set as active\n      // The child blocks will handle their own clicks\n      return\n    }\n    dispatch(EditorActions.setActiveNode(nodeId))\n  }\n}\n\n/**\n * Handle delete node\n */\nexport function createHandleDeleteNode(\n  params: Pick<NodeOperationHandlerParams, \"container\" | \"dispatch\" | \"toast\">\n) {\n  return (nodeId: string) => {\n    const { container, dispatch, toast } = params\n\n    // Check if the node is inside a flex container\n    const parentContainer = container.children.find(\n      (child) =>\n        isContainerNode(child) &&\n        (child as ContainerNode).children.some((c) => c.id === nodeId)\n    )\n\n    if (parentContainer) {\n      const containerNode = parentContainer as ContainerNode\n      const remainingChildren = containerNode.children.filter(\n        (c) => c.id !== nodeId\n      )\n\n      // If only one child left, unwrap it from the container\n      if (remainingChildren.length === 1) {\n        // Batch: delete container and insert remaining child (single history entry)\n        const containerIndex = container.children.findIndex(\n          (c) => c.id === parentContainer.id\n        )\n        const actions: any[] = [EditorActions.deleteNode(parentContainer.id)]\n\n        if (containerIndex > 0) {\n          const prevNode = container.children[containerIndex - 1]\n          actions.push(\n            EditorActions.insertNode(remainingChildren[0], prevNode.id, \"after\")\n          )\n        } else if (containerIndex === 0 && container.children.length > 1) {\n          const nextNode = container.children[1]\n          actions.push(\n            EditorActions.insertNode(\n              remainingChildren[0],\n              nextNode.id,\n              \"before\"\n            )\n          )\n        }\n\n        dispatch(EditorActions.batch(actions))\n      } else if (remainingChildren.length === 0) {\n        // No children left, delete the container\n        dispatch(EditorActions.deleteNode(parentContainer.id))\n      } else {\n        // Multiple children remain, just remove this one\n        dispatch(EditorActions.deleteNode(nodeId))\n      }\n    } else {\n      dispatch(EditorActions.deleteNode(nodeId))\n    }\n\n    toast({\n      title: \"Image removed\",\n      description: \"The image has been deleted.\",\n    })\n  }\n}\n\n/**\n * Handle add block\n */\nexport function createHandleAddBlock(\n  params: Pick<NodeOperationHandlerParams, \"dispatch\" | \"nodeRefs\">\n) {\n  return (targetId: string, position: \"before\" | \"after\" = \"after\") => {\n    const { dispatch, nodeRefs } = params\n    // Create new paragraph node\n    const newNode: TextNode = {\n      id: \"p-\" + Date.now(),\n      type: \"p\",\n      content: \"\",\n      attributes: {},\n    }\n\n    dispatch(EditorActions.insertNode(newNode, targetId, position))\n    dispatch(EditorActions.setActiveNode(newNode.id))\n\n    // Focus the new node after a brief delay\n    setTimeout(() => {\n      const newElement = nodeRefs.current.get(newNode.id)\n      if (newElement) {\n        newElement.focus()\n      }\n    }, 50)\n  }\n}\n\n/**\n * Handle create nested block\n */\nexport function createHandleCreateNested(\n  params: Pick<NodeOperationHandlerParams, \"container\" | \"dispatch\" | \"toast\">\n) {\n  return (nodeId: string) => {\n    const { container, dispatch, toast } = params\n    const result = findNodeInTree(nodeId, container)\n    if (!result) return\n\n    const { node, parentId } = result\n\n    // If the node is inside a nested container (not root), we need to handle it differently\n    // We only allow 1 level of nesting, so if we're already nested, add to the parent container\n    const isAlreadyNested = parentId !== container.id\n\n    if (isAlreadyNested) {\n      // We're inside a nested container, so just add a new paragraph to the parent container\n      const newParagraph: TextNode = {\n        id: \"p-\" + Date.now(),\n        type: \"p\",\n        content: \"\",\n        attributes: {},\n      }\n\n      // Insert after the current node within the parent container\n      dispatch(EditorActions.insertNode(newParagraph, nodeId, \"after\"))\n      dispatch(EditorActions.setActiveNode(newParagraph.id))\n\n      // Focus is handled by the useEffect watching state.activeNodeId\n      return\n    }\n\n    // Node is at root level, create a nested container\n    if (!isTextNode(node)) return\n    const textNode = node as TextNode\n\n    // Create the new paragraph that will be focused\n    const newParagraphId = \"p-\" + Date.now()\n    const newParagraph: TextNode = {\n      id: newParagraphId,\n      type: \"p\",\n      content: \"\",\n      attributes: {},\n    }\n\n    // Create a nested container with the current node inside it\n    const nestedContainer: ContainerNode = {\n      id: \"container-\" + Date.now(),\n      type: \"container\",\n      children: [\n        // Copy the current node\n        { ...textNode },\n        // Add a new empty paragraph inside the nested container\n        newParagraph,\n      ],\n      attributes: {},\n    }\n\n    // Delete the original node\n    dispatch(EditorActions.deleteNode(nodeId))\n\n    // Insert the nested container in its place\n    // Since we deleted the node, we insert after the previous node or prepend to container\n    const nodeIndex = container.children.findIndex((n) => n.id === nodeId)\n    if (nodeIndex > 0) {\n      const previousNode = container.children[nodeIndex - 1]\n      dispatch(\n        EditorActions.insertNode(nestedContainer, previousNode.id, \"after\")\n      )\n    } else {\n      dispatch(\n        EditorActions.insertNode(nestedContainer, container.id, \"prepend\")\n      )\n    }\n\n    // Set the new paragraph as active\n    dispatch(EditorActions.setActiveNode(newParagraphId))\n\n    toast({\n      title: \"Nested block created\",\n      description:\n        \"Press Shift+Enter again to add more blocks in this container\",\n    })\n\n    // Focus is handled by the useEffect watching state.activeNodeId\n  }\n}\n\n/**\n * Handle change block type\n */\nexport function createHandleChangeBlockType(\n  params: Pick<NodeOperationHandlerParams, \"dispatch\" | \"nodeRefs\">\n) {\n  return (nodeId: string, newType: string) => {\n    const { dispatch, nodeRefs } = params\n    // Special handling for list items - initialize with empty content\n    if (newType === \"li\") {\n      dispatch(\n        EditorActions.updateNode(nodeId, {\n          type: newType as any,\n          content: \"\",\n        })\n      )\n    } else {\n      dispatch(EditorActions.updateNode(nodeId, { type: newType as any }))\n    }\n\n    // Focus the updated node after a brief delay\n    setTimeout(() => {\n      const element = nodeRefs.current.get(nodeId)\n      if (element) {\n        element.focus()\n      }\n    }, 50)\n  }\n}\n\n/**\n * Handle insert image from command\n */\nexport function createHandleInsertImageFromCommand(\n  params: Pick<NodeOperationHandlerParams, \"dispatch\" | \"nodeRefs\">,\n  fileInputRef: React.RefObject<HTMLInputElement | null>\n) {\n  return (nodeId: string) => {\n    const { dispatch } = params\n    // Delete the current empty block\n    dispatch(EditorActions.deleteNode(nodeId))\n\n    // Trigger the file input\n    setTimeout(() => {\n      fileInputRef.current?.click()\n    }, 100)\n  }\n}\n\n/**\n * Handle create list\n */\nexport function createHandleCreateList(params: NodeOperationHandlerParams) {\n  return (listType: \"ul\" | \"ol\") => {\n    const { container, dispatch, toast, editorContentRef } = params\n    const timestamp = Date.now()\n\n    // Create a container with a header and 1 nested item\n    const listContainer: ContainerNode = {\n      id: `container-${timestamp}`,\n      type: \"container\",\n      children: [\n        {\n          id: `h3-${timestamp}`,\n          type: \"h3\",\n          content: \"List Title\",\n          attributes: {},\n        } as TextNode,\n        {\n          id: `li-${timestamp}-1`,\n          type: \"li\",\n          content: \"First item\",\n          attributes: {},\n        } as TextNode,\n      ],\n      attributes: {\n        listType: listType,\n      },\n    }\n\n    // Insert the list container at the end\n    const lastNode = container.children[container.children.length - 1]\n    if (lastNode) {\n      dispatch(EditorActions.insertNode(listContainer, lastNode.id, \"after\"))\n    } else {\n      // If no nodes exist, replace the container\n      dispatch(\n        EditorActions.replaceContainer({\n          ...container,\n          children: [listContainer],\n        })\n      )\n    }\n\n    const listTypeLabel = listType === \"ol\" ? \"ordered\" : \"unordered\"\n    toast({\n      title: \"List Created\",\n      description: `Added a new ${listTypeLabel} list with header and 3 items`,\n    })\n\n    // Smooth scroll to the newly created list\n    setTimeout(() => {\n      // Find the last element in the editor (the newly created list container)\n      const editorContent = editorContentRef.current\n      if (editorContent) {\n        const lastChild = editorContent.querySelector(\n          \"[data-editor-content]\"\n        )?.lastElementChild\n        if (lastChild) {\n          lastChild.scrollIntoView({\n            behavior: \"smooth\",\n            block: \"end\",\n            inline: \"nearest\",\n          })\n        }\n      }\n    }, 150)\n  }\n}\n\n/**\n * Handle create list from command menu\n */\nexport function createHandleCreateListFromCommand(\n  params: Pick<NodeOperationHandlerParams, \"dispatch\" | \"toast\" | \"nodeRefs\">\n) {\n  return (nodeId: string, listType: string) => {\n    const { dispatch, toast, nodeRefs } = params\n    const timestamp = Date.now()\n    const firstItemId = `li-${timestamp}-1`\n\n    // Create a container with 1 list item (always \"li\", regardless of ul/ol)\n    // The container's attributes will store whether it's ul or ol\n    const listContainer: ContainerNode = {\n      id: `container-${timestamp}`,\n      type: \"container\",\n      attributes: {\n        listType: listType, // Store 'ul' or 'ol' in the container attributes\n      },\n      children: [\n        {\n          id: firstItemId,\n          type: \"li\",\n          content: \"\",\n          attributes: {},\n        } as TextNode,\n      ],\n    }\n\n    // Insert the list container after the current node, then delete the current node\n    dispatch(EditorActions.insertNode(listContainer, nodeId, \"after\"))\n    dispatch(EditorActions.deleteNode(nodeId))\n\n    const listTypeLabel = listType === \"ol\" ? \"numbered\" : \"bulleted\"\n    toast({\n      title: \"List Created\",\n      description: `Created a ${listTypeLabel} list with 3 items`,\n    })\n\n    // Focus the first item after a longer delay to ensure nested elements are registered\n    // Nested elements take longer to mount and register their refs\n    setTimeout(() => {\n      const element = nodeRefs.current.get(firstItemId)\n      if (element) {\n        element.focus()\n        // Also set it as active node\n        dispatch(EditorActions.setActiveNode(firstItemId))\n      } else {\n        // Retry after another delay\n        setTimeout(() => {\n          const retryElement = nodeRefs.current.get(firstItemId)\n          if (retryElement) {\n            retryElement.focus()\n            dispatch(EditorActions.setActiveNode(firstItemId))\n          }\n        }, 100)\n      }\n    }, 150)\n  }\n}\n\n/**\n * Handle create link\n */\nexport function createHandleCreateLink(params: NodeOperationHandlerParams) {\n  return () => {\n    const { container, dispatch, toast, editorContentRef } = params\n    const timestamp = Date.now()\n\n    // Create a paragraph with a link\n    const linkNode: TextNode = {\n      id: `p-${timestamp}`,\n      type: \"p\",\n      children: [\n        {\n          content: \"www.text.com\",\n          href: \"https://www.text.com\",\n        },\n      ],\n      attributes: {},\n    }\n\n    // Insert the link node at the end\n    const lastNode = container.children[container.children.length - 1]\n    if (lastNode) {\n      dispatch(EditorActions.insertNode(linkNode, lastNode.id, \"after\"))\n    } else {\n      // If no nodes exist, replace the container\n      dispatch(\n        EditorActions.replaceContainer({\n          ...container,\n          children: [linkNode],\n        })\n      )\n    }\n\n    toast({\n      title: \"Link Created\",\n      description: \"Added a new link element\",\n    })\n\n    // Smooth scroll to the newly created link\n    setTimeout(() => {\n      const editorContent = editorContentRef.current\n      if (editorContent) {\n        const lastChild = editorContent.querySelector(\n          \"[data-editor-content]\"\n        )?.lastElementChild\n        if (lastChild) {\n          lastChild.scrollIntoView({\n            behavior: \"smooth\",\n            block: \"end\",\n            inline: \"nearest\",\n          })\n        }\n      }\n    }, 150)\n  }\n}\n\n/**\n * Handle create table\n */\nexport function createHandleCreateTable(params: NodeOperationHandlerParams) {\n  return (rows: number, cols: number) => {\n    const { container, dispatch, toast, editorContentRef } = params\n    const timestamp = Date.now()\n\n    // Create header cells\n    const headerCells: TextNode[] = Array.from({ length: cols }, (_, i) => ({\n      id: `th-${timestamp}-${i}`,\n      type: \"th\",\n      content: `Column ${i + 1}`,\n      attributes: {},\n    }))\n\n    // Create header row\n    const headerRow: StructuralNode = {\n      id: `tr-header-${timestamp}`,\n      type: \"tr\",\n      children: headerCells,\n      attributes: {},\n    }\n\n    // Create thead\n    const thead: StructuralNode = {\n      id: `thead-${timestamp}`,\n      type: \"thead\",\n      children: [headerRow],\n      attributes: {},\n    }\n\n    // Create body rows\n    const bodyRows: StructuralNode[] = Array.from(\n      { length: rows },\n      (_, rowIdx) => {\n        const cells: TextNode[] = Array.from({ length: cols }, (_, colIdx) => ({\n          id: `td-${timestamp}-${rowIdx}-${colIdx}`,\n          type: \"td\",\n          content: \"\",\n          attributes: {},\n        }))\n\n        return {\n          id: `tr-${timestamp}-${rowIdx}`,\n          type: \"tr\",\n          children: cells,\n          attributes: {},\n        }\n      }\n    )\n\n    // Create tbody\n    const tbody: StructuralNode = {\n      id: `tbody-${timestamp}`,\n      type: \"tbody\",\n      children: bodyRows,\n      attributes: {},\n    }\n\n    // Create table\n    const table: StructuralNode = {\n      id: `table-${timestamp}`,\n      type: \"table\",\n      children: [thead, tbody],\n      attributes: {},\n    }\n\n    // Wrap table in a container for consistent handling\n    const tableWrapper: ContainerNode = {\n      id: `table-wrapper-${timestamp}`,\n      type: \"container\",\n      children: [table],\n      attributes: {},\n    }\n\n    // Insert the table at the end\n    const lastNode = container.children[container.children.length - 1]\n    if (lastNode) {\n      dispatch(EditorActions.insertNode(tableWrapper, lastNode.id, \"after\"))\n    } else {\n      // If no nodes exist, replace the container\n      dispatch(\n        EditorActions.replaceContainer({\n          ...container,\n          children: [tableWrapper],\n        })\n      )\n    }\n\n    toast({\n      title: \"Table Created\",\n      description: `Added a ${rows}×${cols} table`,\n    })\n\n    // Smooth scroll to the newly created table\n    setTimeout(() => {\n      const editorContent = editorContentRef.current\n      if (editorContent) {\n        const lastChild = editorContent.querySelector(\n          \"[data-editor-content]\"\n        )?.lastElementChild\n        if (lastChild) {\n          lastChild.scrollIntoView({\n            behavior: \"smooth\",\n            block: \"end\",\n            inline: \"nearest\",\n          })\n        }\n      }\n    }, 150)\n  }\n}\n\n/**\n * Handle copy HTML\n */\nexport function createHandleCopyHtml(\n  params: Pick<NodeOperationHandlerParams, \"toast\">,\n  enhanceSpaces: boolean,\n  setCopiedHtml: (copied: boolean) => void\n) {\n  return async (container: ContainerNode) => {\n    const { toast } = params\n    const { serializeToHtml } = require(\"../utils/serialize-to-html\")\n    let html = serializeToHtml(container)\n\n    // Wrap with spacing classes if enhance spaces is enabled\n    if (enhanceSpaces) {\n      html = `<div class=\"[&>*]:my-3 [&_*]:my-5\">\\n${html}\\n</div>`\n    }\n\n    try {\n      await navigator.clipboard.writeText(html)\n      setCopiedHtml(true)\n      toast({\n        title: \"HTML copied!\",\n        description: \"HTML code has been copied to clipboard.\",\n      })\n      setTimeout(() => setCopiedHtml(false), 2000)\n    } catch (error) {\n      toast({\n        variant: \"destructive\",\n        title: \"Copy failed\",\n        description: \"Failed to copy HTML to clipboard.\",\n      })\n    }\n  }\n}\n\n/**\n * Handle copy JSON\n */\nexport function createHandleCopyJson(\n  params: Pick<NodeOperationHandlerParams, \"toast\">,\n  setCopiedJson: (copied: boolean) => void\n) {\n  return async (container: ContainerNode) => {\n    const { toast } = params\n    const json = JSON.stringify(container.children, null, 2)\n    try {\n      await navigator.clipboard.writeText(json)\n      setCopiedJson(true)\n      toast({\n        title: \"JSON copied!\",\n        description: \"JSON data has been copied to clipboard.\",\n      })\n      setTimeout(() => setCopiedJson(false), 2000)\n    } catch (error) {\n      toast({\n        variant: \"destructive\",\n        title: \"Copy failed\",\n        description: \"Failed to copy JSON to clipboard.\",\n      })\n    }\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/selection-handlers.ts",
      "content": "/**\n * Selection Handler Functions\n *\n * Functions for handling text selection and formatting in the editor\n */\n\nimport { EditorActions } from \"../reducer/actions\"\nimport { ContainerNode, isTextNode, SelectionInfo, TextNode } from \"../types\"\nimport { detectFormatsInRange, restoreSelection } from \"../utils/editor-helpers\"\nimport { findNodeById } from \"../utils/tree-operations\"\n\nexport interface SelectionHandlerParams {\n  container: ContainerNode\n  state: any\n  dispatch: React.Dispatch<any>\n  selectionManager: any\n  nodeRefs: React.MutableRefObject<Map<string, HTMLElement>>\n}\n\n/**\n * Track text selection - updates ref immediately, state with debounce\n */\nexport function createHandleSelectionChange(\n  params: SelectionHandlerParams,\n  selectionDispatchTimerRef: React.MutableRefObject<NodeJS.Timeout | null>\n) {\n  return () => {\n    const { container, state, dispatch, selectionManager, nodeRefs } = params\n    const selection = window.getSelection()\n    const hasText =\n      selection !== null &&\n      !selection.isCollapsed &&\n      selection.toString().length > 0\n\n    if (hasText && selection) {\n      // NEW APPROACH: Find the actual node by traversing the DOM upwards from the selection\n      const range = selection.getRangeAt(0)\n      let currentElement: HTMLElement | null = null\n\n      // Start from the selection's common ancestor\n      let node: Node | null = range.commonAncestorContainer\n\n      // Walk up the DOM to find the closest element with data-node-id\n      while (node) {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          const element = node as HTMLElement\n          const nodeId = element.getAttribute(\"data-node-id\")\n          const nodeType = element.getAttribute(\"data-node-type\")\n\n          // We found a text node (not a container)\n          if (nodeId && nodeType && nodeType !== \"container\") {\n            currentElement = element\n            break\n          }\n        }\n        node = node.parentNode\n      }\n\n      if (!currentElement) {\n        // Fallback to old behavior if we can't find via DOM\n        const freshCurrentNode = state.activeNodeId\n          ? (findNodeById(container, state.activeNodeId) as\n              | TextNode\n              | undefined)\n          : (container.children[0] as TextNode | undefined)\n\n        if (freshCurrentNode) {\n          currentElement = nodeRefs.current.get(freshCurrentNode.id) || null\n        }\n      }\n\n      if (currentElement) {\n        const actualNodeId = currentElement.getAttribute(\"data-node-id\")\n\n        if (actualNodeId) {\n          // Find the actual node in the tree (including nested nodes)\n          const actualNode = findNodeById(container, actualNodeId) as\n            | TextNode\n            | undefined\n\n          if (actualNode && isTextNode(actualNode)) {\n            const preSelectionRange = range.cloneRange()\n            preSelectionRange.selectNodeContents(currentElement)\n            preSelectionRange.setEnd(range.startContainer, range.startOffset)\n            let start = preSelectionRange.toString().length\n            let end = start + range.toString().length\n\n            // Get the selected text\n            const selectedText = selection.toString()\n\n            // Trim trailing whitespace from the selection range\n            // This fixes the issue where double-clicking selects an extra space\n            const trimmedText = selectedText.trimEnd()\n            const trimmedLength = selectedText.length - trimmedText.length\n\n            // Adjust end position to exclude trailing whitespace\n            if (trimmedLength > 0) {\n              end = end - trimmedLength\n\n              // Also adjust the actual browser selection to exclude trailing space\n              // This makes the visual selection match what we're tracking\n              try {\n                const newRange = document.createRange()\n                const endContainer = range.endContainer\n                const endOffset = range.endOffset - trimmedLength\n\n                newRange.setStart(range.startContainer, range.startOffset)\n                newRange.setEnd(endContainer, endOffset)\n\n                selection.removeAllRanges()\n                selection.addRange(newRange)\n              } catch (e) {\n                // If adjusting the selection fails, just continue with the original\n                console.warn(\"Failed to adjust selection:\", e)\n              }\n            }\n\n            // Detect active formats in the selected range\n            const detected = detectFormatsInRange(actualNode, start, end)\n\n            const selectionInfo: SelectionInfo = {\n              text: selection.toString(),\n              start,\n              end,\n              nodeId: actualNode.id,\n              formats: {\n                bold: detected.bold,\n                italic: detected.italic,\n                underline: detected.underline,\n              },\n              elementType: detected.elementType,\n              href: detected.href,\n              className: detected.className,\n              styles: detected.styles,\n            }\n\n            // Check if selection actually changed\n            const currentSel = selectionManager.getSelection()\n            const changed =\n              !currentSel ||\n              currentSel.start !== start ||\n              currentSel.end !== end ||\n              currentSel.nodeId !== actualNode.id ||\n              currentSel.formats.bold !== detected.bold ||\n              currentSel.formats.italic !== detected.italic ||\n              currentSel.formats.underline !== detected.underline ||\n              currentSel.elementType !== detected.elementType\n\n            if (changed) {\n              // Update ref immediately (fast, no re-renders)\n              selectionManager.setSelection(selectionInfo)\n\n              // Debounce state dispatch to avoid excessive re-renders\n              if (selectionDispatchTimerRef.current) {\n                clearTimeout(selectionDispatchTimerRef.current)\n              }\n\n              selectionDispatchTimerRef.current = setTimeout(() => {\n                dispatch(EditorActions.setCurrentSelection(selectionInfo))\n              }, 150) // 150ms debounce for toolbar updates\n            }\n            return // Exit early on success\n          }\n        }\n      }\n    }\n\n    // Clear selection if no valid selection found\n    const currentSel = selectionManager.getSelection()\n    if (currentSel !== null) {\n      // Clear ref immediately\n      selectionManager.setSelection(null)\n\n      // Clear state with debounce\n      if (selectionDispatchTimerRef.current) {\n        clearTimeout(selectionDispatchTimerRef.current)\n      }\n\n      selectionDispatchTimerRef.current = setTimeout(() => {\n        dispatch(EditorActions.setCurrentSelection(null))\n      }, 150)\n    }\n  }\n}\n\n/**\n * Handle format button clicks - completely state-driven!\n */\nexport function createHandleFormat(params: SelectionHandlerParams) {\n  return (format: \"bold\" | \"italic\" | \"underline\") => {\n    const { container, dispatch, selectionManager, nodeRefs } = params\n    console.group(\"🔘 [handleFormat] Button clicked\")\n\n    // Get fresh selection from ref (more up-to-date than state)\n    const refSelection = selectionManager.getSelection()\n    if (!refSelection) {\n      console.warn(\"❌ No current selection, aborting\")\n      console.groupEnd()\n      return\n    }\n\n    // Save selection for restoration\n    const { start, end, nodeId, formats } = refSelection\n\n    // Dispatch toggle format action - reducer handles everything!\n    dispatch(EditorActions.toggleFormat(format))\n\n    // After state updates, check what happened\n    setTimeout(() => {\n      const updatedNode = container.children.find((n) => n.id === nodeId)\n    }, 100)\n\n    // Restore selection after formatting\n    setTimeout(() => {\n      const element = nodeRefs.current.get(nodeId)\n      if (element) {\n        restoreSelection(element, start, end)\n      } else {\n        console.warn(\"❌ Element not found for selection restoration\")\n      }\n      console.groupEnd()\n    }, 0)\n  }\n}\n\n/**\n * Handle color selection\n */\nexport function createHandleApplyColor(\n  params: SelectionHandlerParams,\n  toast: any,\n  setSelectedColor: (color: string) => void\n) {\n  return (color: string) => {\n    const { dispatch, selectionManager, nodeRefs } = params\n    // Get fresh selection from ref\n    const refSelection = selectionManager.getSelection()\n    if (!refSelection) return\n\n    const { nodeId, start, end } = refSelection\n\n    // Apply color as inline style\n    dispatch(EditorActions.applyInlineStyle(\"color\", color))\n\n    setSelectedColor(color)\n\n    toast({\n      title: \"Color Applied\",\n      description: `Applied color: ${color}`,\n    })\n\n    // Restore selection with a slightly longer delay to allow state update\n    setTimeout(() => {\n      const element = nodeRefs.current.get(nodeId)\n      if (element) {\n        restoreSelection(element, start, end)\n      }\n    }, 50)\n  }\n}\n\n/**\n * Handle font size selection\n */\nexport function createHandleApplyFontSize(\n  params: SelectionHandlerParams,\n  toast: any\n) {\n  return (fontSize: string) => {\n    const { dispatch, selectionManager, nodeRefs } = params\n    // Get fresh selection from ref\n    const refSelection = selectionManager.getSelection()\n    if (!refSelection) return\n\n    const { nodeId, start, end } = refSelection\n\n    // Apply font size as inline style\n    dispatch(EditorActions.applyInlineStyle(\"fontSize\", fontSize))\n\n    toast({\n      title: \"Font Size Applied\",\n      description: `Applied font size: ${fontSize}`,\n    })\n\n    // Restore selection with a slightly longer delay to allow state update\n    setTimeout(() => {\n      const element = nodeRefs.current.get(nodeId)\n      if (element) {\n        restoreSelection(element, start, end)\n      }\n    }, 50)\n  }\n}\n\n/**\n * Handle type change\n */\nexport function createHandleTypeChange(\n  params: SelectionHandlerParams,\n  currentNode: TextNode | undefined,\n  handleSelectionChange: () => void\n) {\n  return (type: TextNode[\"type\"]) => {\n    const { dispatch, selectionManager, nodeRefs } = params\n    if (!currentNode) return\n\n    // Check if there's a selection (use ref for freshest data)\n    const refSelection = selectionManager.getSelection()\n    if (refSelection) {\n      // Save selection info before dispatch\n      const { start, end, nodeId } = refSelection\n\n      // Apply as inline element type to selected text only\n      const elementType = type as\n        | \"p\"\n        | \"h1\"\n        | \"h2\"\n        | \"h3\"\n        | \"h4\"\n        | \"h5\"\n        | \"h6\"\n        | \"code\"\n        | \"blockquote\"\n      dispatch(EditorActions.applyInlineElementType(elementType))\n\n      // Restore selection after state update and trigger re-detection\n      setTimeout(() => {\n        const element = nodeRefs.current.get(nodeId)\n        if (element) {\n          restoreSelection(element, start, end)\n          // Manually trigger selection change detection to update the UI\n          handleSelectionChange()\n        }\n      }, 0)\n    } else {\n      // No selection - change entire block type (old behavior)\n      dispatch(\n        EditorActions.updateNode(currentNode.id, {\n          type,\n        })\n      )\n    }\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/block/index.ts",
      "content": "/**\n * Block Handlers Index\n *\n * Central export point for all block handler functions\n */\n\n// Utility functions\nexport * from \"./block-utils\"\n\n// Event handlers\nexport * from \"./block-event-handlers\"\n\n// Drag handlers\nexport * from \"./block-drag-handlers\"\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/block/block-drag-handlers.ts",
      "content": "/**\n * Block Drag Handler Functions\n *\n * Functions for handling drag operations in Block components\n */\n\nimport React from \"react\"\n\nimport { TextNode } from \"../../types\"\n\n/**\n * Create handle block drag start\n */\nexport function createHandleBlockDragStart(\n  textNode: TextNode,\n  onBlockDragStart?: (nodeId: string) => void\n) {\n  return (e: React.DragEvent) => {\n    e.stopPropagation()\n    e.dataTransfer.effectAllowed = \"move\"\n    e.dataTransfer.setData(\"text/plain\", textNode.id)\n    e.dataTransfer.setData(\n      \"application/json\",\n      JSON.stringify({\n        nodeId: textNode.id,\n        type: textNode.type,\n      })\n    )\n    if (onBlockDragStart) {\n      onBlockDragStart(textNode.id)\n    }\n  }\n}\n\n/**\n * Create handle block drag end\n */\nexport function createHandleBlockDragEnd() {\n  return (e: React.DragEvent) => {\n    e.stopPropagation()\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/block/block-event-handlers.ts",
      "content": "/**\n * Block Event Handler Functions\n *\n * Functions for handling events in Block components\n */\n\nimport React from \"react\"\n\nimport { EditorAction } from \"../../reducer/actions\"\nimport { ContainerNode, TextNode } from \"../../types\"\nimport { findParentById } from \"../../utils/tree-operations\"\n\nexport interface BlockEventHandlerParams {\n  textNode: TextNode\n  readOnly: boolean\n  onInput: (element: HTMLElement) => void\n  onKeyDown: (e: React.KeyboardEvent<HTMLElement>) => void\n  onClick: () => void\n  onCreateNested?: (nodeId: string) => void\n  onChangeBlockType?: (nodeId: string, newType: string) => void\n  onInsertImage?: (nodeId: string) => void\n  onCreateList?: (nodeId: string, listType: string) => void\n  currentContainer: ContainerNode\n  dispatch: React.Dispatch<EditorAction>\n  localRef: React.RefObject<HTMLElement | null>\n  isComposingRef: React.MutableRefObject<boolean>\n  shouldPreserveSelectionRef: React.MutableRefObject<boolean>\n  showCommandMenu: boolean\n  setShowCommandMenu: (show: boolean) => void\n  setCommandMenuAnchor: (el: HTMLElement | null) => void\n}\n\n/**\n * Create handle composition start\n */\nexport function createHandleCompositionStart() {\n  return (isComposingRef: React.MutableRefObject<boolean>) => {\n    return () => {\n      isComposingRef.current = true\n    }\n  }\n}\n\n/**\n * Create handle composition end\n */\nexport function createHandleCompositionEnd() {\n  return (isComposingRef: React.MutableRefObject<boolean>) => {\n    return () => {\n      isComposingRef.current = false\n    }\n  }\n}\n\n/**\n * Create handle input\n */\nexport function createHandleInput(\n  params: Pick<\n    BlockEventHandlerParams,\n    | \"textNode\"\n    | \"readOnly\"\n    | \"onInput\"\n    | \"onChangeBlockType\"\n    | \"showCommandMenu\"\n    | \"setShowCommandMenu\"\n    | \"setCommandMenuAnchor\"\n    | \"shouldPreserveSelectionRef\"\n  >\n) {\n  return (e: React.FormEvent<HTMLDivElement>) => {\n    const {\n      textNode,\n      readOnly,\n      onInput,\n      onChangeBlockType,\n      showCommandMenu,\n      setShowCommandMenu,\n      setCommandMenuAnchor,\n      shouldPreserveSelectionRef,\n    } = params\n    const element = e.currentTarget\n    const text = element.textContent || \"\"\n\n    // Check if the block is empty and user typed \"/\"\n    if (text === \"/\" && !readOnly && onChangeBlockType) {\n      setShowCommandMenu(true)\n      setCommandMenuAnchor(element)\n    } else if (showCommandMenu && text !== \"/\") {\n      // Close menu if user continues typing\n      setShowCommandMenu(false)\n    }\n\n    // Set flag to prevent content updates until next render\n    shouldPreserveSelectionRef.current = true\n\n    // Call the parent onInput handler\n    onInput(element)\n\n    // Reset the flag after a short delay to allow React to process\n    setTimeout(() => {\n      shouldPreserveSelectionRef.current = false\n    }, 0)\n  }\n}\n\n/**\n * Create handle key down\n */\nexport function createHandleKeyDown(params: BlockEventHandlerParams) {\n  return (e: React.KeyboardEvent<HTMLDivElement>) => {\n    const {\n      textNode,\n      onKeyDown,\n      onCreateNested,\n      showCommandMenu,\n      setShowCommandMenu,\n      setCommandMenuAnchor,\n      currentContainer,\n      dispatch,\n    } = params\n\n    // Close command menu on Escape\n    if (e.key === \"Escape\" && showCommandMenu) {\n      e.preventDefault()\n      setShowCommandMenu(false)\n      setCommandMenuAnchor(null)\n      return\n    }\n\n    // If command menu is open, let it handle the keyboard events\n    if (showCommandMenu && [\"ArrowDown\", \"ArrowUp\", \"Enter\"].includes(e.key)) {\n      // Don't prevent default - let CommandMenu handle it\n      return\n    }\n\n    // For list items (ul/ol/li), handle Enter and Shift+Enter specially\n    // For non-list items, Shift+Enter creates nested blocks\n    const isListItem =\n      textNode.type === \"ul\" || textNode.type === \"ol\" || textNode.type === \"li\"\n\n    // Handle Shift+Enter for list items - add line break within item\n    if (e.key === \"Enter\" && e.shiftKey && isListItem) {\n      e.preventDefault()\n      e.stopPropagation()\n\n      // Pass to SimpleEditor to handle line break insertion\n      onKeyDown(e)\n      return\n    }\n\n    // Handle Shift+Enter for non-list items - create nested block\n    if (e.key === \"Enter\" && e.shiftKey && !isListItem && onCreateNested) {\n      e.preventDefault()\n      onCreateNested(textNode.id)\n      return\n    }\n\n    // Handle regular Enter for list items - create new list item at same level\n    if (e.key === \"Enter\" && !e.shiftKey && isListItem) {\n      e.preventDefault()\n      e.stopPropagation()\n\n      // Find the parent container\n      const parent = findParentById(currentContainer, textNode.id)\n\n      if (parent) {\n        // Create a new list item with the same type\n        const newListItem: TextNode = {\n          id: `li-${Date.now()}`,\n          type: textNode.type, // Keep the same type (ul/ol/li)\n          content: \"\",\n        }\n\n        // Insert after the current list item\n        dispatch({\n          type: \"INSERT_NODE\",\n          payload: {\n            node: newListItem,\n            targetId: textNode.id,\n            position: \"after\",\n          },\n        })\n\n        // Focus the new list item after a short delay\n        setTimeout(() => {\n          const newElement = document.querySelector(\n            `[data-node-id=\"${newListItem.id}\"]`\n          ) as HTMLElement\n          if (newElement) {\n            newElement.focus()\n          }\n        }, 0)\n      } else {\n        console.warn(\n          \"🔷 [Block.tsx] Could not find parent container for list item\"\n        )\n      }\n\n      return\n    }\n\n    // Pass to parent handler for other keys\n    onKeyDown(e)\n  }\n}\n\n/**\n * Create handle click\n */\nexport function createHandleClick(\n  params: Pick<BlockEventHandlerParams, \"readOnly\" | \"onClick\">\n) {\n  return (e: React.MouseEvent<HTMLDivElement>) => {\n    const { readOnly, onClick } = params\n    // Check if the click target is a link\n    const target = e.target as HTMLElement\n    if (target.tagName === \"A\" && target.hasAttribute(\"href\")) {\n      // In read-only mode, let links work naturally\n      if (readOnly) {\n        return // Let the browser handle the link\n      } else {\n        // In edit mode, prevent link navigation\n        e.preventDefault()\n      }\n    }\n\n    // Call the parent onClick handler\n    onClick()\n  }\n}\n\n/**\n * Create handle command select\n */\nexport function createHandleCommandSelect(params: {\n  textNode: TextNode\n  onChangeBlockType?: (nodeId: string, newType: string) => void\n  onInsertImage?: (nodeId: string) => void\n  onCreateList?: (nodeId: string, listType: string) => void\n  localRef: React.RefObject<HTMLElement | null>\n  setShowCommandMenu: (show: boolean) => void\n  setCommandMenuAnchor: (el: HTMLElement | null) => void\n}) {\n  return (commandValue: string) => {\n    const {\n      textNode,\n      onChangeBlockType,\n      onInsertImage,\n      onCreateList,\n      localRef,\n      setShowCommandMenu,\n      setCommandMenuAnchor,\n    } = params\n\n    if (!localRef.current) return\n\n    // Clear the \"/\" character\n    localRef.current.textContent = \"\"\n\n    // Close the menu immediately\n    setShowCommandMenu(false)\n    setCommandMenuAnchor(null)\n\n    // Handle image insertion specially\n    if (commandValue === \"img\" && onInsertImage) {\n      onInsertImage(textNode.id)\n      return\n    }\n\n    // Handle list creation (both ordered and unordered) - create a container with multiple list items\n    if ((commandValue === \"ol\" || commandValue === \"ul\") && onCreateList) {\n      // Small delay to ensure menu is closed before creating the list\n      setTimeout(() => {\n        onCreateList(textNode.id, commandValue)\n      }, 50)\n      return\n    }\n\n    // For other block types, just change the type\n    if (onChangeBlockType) {\n      onChangeBlockType(textNode.id, commandValue)\n\n      // Focus back on the block\n      setTimeout(() => {\n        localRef.current?.focus()\n      }, 0)\n    }\n  }\n}\n\n/**\n * Create handle background color change\n */\nexport function createHandleBackgroundColorChange(\n  textNode: TextNode,\n  dispatch: React.Dispatch<EditorAction>\n) {\n  return (color: string) => {\n    dispatch({\n      type: \"UPDATE_ATTRIBUTES\",\n      payload: {\n        id: textNode.id,\n        attributes: {\n          backgroundColor: color,\n        },\n        merge: true,\n      },\n    })\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/handlers/block/block-utils.ts",
      "content": "/**\n * Block Utility Functions\n *\n * Helper functions for Block component rendering and selection management\n */\n\nimport { TextNode } from \"../../types\"\n\n/**\n * Helper function to escape HTML entities\n */\nexport function escapeHTML(text: string): string {\n  const div = document.createElement(\"div\")\n  div.textContent = text\n  return div.innerHTML\n}\n\n/**\n * Get CSS classes for each node type\n */\nexport function getTypeClassName(type: string): string {\n  switch (type) {\n    case \"h1\":\n      return \"text-4xl font-extrabold text-foreground leading-[1.2]\"\n    case \"h2\":\n      return \"text-3xl font-bold text-foreground leading-[1.2]\"\n    case \"h3\":\n      return \"text-2xl font-semibold text-foreground leading-[1.3]\"\n    case \"h4\":\n      return \"text-xl font-semibold text-foreground leading-[1.3]\"\n    case \"h5\":\n      return \"text-lg font-semibold text-foreground leading-[1.4]\"\n    case \"h6\":\n      return \"text-base font-semibold text-foreground leading-[1.4]\"\n    case \"p\":\n      return \"text-base text-foreground leading-relaxed\"\n    case \"ul\":\n      return \"text-base text-foreground leading-relaxed\"\n    case \"ol\":\n      return \"text-base text-foreground leading-relaxed\"\n    case \"li\":\n      return \"text-base text-foreground leading-relaxed\"\n    case \"blockquote\":\n      return \"text-base text-muted-foreground italic border-l-4 border-primary pl-6 py-2\"\n    case \"code\":\n      return \"font-mono text-sm bg-secondary text-secondary-foreground px-4 py-3 rounded-lg whitespace-pre-wrap break-words\"\n    default:\n      return \"text-lg text-foreground leading-relaxed\"\n  }\n}\n\n/**\n * Build HTML content from children or lines\n */\nexport function buildHTML(textNode: TextNode, readOnly: boolean): string {\n  // Check if node has inline children with formatting\n  const hasChildren =\n    Array.isArray(textNode.children) && textNode.children.length > 0\n  // Check if node has multiple lines\n  const hasLines = Array.isArray(textNode.lines) && textNode.lines.length > 0\n\n  // For code blocks, we need to escape HTML entities\n  const isCodeBlock = textNode.type === \"code\"\n\n  // If node has multiple lines (e.g., ordered list with multiple items)\n  if (hasLines) {\n    return textNode\n      .lines!.map((line, index) => {\n        let lineContent = \"\"\n\n        // If line has inline children with formatting\n        if (line.children && line.children.length > 0) {\n          lineContent = line.children\n            .map((child) => {\n              // Check if className is a hex color or Tailwind class\n              const isHexColor =\n                child.className && child.className.startsWith(\"#\")\n              const colorStyle = isHexColor ? child.className : \"\"\n              const className = isHexColor ? \"\" : child.className\n\n              const classes = [\n                child.bold ? \"font-bold\" : \"\",\n                child.italic ? \"italic\" : \"\",\n                child.underline ? \"underline\" : \"\",\n                className || \"\", // Include custom className (only if not hex color)\n              ]\n                .filter(Boolean)\n                .join(\" \")\n\n              const styleAttr = colorStyle\n                ? ` style=\"color: ${colorStyle};\"`\n                : \"\"\n              const childContent = isCodeBlock\n                ? escapeHTML(child.content || \"\")\n                : child.content || \"\"\n\n              // If it's a link\n              if (child.href) {\n                const linkClasses = [\"hover:underline cursor-pointer\", classes]\n                  .filter(Boolean)\n                  .join(\" \")\n                const italicSpacing = child.italic ? \"inline-block pr-1\" : \"\"\n                const combinedClasses = [linkClasses, italicSpacing]\n                  .filter(Boolean)\n                  .join(\" \")\n                return `<a href=\"${child.href}\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"${combinedClasses}\"${styleAttr}>${childContent}</a>`\n              }\n\n              if (child.elementType) {\n                const elementClasses = getTypeClassName(child.elementType)\n                const italicSpacing = child.italic ? \"inline-block pr-1\" : \"\"\n                const combinedClasses = [elementClasses, classes, italicSpacing]\n                  .filter(Boolean)\n                  .join(\" \")\n                return `<span class=\"${combinedClasses}\"${styleAttr}>${childContent}</span>`\n              }\n\n              if (classes || colorStyle) {\n                const italicSpacing = child.italic ? \"inline-block pr-1\" : \"\"\n                const combinedClasses = [classes, italicSpacing]\n                  .filter(Boolean)\n                  .join(\" \")\n                const classAttr = combinedClasses\n                  ? ` class=\"${combinedClasses}\"`\n                  : \"\"\n                return `<span${classAttr}${styleAttr}>${childContent}</span>`\n              }\n              return childContent\n            })\n            .join(\"\")\n        } else {\n          lineContent = isCodeBlock\n            ? escapeHTML(line.content || \"\")\n            : line.content || \"\"\n        }\n\n        return lineContent\n      })\n      .join(\"<br>\")\n  }\n\n  // If node has inline children with formatting (single line)\n  if (hasChildren) {\n    return textNode\n      .children!.map((child) => {\n        // Build inline styles from the styles object\n        let inlineStyles = \"\"\n        if (child.styles) {\n          inlineStyles = Object.entries(child.styles)\n            .map(([key, value]) => {\n              // Convert camelCase to kebab-case (fontSize -> font-size)\n              const kebabKey = key.replace(/([A-Z])/g, \"-$1\").toLowerCase()\n              return `${kebabKey}: ${value}`\n            })\n            .join(\"; \")\n        }\n\n        const classes = [\n          child.bold ? \"font-bold\" : \"\",\n          child.italic ? \"italic\" : \"\",\n          child.underline ? \"underline\" : \"\",\n          child.className || \"\",\n        ]\n          .filter(Boolean)\n          .join(\" \")\n\n        const styleAttr = inlineStyles ? ` style=\"${inlineStyles}\"` : \"\"\n        const childContent = isCodeBlock\n          ? escapeHTML(child.content || \"\")\n          : child.content || \"\"\n\n        // If it's a link\n        if (child.href) {\n          const linkClasses = [\"underline cursor-pointer\", classes]\n            .filter(Boolean)\n            .join(\" \")\n          const italicSpacing = child.italic ? \"inline-block pr-1\" : \"\"\n          const combinedClasses = [linkClasses, italicSpacing]\n            .filter(Boolean)\n            .join(\" \")\n          return `<a href=\"${child.href}\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"${combinedClasses}\"${styleAttr}>${childContent}</a>`\n        }\n\n        // If child has an elementType, wrap in appropriate element\n        if (child.elementType) {\n          const elementClasses = getTypeClassName(child.elementType)\n          // Add extra spacing for italic text to prevent overlapping\n          const italicSpacing = child.italic ? \"inline-block pr-1\" : \"\"\n          const combinedClasses = [elementClasses, classes, italicSpacing]\n            .filter(Boolean)\n            .join(\" \")\n          return `<span class=\"${combinedClasses}\"${styleAttr}>${childContent}</span>`\n        }\n\n        if (classes || inlineStyles) {\n          // Add extra spacing for italic text to prevent overlapping\n          const italicSpacing = child.italic ? \"inline-block pr-1\" : \"\"\n          const combinedClasses = [classes, italicSpacing]\n            .filter(Boolean)\n            .join(\" \")\n          const classAttr = combinedClasses ? ` class=\"${combinedClasses}\"` : \"\"\n          return `<span${classAttr}${styleAttr}>${childContent}</span>`\n        }\n        return childContent\n      })\n      .join(\"\")\n  }\n\n  // Simple content (single line, no formatting)\n  const content = textNode.content || \"\"\n  return isCodeBlock ? escapeHTML(content) : content\n}\n\n/**\n * Save current selection position\n */\nexport function saveSelection(localRef: React.RefObject<HTMLElement | null>): {\n  start: number\n  end: number\n  collapsed: boolean\n} | null {\n  if (!localRef.current) return null\n\n  const selection = window.getSelection()\n  if (!selection || selection.rangeCount === 0) return null\n\n  const range = selection.getRangeAt(0)\n  if (!localRef.current.contains(range.commonAncestorContainer)) return null\n\n  // Create a simplified representation of the selection\n  const preCaretRange = range.cloneRange()\n  preCaretRange.selectNodeContents(localRef.current)\n  preCaretRange.setEnd(range.startContainer, range.startOffset)\n\n  return {\n    start: preCaretRange.toString().length,\n    end: preCaretRange.toString().length + range.toString().length,\n    collapsed: range.collapsed,\n  }\n}\n\n/**\n * Restore selection to saved position\n */\nexport function restoreSelection(\n  localRef: React.RefObject<HTMLElement | null>,\n  savedSelection: { start: number; end: number; collapsed: boolean } | null\n): void {\n  if (!savedSelection || !localRef.current) return\n\n  const selection = window.getSelection()\n  if (!selection) return\n\n  let charIndex = 0\n  let startNode: Node | undefined = undefined\n  let startOffset = 0\n  let endNode: Node | undefined = undefined\n  let endOffset = 0\n\n  const walk = (node: Node): void => {\n    if (startNode && endNode) return\n\n    if (node.nodeType === Node.TEXT_NODE) {\n      const textLength = node.textContent?.length || 0\n\n      // Find start position\n      if (!startNode && charIndex + textLength >= savedSelection.start) {\n        startNode = node\n        startOffset = savedSelection.start - charIndex\n      }\n\n      // Find end position\n      if (!endNode && charIndex + textLength >= savedSelection.end) {\n        endNode = node\n        endOffset = savedSelection.end - charIndex\n      }\n\n      charIndex += textLength\n    } else {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        walk(node.childNodes[i])\n        if (startNode && endNode) break\n      }\n    }\n  }\n\n  walk(localRef.current)\n\n  try {\n    const range = document.createRange()\n\n    if (startNode && endNode) {\n      const start = startNode as Node\n      const end = endNode as Node\n      range.setStart(\n        start,\n        Math.min(startOffset, start.textContent?.length || 0)\n      )\n\n      if (savedSelection.collapsed) {\n        range.collapse(true)\n      } else {\n        range.setEnd(end, Math.min(endOffset, end.textContent?.length || 0))\n      }\n\n      selection.removeAllRanges()\n      selection.addRange(range)\n    }\n  } catch (e) {\n    console.warn(\"Failed to restore selection:\", e)\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/utils/drag-auto-scroll.ts",
      "content": "/**\n * Drag Auto-Scroll Utility\n *\n * Provides automatic scrolling functionality when dragging elements near viewport edges\n * This allows users to drag items to areas outside the current visible viewport\n */\n\nimport React from \"react\"\n\n/**\n * Auto-scroll configuration\n */\nexport interface AutoScrollConfig {\n  /** Distance from edge (in pixels) that triggers auto-scroll */\n  scrollZone?: number\n  /** Scroll speed in pixels per frame */\n  scrollSpeed?: number\n  /** Whether to enable horizontal scrolling */\n  enableHorizontal?: boolean\n  /** Whether to enable vertical scrolling */\n  enableVertical?: boolean\n}\n\nconst DEFAULT_CONFIG: Required<AutoScrollConfig> = {\n  scrollZone: 80,\n  scrollSpeed: 10,\n  enableHorizontal: false,\n  enableVertical: true,\n}\n\n/**\n * Setup auto-scroll for drag operations\n * Returns a cleanup function to remove event listeners\n */\nexport function setupDragAutoScroll(\n  containerRef: React.RefObject<HTMLElement | null>,\n  config: AutoScrollConfig = {}\n): () => void {\n  const finalConfig = { ...DEFAULT_CONFIG, ...config }\n  let rafId: number | null = null\n  let isDragging = false\n  let lastMouseX = 0\n  let lastMouseY = 0\n\n  /**\n   * Auto-scroll logic\n   */\n  const autoScroll = () => {\n    if (!isDragging || !containerRef.current) {\n      rafId = null\n      return\n    }\n\n    const container = containerRef.current\n    const rect = container.getBoundingClientRect()\n    const { scrollZone, scrollSpeed, enableVertical, enableHorizontal } =\n      finalConfig\n\n    let scrollX = 0\n    let scrollY = 0\n\n    // Check vertical scrolling\n    if (enableVertical) {\n      // Scroll down when near bottom\n      if (lastMouseY > rect.bottom - scrollZone) {\n        const distance = lastMouseY - (rect.bottom - scrollZone)\n        const intensity = Math.min(distance / scrollZone, 1)\n        scrollY = scrollSpeed * intensity\n      }\n      // Scroll up when near top\n      else if (lastMouseY < rect.top + scrollZone) {\n        const distance = rect.top + scrollZone - lastMouseY\n        const intensity = Math.min(distance / scrollZone, 1)\n        scrollY = -scrollSpeed * intensity\n      }\n    }\n\n    // Check horizontal scrolling\n    if (enableHorizontal) {\n      // Scroll right when near right edge\n      if (lastMouseX > rect.right - scrollZone) {\n        const distance = lastMouseX - (rect.right - scrollZone)\n        const intensity = Math.min(distance / scrollZone, 1)\n        scrollX = scrollSpeed * intensity\n      }\n      // Scroll left when near left edge\n      else if (lastMouseX < rect.left + scrollZone) {\n        const distance = rect.left + scrollZone - lastMouseX\n        const intensity = Math.min(distance / scrollZone, 1)\n        scrollX = -scrollSpeed * intensity\n      }\n    }\n\n    // Perform scroll\n    if (scrollX !== 0 || scrollY !== 0) {\n      // Try to find the scrollable parent (could be window or a container)\n      const scrollableParent = findScrollableParent(container)\n\n      if (scrollableParent === window) {\n        window.scrollBy(scrollX, scrollY)\n      } else if (scrollableParent instanceof HTMLElement) {\n        scrollableParent.scrollLeft += scrollX\n        scrollableParent.scrollTop += scrollY\n      }\n    }\n\n    // Continue animation loop\n    rafId = requestAnimationFrame(autoScroll)\n  }\n\n  /**\n   * Find the scrollable parent element\n   */\n  const findScrollableParent = (element: HTMLElement): HTMLElement | Window => {\n    let parent = element.parentElement\n\n    while (parent) {\n      const style = window.getComputedStyle(parent)\n      const isScrollable =\n        (style.overflowY === \"auto\" ||\n          style.overflowY === \"scroll\" ||\n          style.overflowX === \"auto\" ||\n          style.overflowX === \"scroll\") &&\n        (parent.scrollHeight > parent.clientHeight ||\n          parent.scrollWidth > parent.clientWidth)\n\n      if (isScrollable) {\n        return parent\n      }\n\n      parent = parent.parentElement\n    }\n\n    // Default to window if no scrollable parent found\n    return window\n  }\n\n  /**\n   * Track mouse movement during drag\n   */\n  const handleDragOver = (e: DragEvent) => {\n    lastMouseX = e.clientX\n    lastMouseY = e.clientY\n\n    // Start auto-scroll loop if not already running\n    if (!rafId && isDragging) {\n      rafId = requestAnimationFrame(autoScroll)\n    }\n  }\n\n  /**\n   * Start tracking drag\n   */\n  const handleDragStart = () => {\n    isDragging = true\n  }\n\n  /**\n   * Stop tracking drag\n   */\n  const handleDragEnd = () => {\n    isDragging = false\n    if (rafId) {\n      cancelAnimationFrame(rafId)\n      rafId = null\n    }\n  }\n\n  // Attach event listeners\n  document.addEventListener(\"dragstart\", handleDragStart)\n  document.addEventListener(\"dragover\", handleDragOver)\n  document.addEventListener(\"dragend\", handleDragEnd)\n  document.addEventListener(\"drop\", handleDragEnd)\n\n  // Return cleanup function\n  return () => {\n    isDragging = false\n    if (rafId) {\n      cancelAnimationFrame(rafId)\n      rafId = null\n    }\n    document.removeEventListener(\"dragstart\", handleDragStart)\n    document.removeEventListener(\"dragover\", handleDragOver)\n    document.removeEventListener(\"dragend\", handleDragEnd)\n    document.removeEventListener(\"drop\", handleDragEnd)\n  }\n}\n\n/**\n * React hook for drag auto-scroll\n */\nexport function useDragAutoScroll(\n  containerRef: React.RefObject<HTMLElement | null>,\n  config?: AutoScrollConfig\n) {\n  const configRef = React.useRef(config)\n\n  React.useEffect(() => {\n    configRef.current = config\n  }, [config])\n\n  React.useEffect(() => {\n    const cleanup = setupDragAutoScroll(containerRef, configRef.current)\n    return cleanup\n  }, [containerRef])\n}\n\n// For non-React usage\nexport default setupDragAutoScroll\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/utils/editor-helpers.ts",
      "content": "/**\n * Editor Helper Functions\n *\n * Utility functions used by the SimpleEditor component\n */\n\nimport {\n  ContainerNode,\n  EditorNode,\n  InlineText,\n  isContainerNode,\n  SelectionInfo,\n  TextNode,\n} from \"../types\"\n\n/**\n * Parse DOM element back into inline children structure\n * This preserves formatting when user types in a formatted block\n */\nexport function parseDOMToInlineChildren(\n  element: HTMLElement\n): TextNode[\"children\"] {\n  const children: TextNode[\"children\"] = []\n\n  const walkNode = (\n    node: Node,\n    inheritedFormats: {\n      bold?: boolean\n      italic?: boolean\n      underline?: boolean\n      className?: string\n      elementType?:\n        | \"p\"\n        | \"h1\"\n        | \"h2\"\n        | \"h3\"\n        | \"h4\"\n        | \"h5\"\n        | \"h6\"\n        | \"code\"\n        | \"blockquote\"\n    } = {}\n  ) => {\n    if (node.nodeType === Node.TEXT_NODE) {\n      // Direct text node - use inherited formatting\n      const content = node.textContent || \"\"\n      if (content) {\n        const hasAnyFormatting =\n          inheritedFormats.bold ||\n          inheritedFormats.italic ||\n          inheritedFormats.underline ||\n          inheritedFormats.className ||\n          inheritedFormats.elementType\n        if (hasAnyFormatting) {\n          children.push({\n            content,\n            bold: inheritedFormats.bold || undefined,\n            italic: inheritedFormats.italic || undefined,\n            underline: inheritedFormats.underline || undefined,\n            className: inheritedFormats.className || undefined,\n            elementType: inheritedFormats.elementType,\n          })\n        } else {\n          children.push({ content })\n        }\n      }\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      const el = node as HTMLElement\n      const classList = Array.from(el.classList)\n\n      // Detect formatting from classes\n      const bold = classList.includes(\"font-bold\")\n      const italic = classList.includes(\"italic\")\n      const underline = classList.includes(\"underline\")\n\n      // Detect element type from classes\n      let elementType:\n        | \"p\"\n        | \"h1\"\n        | \"h2\"\n        | \"h3\"\n        | \"h4\"\n        | \"h5\"\n        | \"h6\"\n        | \"code\"\n        | \"blockquote\"\n        | undefined = undefined\n      if (classList.some((c) => c.includes(\"text-4xl\"))) {\n        elementType = \"h1\"\n      } else if (classList.some((c) => c.includes(\"text-3xl\"))) {\n        elementType = \"h2\"\n      } else if (classList.some((c) => c.includes(\"text-2xl\"))) {\n        elementType = \"h3\"\n      } else if (classList.some((c) => c.includes(\"text-xl\"))) {\n        elementType = \"h4\"\n      } else if (\n        classList.some((c) => c.includes(\"text-lg\")) &&\n        classList.includes(\"font-semibold\")\n      ) {\n        elementType = \"h5\"\n      } else if (\n        classList.some((c) => c.includes(\"text-base\")) &&\n        classList.includes(\"font-semibold\")\n      ) {\n        elementType = \"h6\"\n      } else if (classList.includes(\"font-mono\")) {\n        elementType = \"code\"\n      } else if (classList.includes(\"border-l-4\")) {\n        elementType = \"blockquote\"\n      } else if (\n        classList.some((c) => c.includes(\"text-base\")) &&\n        classList.some((c) => c.includes(\"leading-relaxed\"))\n      ) {\n        elementType = \"p\"\n      }\n\n      // Extract custom classes (filter out known formatting classes and extra spacing classes)\n      const knownClasses = [\n        \"font-bold\",\n        \"italic\",\n        \"underline\",\n        \"text-5xl\",\n        \"text-4xl\",\n        \"text-3xl\",\n        \"text-2xl\",\n        \"text-xl\",\n        \"text-lg\",\n        \"font-semibold\",\n        \"font-mono\",\n        \"border-l-4\",\n        \"pl-4\",\n        \"text-primary\",\n        \"hover:underline\",\n        \"cursor-pointer\",\n        \"inline-block\",\n        \"pr-1\", // italic spacing classes\n      ]\n      const customClasses = classList.filter((c) => !knownClasses.includes(c))\n      const customClassName =\n        customClasses.length > 0 ? customClasses.join(\" \") : undefined\n\n      // Merge with inherited formatting\n      const currentFormats = {\n        bold: bold || inheritedFormats.bold,\n        italic: italic || inheritedFormats.italic,\n        underline: underline || inheritedFormats.underline,\n        className: customClassName || inheritedFormats.className,\n        elementType: elementType || inheritedFormats.elementType,\n      }\n\n      // If it's a span with formatting, walk its children with inherited formats\n      if (el.tagName === \"SPAN\") {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          walkNode(node.childNodes[i], currentFormats)\n        }\n      } else {\n        // For other elements (like the main div), just walk children\n        for (let i = 0; i < node.childNodes.length; i++) {\n          walkNode(node.childNodes[i], inheritedFormats)\n        }\n      }\n    }\n  }\n\n  for (let i = 0; i < element.childNodes.length; i++) {\n    walkNode(element.childNodes[i])\n  }\n\n  // Filter out empty content\n  return children.filter((child) => child.content && child.content.length > 0)\n}\n\n/**\n * Detect which formats are active in a given range of a node\n */\nexport function detectFormatsInRange(\n  node: TextNode,\n  start: number,\n  end: number\n): {\n  bold: boolean\n  italic: boolean\n  underline: boolean\n  elementType?:\n    | \"h1\"\n    | \"h2\"\n    | \"h3\"\n    | \"h4\"\n    | \"h5\"\n    | \"h6\"\n    | \"code\"\n    | \"blockquote\"\n    | null\n  href?: string | null\n  className?: string | null\n  styles?: Record<string, string> | null\n} {\n  const formats = {\n    bold: false,\n    italic: false,\n    underline: false,\n    elementType: null as any,\n    href: null as string | null,\n    className: null as string | null,\n    styles: null as Record<string, string> | null,\n  }\n\n  // If node has no children, check node-level attributes\n  if (!node.children || node.children.length === 0) {\n    return {\n      bold: node.attributes?.bold === true,\n      italic: node.attributes?.italic === true,\n      underline: node.attributes?.underline === true,\n      elementType: null,\n      href: null,\n      className: null,\n      styles: null,\n    }\n  }\n\n  // Node has children array - analyze the range\n  let currentPos = 0\n  let hasAnyBold = false\n  let hasAnyItalic = false\n  let hasAnyUnderline = false\n  let allBold = true\n  let allItalic = true\n  let allUnderline = true\n  let charsInRange = 0\n  let firstElementType: typeof formats.elementType = undefined\n  let allSameElementType = true\n  let firstHref: string | undefined = undefined\n  let allSameHref = true\n  let firstClassName: string | undefined = undefined\n  let allSameClassName = true\n  let firstStyles: Record<string, string> | undefined = undefined\n  let allSameStyles = true\n\n  for (const child of node.children) {\n    const childLength = (child.content || \"\").length\n    const childStart = currentPos\n    const childEnd = currentPos + childLength\n\n    // Check if this child overlaps with the selection\n    const overlaps = childStart < end && childEnd > start\n\n    if (overlaps) {\n      charsInRange += Math.min(childEnd, end) - Math.max(childStart, start)\n\n      if (child.bold) {\n        hasAnyBold = true\n      } else {\n        allBold = false\n      }\n\n      if (child.italic) {\n        hasAnyItalic = true\n      } else {\n        allItalic = false\n      }\n\n      if (child.underline) {\n        hasAnyUnderline = true\n      } else {\n        allUnderline = false\n      }\n\n      // Check element type\n      const childElementType = child.elementType || null\n      if (firstElementType === undefined) {\n        firstElementType = childElementType\n      } else if (firstElementType !== childElementType) {\n        allSameElementType = false\n      }\n\n      // Check href\n      const childHref = child.href || null\n      if (firstHref === undefined) {\n        firstHref = childHref || undefined\n      } else if (firstHref !== childHref) {\n        allSameHref = false\n      }\n\n      // Check className\n      const childClassName = child.className || null\n      if (firstClassName === undefined) {\n        firstClassName = childClassName || undefined\n      } else if (firstClassName !== childClassName) {\n        allSameClassName = false\n      }\n\n      // Check styles\n      const childStyles = child.styles || null\n      if (firstStyles === undefined) {\n        firstStyles = childStyles || undefined\n      } else if (JSON.stringify(firstStyles) !== JSON.stringify(childStyles)) {\n        allSameStyles = false\n      }\n    }\n\n    currentPos = childEnd\n  }\n\n  // A format is \"active\" if ALL selected text has that format\n  return {\n    bold: charsInRange > 0 && allBold,\n    italic: charsInRange > 0 && allItalic,\n    underline: charsInRange > 0 && allUnderline,\n    elementType: allSameElementType ? firstElementType : null,\n    href: allSameHref ? firstHref || null : null,\n    className: allSameClassName ? firstClassName || null : null,\n    styles: allSameStyles ? firstStyles || null : null,\n  }\n}\n\n/**\n * Helper function to find a node in the tree (including nested containers)\n */\nexport function findNodeInTree(\n  searchId: string,\n  container: ContainerNode\n): {\n  node: EditorNode\n  parentId: string | null\n  siblings: EditorNode[]\n} | null {\n  // Check direct children\n  for (let i = 0; i < container.children.length; i++) {\n    const child = container.children[i]\n    if (child.id === searchId) {\n      return {\n        node: child,\n        parentId: container.id,\n        siblings: container.children,\n      }\n    }\n    // If child is a container, search recursively\n    if (isContainerNode(child)) {\n      const found = findNodeInTree(searchId, child as ContainerNode)\n      if (found) return found\n    }\n  }\n  return null\n}\n\n/**\n * Helper to find a node anywhere (root or in container)\n */\nexport function findNodeAnywhere(\n  id: string,\n  container: ContainerNode\n): {\n  node: EditorNode\n  parentId?: string\n  parent?: ContainerNode\n} | null {\n  // Check root level\n  const rootNode = container.children.find((n) => n.id === id)\n  if (rootNode) return { node: rootNode }\n\n  // Check inside containers\n  for (const child of container.children) {\n    if (isContainerNode(child)) {\n      const containerNode = child as ContainerNode\n      const foundInContainer = containerNode.children.find((c) => c.id === id)\n      if (foundInContainer)\n        return {\n          node: foundInContainer,\n          parentId: child.id,\n          parent: containerNode,\n        }\n    }\n  }\n  return null\n}\n\n/**\n * Helper to restore selection after formatting\n */\nexport function restoreSelection(\n  element: HTMLElement,\n  start: number,\n  end: number\n) {\n  const range = document.createRange()\n  const sel = window.getSelection()\n\n  let currentPos = 0\n  let startNode: Node | null = null\n  let startOffset = 0\n  let endNode: Node | null = null\n  let endOffset = 0\n  let found = false\n\n  const walk = (node: Node) => {\n    if (found) return\n\n    if (node.nodeType === Node.TEXT_NODE) {\n      const textLength = node.textContent?.length || 0\n\n      if (!startNode && currentPos + textLength >= start) {\n        startNode = node\n        startOffset = start - currentPos\n      }\n\n      if (!endNode && currentPos + textLength >= end) {\n        endNode = node\n        endOffset = end - currentPos\n        found = true\n      }\n\n      currentPos += textLength\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        walk(node.childNodes[i])\n        if (found) break\n      }\n    }\n  }\n\n  walk(element)\n\n  if (startNode && endNode && sel) {\n    try {\n      const startLength = (startNode as Text).textContent?.length || 0\n      const endLength = (endNode as Text).textContent?.length || 0\n      range.setStart(startNode, Math.min(startOffset, startLength))\n      range.setEnd(endNode, Math.min(endOffset, endLength))\n      sel.removeAllRanges()\n      sel.addRange(range)\n    } catch (e) {\n      console.warn(\"Failed to restore selection:\", e)\n    }\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/utils/image-upload.ts",
      "content": "/**\n * Image Upload Utilities\n *\n * Mock implementation for image upload functionality\n * In production, this would call your actual API endpoint\n */\n\n/**\n * Mock image URLs for testing\n */\nconst MOCK_IMAGES = [\n  \"https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80\",\n  \"https://images.unsplash.com/photo-1469474968028-56623f02e42e?w=800&q=80\",\n  \"https://images.unsplash.com/photo-1501785888041-af3ef285b470?w=800&q=80\",\n  \"https://images.unsplash.com/photo-1511884642898-4c92249e20b6?w=800&q=80\",\n  \"https://images.unsplash.com/photo-1418065460487-3e41a6c84dc5?w=800&q=80\",\n  \"https://images.unsplash.com/photo-1472214103451-9374bd1c798e?w=800&q=80\",\n]\n\nexport interface UploadResult {\n  success: boolean\n  url?: string\n  error?: string\n}\n\n/**\n * Mock function to simulate image upload to server\n *\n * @param file - The image file to upload\n * @returns Promise with upload result containing the image URL\n *\n * @example\n * ```typescript\n * const result = await uploadImage(file);\n * if (result.success) {\n *\n * }\n * ```\n */\nexport async function uploadImage(file: File): Promise<UploadResult> {\n  // Simulate network delay (500ms - 1500ms)\n  const delay = Math.random() * 1000 + 500\n  await new Promise((resolve) => setTimeout(resolve, delay))\n\n  // Validate file type\n  if (!file.type.startsWith(\"image/\")) {\n    return {\n      success: false,\n      error: \"File must be an image\",\n    }\n  }\n\n  // Validate file size (max 10MB)\n  const maxSize = 10 * 1024 * 1024 // 10MB\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"Image must be smaller than 10MB\",\n    }\n  }\n\n  // Simulate 5% chance of upload failure for testing\n  if (Math.random() < 0.05) {\n    return {\n      success: false,\n      error: \"Upload failed. Please try again.\",\n    }\n  }\n\n  // Return a random mock image URL\n  const randomIndex = Math.floor(Math.random() * MOCK_IMAGES.length)\n  const url = MOCK_IMAGES[randomIndex]\n\n  return {\n    success: true,\n    url,\n  }\n}\n\n/**\n * In production, replace the above mock function with actual API call:\n *\n * export async function uploadImage(file: File): Promise<UploadResult> {\n *   const formData = new FormData();\n *   formData.append('image', file);\n *\n *   try {\n *     const response = await fetch('/api/upload', {\n *       method: 'POST',\n *       body: formData,\n *     });\n *\n *     if (!response.ok) {\n *       throw new Error('Upload failed');\n *     }\n *\n *     const data = await response.json();\n *     return {\n *       success: true,\n *       url: data.url,\n *     };\n *   } catch (error) {\n *     return {\n *       success: false,\n *       error: error instanceof Error ? error.message : 'Upload failed',\n *     };\n *   }\n * }\n */\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/utils/inline-formatting.ts",
      "content": "/**\n * Inline Formatting Utilities\n *\n * Functions for splitting text nodes and applying inline formatting\n */\n\nimport { getNodeTextContent, hasInlineChildren, TextNode } from \"../types\"\n\n/**\n * Split a text node into inline segments based on selection range\n *\n * @param node - The node to split\n * @param startOffset - Start offset of selection\n * @param endOffset - End offset of selection\n * @returns Array of text segments: [before, selected, after]\n *\n * @example\n * ```typescript\n * const node = { id: 'p-1', type: 'p', content: 'Hello world' };\n * const [before, selected, after] = splitTextNode(node, 6, 11);\n * // before: 'Hello ', selected: 'world', after: ''\n * ```\n */\nexport function splitTextAtSelection(\n  content: string,\n  startOffset: number,\n  endOffset: number\n): { before: string; selected: string; after: string } {\n  return {\n    before: content.substring(0, startOffset),\n    selected: content.substring(startOffset, endOffset),\n    after: content.substring(endOffset),\n  }\n}\n\n/**\n * Convert a simple text node to inline children format\n *\n * @param node - The simple text node\n * @returns Node with inline children\n */\nexport function convertToInlineFormat(node: TextNode): TextNode {\n  if (hasInlineChildren(node)) {\n    return node // Already in inline format\n  }\n\n  const content = node.content || \"\"\n\n  return {\n    ...node,\n    content: undefined, // Remove content property\n    children: [\n      {\n        id: `${node.id}-text-${Date.now()}`,\n        type: \"text\",\n        content: content,\n      },\n    ],\n  }\n}\n\n/**\n * Apply formatting to a selection within a node\n *\n * @param node - The node to format\n * @param startOffset - Start offset of selection (in text content)\n * @param endOffset - End offset of selection (in text content)\n * @param className - Tailwind classes to apply\n * @returns New node with formatting applied\n */\nexport function applyFormatting(\n  node: TextNode,\n  startOffset: number,\n  endOffset: number,\n  className: string\n): TextNode {\n  // Convert to inline format if needed\n  const inlineNode = convertToInlineFormat(node)\n  const fullText = getNodeTextContent(inlineNode)\n\n  // Split the text\n  const { before, selected, after } = splitTextAtSelection(\n    fullText,\n    startOffset,\n    endOffset\n  )\n\n  // Build new children array\n  const newChildren: TextNode[] = []\n\n  // Add \"before\" text if it exists\n  if (before) {\n    newChildren.push({\n      id: `${node.id}-before-${Date.now()}`,\n      type: \"text\",\n      content: before,\n    })\n  }\n\n  // Add formatted selection as a span\n  if (selected) {\n    newChildren.push({\n      id: `${node.id}-span-${Date.now()}`,\n      type: \"span\",\n      content: selected,\n      attributes: {\n        className: className,\n      },\n    })\n  }\n\n  // Add \"after\" text if it exists\n  if (after) {\n    newChildren.push({\n      id: `${node.id}-after-${Date.now()}`,\n      type: \"text\",\n      content: after,\n    })\n  }\n\n  return {\n    ...inlineNode,\n    children: newChildren,\n  }\n}\n\n/**\n * Merge adjacent text nodes with the same formatting\n *\n * @param children - Array of inline text nodes\n * @returns Merged array\n */\nexport function mergeAdjacentTextNodes(children: TextNode[]): TextNode[] {\n  if (children.length <= 1) return children\n\n  const merged: TextNode[] = []\n  let current = children[0]\n\n  for (let i = 1; i < children.length; i++) {\n    const next = children[i]\n\n    // Check if both are plain text nodes (not spans) with same attributes\n    if (\n      current.type === \"text\" &&\n      next.type === \"text\" &&\n      current.attributes?.className === next.attributes?.className\n    ) {\n      // Merge them\n      current = {\n        ...current,\n        content: (current.content || \"\") + (next.content || \"\"),\n      }\n    } else {\n      merged.push(current)\n      current = next\n    }\n  }\n\n  merged.push(current)\n  return merged\n}\n\n/**\n * Remove formatting from a selection\n *\n * @param node - The node with inline formatting\n * @param startOffset - Start offset of selection\n * @param endOffset - End offset of selection\n * @param className - Class name to remove\n * @returns New node with formatting removed\n */\nexport function removeFormatting(\n  node: TextNode,\n  startOffset: number,\n  endOffset: number,\n  className: string\n): TextNode {\n  if (!hasInlineChildren(node)) {\n    return node // Nothing to remove\n  }\n\n  // This is more complex - we need to traverse inline children\n  // and split spans that intersect with the selection\n  // For now, simplified implementation\n\n  return node\n}\n\n/**\n * Get the formatting at a specific cursor position\n *\n * @param node - The node to check\n * @param offset - Cursor position\n * @returns Array of class names at that position\n */\nexport function getFormattingAtPosition(\n  node: TextNode,\n  offset: number\n): string[] {\n  if (!hasInlineChildren(node)) {\n    return node.attributes?.className ? [String(node.attributes.className)] : []\n  }\n\n  let currentOffset = 0\n  for (const child of node.children!) {\n    const childLength = (child.content || \"\").length\n    if (offset >= currentOffset && offset <= currentOffset + childLength) {\n      return child.attributes?.className\n        ? [String(child.attributes.className)]\n        : []\n    }\n    currentOffset += childLength\n  }\n\n  return []\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/utils/markdown-table-parser.ts",
      "content": "/**\n * Markdown Table Parser\n *\n * Converts markdown table syntax to editor table structure\n */\n\nimport { StructuralNode, TextNode } from \"../types\"\n\n/**\n * Parse markdown table string into table structure\n *\n * @example\n * ```\n * | Header 1 | Header 2 |\n * |----------|----------|\n * | Cell 1   | Cell 2   |\n * ```\n */\nexport function parseMarkdownTable(markdown: string): {\n  success: boolean\n  table?: StructuralNode\n  error?: string\n} {\n  try {\n    // Split into lines and remove empty lines\n    const lines = markdown\n      .trim()\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter((line) => line.length > 0)\n\n    if (lines.length < 2) {\n      return {\n        success: false,\n        error: \"Table must have at least a header row and separator row\",\n      }\n    }\n\n    // Parse header row\n    const headerLine = lines[0]\n    if (!headerLine.startsWith(\"|\") || !headerLine.endsWith(\"|\")) {\n      return {\n        success: false,\n        error: \"Table rows must start and end with |\",\n      }\n    }\n\n    const headerCells = headerLine\n      .split(\"|\")\n      .slice(1, -1) // Remove first and last empty strings\n      .map((cell) => cell.trim())\n\n    if (headerCells.length === 0) {\n      return {\n        success: false,\n        error: \"Header row must have at least one column\",\n      }\n    }\n\n    // Check separator row\n    const separatorLine = lines[1]\n    if (!separatorLine.includes(\"---\") && !separatorLine.includes(\"-\")) {\n      return {\n        success: false,\n        error: \"Second row must be a separator (e.g., |---|---|)\",\n      }\n    }\n\n    // Parse body rows\n    const bodyLines = lines.slice(2)\n    const numCols = headerCells.length\n\n    // Validate all rows have same number of columns\n    for (let i = 0; i < bodyLines.length; i++) {\n      const cells = bodyLines[i]\n        .split(\"|\")\n        .slice(1, -1)\n        .map((cell) => cell.trim())\n\n      if (cells.length !== numCols) {\n        return {\n          success: false,\n          error: `Row ${i + 3} has ${cells.length} columns, expected ${numCols}`,\n        }\n      }\n    }\n\n    const timestamp = Date.now()\n\n    // Create header cells\n    const headerCellNodes: TextNode[] = headerCells.map((content, idx) => ({\n      id: `th-${timestamp}-${idx}`,\n      type: \"th\",\n      content: content || \"\",\n      attributes: {},\n    }))\n\n    // Create header row\n    const headerRow: StructuralNode = {\n      id: `tr-header-${timestamp}`,\n      type: \"tr\",\n      children: headerCellNodes,\n      attributes: {},\n    }\n\n    // Create thead\n    const thead: StructuralNode = {\n      id: `thead-${timestamp}`,\n      type: \"thead\",\n      children: [headerRow],\n      attributes: {},\n    }\n\n    // Create body rows\n    const bodyRows: StructuralNode[] = bodyLines.map((line, rowIdx) => {\n      const cells = line\n        .split(\"|\")\n        .slice(1, -1)\n        .map((cell) => cell.trim())\n\n      const cellNodes: TextNode[] = cells.map((content, colIdx) => ({\n        id: `td-${timestamp}-${rowIdx}-${colIdx}`,\n        type: \"td\",\n        content: content || \"\",\n        attributes: {},\n      }))\n\n      return {\n        id: `tr-${timestamp}-${rowIdx}`,\n        type: \"tr\",\n        children: cellNodes,\n        attributes: {},\n      }\n    })\n\n    // Create tbody\n    const tbody: StructuralNode = {\n      id: `tbody-${timestamp}`,\n      type: \"tbody\",\n      children: bodyRows,\n      attributes: {},\n    }\n\n    // Create table\n    const table: StructuralNode = {\n      id: `table-${timestamp}`,\n      type: \"table\",\n      children: [thead, tbody],\n      attributes: {},\n    }\n\n    return {\n      success: true,\n      table,\n    }\n  } catch (error) {\n    return {\n      success: false,\n      error:\n        error instanceof Error\n          ? error.message\n          : \"Failed to parse markdown table\",\n    }\n  }\n}\n\n/**\n * Validate if string looks like a markdown table\n */\nexport function isMarkdownTable(text: string): boolean {\n  const lines = text\n    .trim()\n    .split(\"\\n\")\n    .filter((line) => line.trim().length > 0)\n\n  if (lines.length < 2) return false\n\n  // Check if first line has pipes\n  if (!lines[0].includes(\"|\")) return false\n\n  // Check if second line is separator\n  const secondLine = lines[1]\n  return (\n    secondLine.includes(\"---\") ||\n    (secondLine.includes(\"-\") && secondLine.includes(\"|\"))\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/utils/serialize-to-html.ts",
      "content": "/**\n * Serialize Editor State to HTML\n *\n * Converts the editor's state container to HTML with Tailwind classes\n * Output matches exactly what the editor displays visually\n * Supports recursive rendering of nested containers\n */\n\nimport {\n  ContainerNode,\n  EditorNode,\n  hasInlineChildren,\n  isContainerNode,\n  isStructuralNode,\n  isTextNode,\n  StructuralNode,\n  TextNode,\n} from \"../types\"\n\n/**\n * Get Tailwind CSS classes for block-level element types\n */\nfunction getBlockTypeClasses(type: string): string {\n  switch (type) {\n    case \"h1\":\n      return \"text-5xl font-extrabold text-foreground leading-[1.2]\"\n    case \"h2\":\n      return \"text-4xl font-bold text-foreground leading-[1.2]\"\n    case \"h3\":\n      return \"text-3xl font-semibold text-foreground leading-[1.3]\"\n    case \"h4\":\n      return \"text-2xl font-semibold text-foreground leading-[1.3]\"\n    case \"h5\":\n      return \"text-xl font-semibold text-foreground leading-[1.4]\"\n    case \"h6\":\n      return \"text-lg font-semibold text-foreground leading-[1.4]\"\n    case \"p\":\n      return \"text-lg text-foreground leading-relaxed\"\n    case \"li\":\n      return \"text-lg text-foreground leading-relaxed\"\n    case \"blockquote\":\n      return \"text-xl text-muted-foreground italic border-l-4 border-primary pl-6 py-2\"\n    case \"code\":\n      return \"font-mono text-base bg-secondary text-secondary-foreground px-2 py-0.5 rounded\"\n    case \"br\":\n      return \"\"\n    default:\n      return \"text-lg text-foreground leading-relaxed\"\n  }\n}\n\n/**\n * Get Tailwind CSS classes for inline element types (when used within text)\n */\nfunction getInlineElementTypeClasses(elementType: string): string {\n  switch (elementType) {\n    case \"h1\":\n      return \"text-5xl font-extrabold text-foreground leading-[1.2]\"\n    case \"h2\":\n      return \"text-4xl font-bold text-foreground leading-[1.2]\"\n    case \"h3\":\n      return \"text-3xl font-semibold text-foreground leading-[1.3]\"\n    case \"h4\":\n      return \"text-2xl font-semibold text-foreground leading-[1.3]\"\n    case \"h5\":\n      return \"text-xl font-semibold text-foreground leading-[1.4]\"\n    case \"h6\":\n      return \"text-lg font-semibold text-foreground leading-[1.4]\"\n    case \"code\":\n      return \"font-mono text-base bg-secondary text-secondary-foreground px-2 py-0.5 rounded\"\n    case \"blockquote\":\n      return \"text-xl text-muted-foreground italic border-l-4 border-primary pl-6 py-2\"\n    default:\n      return \"\"\n  }\n}\n\n/**\n * Build inline formatting classes (bold, italic, underline)\n */\nfunction getInlineFormattingClasses(\n  bold?: boolean,\n  italic?: boolean,\n  underline?: boolean\n): string {\n  const classes: string[] = []\n\n  if (bold) classes.push(\"font-bold\")\n  if (italic) classes.push(\"italic\")\n  if (underline) classes.push(\"underline\")\n\n  return classes.join(\" \")\n}\n\n/**\n * Escape HTML special characters\n */\nfunction escapeHtml(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\")\n}\n\n/**\n * Serialize a text node with inline children (formatted content)\n */\nfunction serializeInlineChildren(node: TextNode): string {\n  if (!hasInlineChildren(node)) {\n    return escapeHtml(node.content || \"\")\n  }\n\n  return node\n    .children!.map((child) => {\n      const formattingClasses = getInlineFormattingClasses(\n        child.bold,\n        child.italic,\n        child.underline\n      )\n\n      const elementTypeClasses = child.elementType\n        ? getInlineElementTypeClasses(child.elementType)\n        : \"\"\n\n      // Build inline styles from the styles object\n      let inlineStyles = \"\"\n      if (child.styles) {\n        inlineStyles =\n          Object.entries(child.styles)\n            .map(([key, value]) => {\n              // Convert camelCase to kebab-case (fontSize -> font-size)\n              const kebabKey = key.replace(/([A-Z])/g, \"-$1\").toLowerCase()\n              return `${kebabKey}: ${value}`\n            })\n            .join(\"; \") + \";\"\n      }\n\n      const allClasses = [\n        elementTypeClasses,\n        formattingClasses,\n        child.className,\n      ]\n        .filter(Boolean)\n        .join(\" \")\n\n      const content = escapeHtml(child.content || \"\")\n\n      // If it's a link\n      if (child.href) {\n        const linkClasses = [\n          \"text-primary hover:underline cursor-pointer\",\n          allClasses,\n        ]\n          .filter(Boolean)\n          .join(\" \")\n        const italicSpacing = child.italic ? \"inline-block pr-1\" : \"\"\n        const finalClasses = [linkClasses, italicSpacing]\n          .filter(Boolean)\n          .join(\" \")\n        const styleAttr = inlineStyles ? ` style=\"${inlineStyles}\"` : \"\"\n        return `<a href=\"${escapeHtml(child.href)}\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"${finalClasses}\"${styleAttr}>${content}</a>`\n      }\n\n      if (allClasses || inlineStyles) {\n        // Add inline-block pr-1 for italic text to prevent overlapping\n        const italicSpacing = child.italic ? \"inline-block pr-1\" : \"\"\n        const finalClasses = [allClasses, italicSpacing]\n          .filter(Boolean)\n          .join(\" \")\n        const classAttr = finalClasses ? ` class=\"${finalClasses}\"` : \"\"\n        const styleAttr = inlineStyles ? ` style=\"${inlineStyles}\"` : \"\"\n        return `<span${classAttr}${styleAttr}>${content}</span>`\n      }\n\n      return content\n    })\n    .join(\"\")\n}\n\n/**\n * Serialize a single text node to HTML\n */\nfunction serializeTextNode(node: TextNode, indent: string = \"\"): string {\n  const { type, attributes } = node\n\n  // Handle BR elements\n  if (type === \"br\") {\n    return `${indent}<br />\\n`\n  }\n\n  // Handle image nodes\n  if (type === \"img\") {\n    const src = (attributes?.src as string) || \"\"\n    const alt = (attributes?.alt as string) || \"\"\n    const caption = node.content || \"\"\n\n    let html = `${indent}<figure class=\"mb-4\">\\n`\n    html += `${indent}  <img src=\"${escapeHtml(src)}\" alt=\"${escapeHtml(alt)}\" class=\"h-auto rounded-lg object-cover max-h-[600px]\" style=\"width: auto; margin: auto;\" />\\n`\n\n    if (caption) {\n      html += `${indent}  <figcaption class=\"text-sm text-muted-foreground text-center mt-3 italic\">${escapeHtml(caption)}</figcaption>\\n`\n    }\n\n    html += `${indent}</figure>\\n`\n    return html\n  }\n\n  // Get block-level classes\n  const blockClasses = getBlockTypeClasses(type)\n\n  // Get custom className from attributes\n  const customClassName = (attributes?.className as string) || \"\"\n\n  // Check if className is a hex color (starts with #)\n  const isHexColor =\n    typeof customClassName === \"string\" && customClassName.startsWith(\"#\")\n  const textColor = isHexColor ? customClassName : \"\"\n  const className = isHexColor ? \"\" : customClassName\n\n  // Combine all classes\n  const allClasses = [blockClasses, className].filter(Boolean).join(\" \")\n\n  // Get backgroundColor from attributes\n  const backgroundColor = attributes?.backgroundColor as string | undefined\n\n  // Build inline styles\n  const styles: string[] = []\n  if (backgroundColor) {\n    styles.push(`background-color: ${backgroundColor}`)\n  }\n  if (textColor) {\n    styles.push(`color: ${textColor}`)\n  }\n\n  const styleAttr = styles.length > 0 ? ` style=\"${styles.join(\"; \")};\"` : \"\"\n\n  // Get content (with inline formatting if present)\n  const content = serializeInlineChildren(node)\n\n  // Check if the block is empty (no content and no inline children with content)\n  const isEmpty = !content || content.trim() === \"\"\n\n  // If empty, render as <br/> tag\n  if (isEmpty) {\n    return `${indent}<br />\\n`\n  }\n\n  // Build the HTML element\n  const classAttr = allClasses ? ` class=\"${allClasses}\"` : \"\"\n\n  // Use appropriate HTML tag\n  const tag = type === \"code\" ? \"code\" : type\n\n  return `${indent}<${tag}${classAttr}${styleAttr}>${content}</${tag}>\\n`\n}\n\n/**\n * Serialize a table node to HTML\n */\nfunction serializeTableNode(\n  node: StructuralNode | ContainerNode,\n  indent: string = \"\"\n): string {\n  // This function handles table, thead, tbody, tr, th, td nodes\n  const tag = node.type\n\n  if (tag === \"table\") {\n    let html = `${indent}<table class=\"border-collapse border border-border w-full\">\\n`\n\n    // Serialize children (thead, tbody)\n    for (const child of node.children) {\n      if (isStructuralNode(child)) {\n        html += serializeTableNode(child, indent + \"  \")\n      }\n    }\n\n    html += `${indent}</table>\\n`\n    return html\n  } else if (tag === \"thead\") {\n    let html = `${indent}<thead>\\n`\n\n    // Serialize children (tr)\n    for (const child of node.children) {\n      if (isStructuralNode(child)) {\n        html += serializeTableNode(child, indent + \"  \")\n      }\n    }\n\n    html += `${indent}</thead>\\n`\n    return html\n  } else if (tag === \"tbody\") {\n    let html = `${indent}<tbody>\\n`\n\n    // Serialize children (tr)\n    for (const child of node.children) {\n      if (isStructuralNode(child)) {\n        html += serializeTableNode(child, indent + \"  \")\n      }\n    }\n\n    html += `${indent}</tbody>\\n`\n    return html\n  } else if (tag === \"tr\") {\n    let html = `${indent}<tr>\\n`\n\n    // Serialize children (th, td)\n    for (const child of node.children) {\n      if (isTextNode(child)) {\n        const cellNode = child as TextNode\n        const cellTag = cellNode.type // 'th' or 'td'\n        const content = escapeHtml(cellNode.content || \"\")\n        const cellClass =\n          cellTag === \"th\"\n            ? \"border border-border bg-muted/50 p-2 font-semibold text-left min-w-[100px]\"\n            : \"border border-border p-2\"\n        html += `${indent}  <${cellTag} class=\"${cellClass}\">${content}</${cellTag}>\\n`\n      }\n    }\n\n    html += `${indent}</tr>\\n`\n    return html\n  }\n\n  return \"\"\n}\n\n/**\n * Serialize a container node to HTML (recursive)\n */\nfunction serializeContainerNode(\n  node: ContainerNode,\n  indent: string = \"\"\n): string {\n  // Check if this is a table wrapper container\n  const firstChild = node.children[0]\n  const isTableWrapper = firstChild?.type === \"table\"\n\n  if (isTableWrapper && isStructuralNode(firstChild)) {\n    // Serialize the table directly\n    return serializeTableNode(firstChild, indent)\n  }\n\n  // Check if this is a flex container for images\n  const layoutType = node.attributes?.layoutType as string | undefined\n  const isFlexContainer = layoutType === \"flex\"\n  const gap = node.attributes?.gap as string | undefined\n  const flexWrap = node.attributes?.flexWrap as string | undefined\n\n  // Determine container type and classes\n  const listTypeFromAttribute = node.attributes?.listType as string | undefined\n  const listType =\n    listTypeFromAttribute ||\n    (isTextNode(firstChild) && (firstChild as TextNode).type === \"li\"\n      ? \"ol\"\n      : undefined)\n  const isListContainer = !!listType\n\n  // Get custom className from attributes\n  const customClassName = (node.attributes?.className as string) || \"\"\n\n  // Build container classes matching the preview\n  let containerClasses = isFlexContainer\n    ? `flex flex-row gap-${gap || \"4\"} items-start ${flexWrap === \"wrap\" ? \"flex-wrap items-center\" : \"\"}`\n    : isListContainer\n      ? `list-none pl-0 ml-6`\n      : `nested-container border-l-2 border-border/50 pl-4 ml-2`\n\n  // Add custom classes\n  if (customClassName) {\n    containerClasses = `${containerClasses} ${customClassName}`.trim()\n  }\n\n  // Get backgroundColor from attributes\n  const backgroundColor = node.attributes?.backgroundColor as string | undefined\n\n  // Build inline styles\n  const styles: string[] = []\n  if (backgroundColor) {\n    styles.push(`background-color: ${backgroundColor}`)\n  }\n\n  const styleAttr = styles.length > 0 ? ` style=\"${styles.join(\"; \")};\"` : \"\"\n\n  // Use ul/ol for list containers, div for regular/flex containers\n  const containerTag =\n    listType === \"ul\" ? \"ul\" : listType === \"ol\" ? \"ol\" : \"div\"\n\n  let html = `${indent}<${containerTag} class=\"${containerClasses}\"${styleAttr}>\\n`\n\n  // Recursively serialize children\n  let i = 0\n  while (i < node.children.length) {\n    const child = node.children[i]\n\n    if (isTextNode(child)) {\n      const textNode = child as TextNode\n\n      // For flex containers, wrap each child in a flex item div\n      if (isFlexContainer) {\n        html += `${indent}  <div class=\"flex-1 min-w-[280px] max-w-full\">\\n`\n        html += serializeTextNode(textNode, indent + \"    \")\n        html += `${indent}  </div>\\n`\n        i++\n      }\n      // Check if this is the start of a list (and not already in a list container)\n      else if (textNode.type === \"li\" && !isListContainer) {\n        // Start ordered list\n        html += `${indent}  <ol class=\"list-decimal list-inside space-y-1\">\\n`\n\n        // Add all consecutive list items\n        while (i < node.children.length) {\n          const listItem = node.children[i]\n          if (isTextNode(listItem) && (listItem as TextNode).type === \"li\") {\n            const content = serializeInlineChildren(listItem as TextNode)\n            const isEmpty = !content || content.trim() === \"\"\n\n            if (!isEmpty) {\n              const liIndent = indent + \"    \"\n              const liClasses = getBlockTypeClasses(\"li\")\n              html += `${liIndent}<li class=\"${liClasses}\">${content}</li>\\n`\n            }\n            i++\n          } else {\n            break\n          }\n        }\n\n        // Close ordered list\n        html += `${indent}  </ol>\\n`\n      } else {\n        // Regular text node\n        html += serializeTextNode(textNode, indent + \"  \")\n        i++\n      }\n    } else if (isContainerNode(child)) {\n      // For flex containers, wrap nested containers in flex items\n      if (isFlexContainer) {\n        html += `${indent}  <div class=\"flex-1 min-w-[280px] max-w-full\">\\n`\n        html += serializeContainerNode(child as ContainerNode, indent + \"    \")\n        html += `${indent}  </div>\\n`\n        i++\n      } else {\n        // Nested container - recurse!\n        html += serializeContainerNode(child as ContainerNode, indent + \"  \")\n        i++\n      }\n    } else {\n      i++\n    }\n  }\n\n  html += `${indent}</${containerTag}>\\n`\n  return html\n}\n\n/**\n * Serialize any editor node (TextNode or ContainerNode) to HTML\n */\nfunction serializeEditorNode(node: EditorNode, indent: string = \"\"): string {\n  if (isContainerNode(node)) {\n    return serializeContainerNode(node as ContainerNode, indent)\n  }\n  return serializeTextNode(node as TextNode, indent)\n}\n\n/**\n * Serialize the entire container to HTML\n *\n * @param container - The root container node from editor state\n * @param options - Serialization options\n * @returns HTML string with Tailwind classes\n *\n * @example\n * ```typescript\n * const html = serializeToHtml(state.container);\n *\n * // Output:\n * // <div class=\"editor-content\">\n * //   <h1 class=\"text-5xl font-extrabold\">Title</h1>\n * //   <p class=\"text-lg\"><span class=\"font-bold\">Bold text</span></p>\n * // </div>\n * ```\n */\nexport function serializeToHtml(\n  container: ContainerNode,\n  options: {\n    wrapperClass?: string\n    includeWrapper?: boolean\n    indent?: string\n  } = {}\n): string {\n  const {\n    wrapperClass = \"editor-content\",\n    includeWrapper = true,\n    indent = \"  \",\n  } = options\n\n  let html = \"\"\n\n  // Add wrapper div if requested\n  if (includeWrapper) {\n    html += `<div class=\"${wrapperClass}\">\\n`\n  }\n\n  // Serialize each child node, grouping consecutive list items and handling containers\n  let i = 0\n  while (i < container.children.length) {\n    const child = container.children[i]\n\n    if (isTextNode(child)) {\n      const textNode = child as TextNode\n\n      // Check if this is the start of a list\n      if (textNode.type === \"li\") {\n        // Start ordered list\n        html += `${includeWrapper ? indent : \"\"}<ol class=\"list-decimal list-inside space-y-1\">\\n`\n\n        // Add all consecutive list items\n        while (i < container.children.length) {\n          const listItem = container.children[i]\n          if (isTextNode(listItem) && (listItem as TextNode).type === \"li\") {\n            const content = serializeInlineChildren(listItem as TextNode)\n            const isEmpty = !content || content.trim() === \"\"\n\n            if (!isEmpty) {\n              const liIndent = includeWrapper ? indent + \"  \" : \"  \"\n              const liClasses = getBlockTypeClasses(\"li\")\n              html += `${liIndent}<li class=\"${liClasses}\">${content}</li>\\n`\n            }\n            i++\n          } else {\n            break\n          }\n        }\n\n        // Close ordered list\n        html += `${includeWrapper ? indent : \"\"}</ol>\\n`\n      } else {\n        // Regular text node (not a list item)\n        html += serializeTextNode(textNode, includeWrapper ? indent : \"\")\n        i++\n      }\n    } else if (isContainerNode(child)) {\n      // Nested container - recurse!\n      html += serializeContainerNode(\n        child as ContainerNode,\n        includeWrapper ? indent : \"\"\n      )\n      i++\n    } else {\n      i++\n    }\n  }\n\n  // Close wrapper div\n  if (includeWrapper) {\n    html += `</div>\\n`\n  }\n\n  return html\n}\n\n/**\n * Serialize to HTML without wrapper div\n */\nexport function serializeToHtmlFragment(container: ContainerNode): string {\n  return serializeToHtml(container, { includeWrapper: false, indent: \"\" })\n}\n\n/**\n * Serialize to HTML with custom wrapper class\n */\nexport function serializeToHtmlWithClass(\n  container: ContainerNode,\n  wrapperClass: string\n): string {\n  return serializeToHtml(container, { wrapperClass })\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/utils/tree-operations.ts",
      "content": "/**\n * Mina Rich Editor - Tree Operations Utilities\n *\n * Recursive utilities for traversing, searching, and manipulating\n * the document tree structure immutably.\n *\n * @packageDocumentation\n */\n\nimport {\n  ContainerNode,\n  EditorNode,\n  isContainerNode,\n  isStructuralNode,\n  StructuralNode,\n} from \"../types\"\n\n/**\n * Recursively finds a node by its ID in the tree.\n *\n * @param node - The root node to start searching from\n * @param targetId - The ID of the node to find\n * @returns The found node or undefined if not found\n *\n * @example\n * ```typescript\n * const found = findNodeById(rootContainer, 'paragraph-123');\n * if (found) {\n *\n * }\n * ```\n */\nexport function findNodeById(\n  node: EditorNode,\n  targetId: string\n): EditorNode | undefined {\n  // Base case: current node matches\n  if (node.id === targetId) {\n    return node\n  }\n\n  // Recursive case: search children if it's a container or structural node\n  if (isContainerNode(node) || isStructuralNode(node)) {\n    for (const child of node.children) {\n      const found = findNodeById(child, targetId)\n      if (found) {\n        return found\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Finds the parent container of a node with the given ID.\n * Useful for operations that need to modify the parent.\n *\n * @param node - The root node to start searching from\n * @param targetId - The ID of the child node\n * @returns The parent ContainerNode or undefined if not found\n *\n * @example\n * ```typescript\n * const parent = findParentById(rootContainer, 'child-node-id');\n * if (parent) {\n *\n * }\n * ```\n */\nexport function findParentById(\n  node: EditorNode,\n  targetId: string\n): ContainerNode | StructuralNode | undefined {\n  if (!isContainerNode(node) && !isStructuralNode(node)) {\n    return undefined\n  }\n\n  // Check if target is a direct child\n  for (const child of node.children) {\n    if (child.id === targetId) {\n      return node\n    }\n  }\n\n  // Recursively search in children\n  for (const child of node.children) {\n    if (isContainerNode(child) || isStructuralNode(child)) {\n      const found = findParentById(child, targetId)\n      if (found) {\n        return found\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Updates a node immutably by ID with a partial update.\n * Returns a new tree with the updated node.\n *\n * @param node - The root node\n * @param targetId - The ID of the node to update\n * @param updater - Function that receives the old node and returns updates\n * @returns A new tree with the node updated, or the original if not found\n *\n * @example\n * ```typescript\n * const newTree = updateNodeById(root, 'p-1', (node) => ({\n *   content: 'Updated content',\n *   attributes: { ...node.attributes, className: 'highlight' }\n * }));\n * ```\n */\nexport function updateNodeById(\n  node: EditorNode,\n  targetId: string,\n  updater: (node: EditorNode) => Partial<EditorNode>\n): EditorNode {\n  // Base case: found the target node\n  if (node.id === targetId) {\n    const updates = updater(node)\n    return { ...node, ...updates } as EditorNode\n  }\n\n  // Recursive case: update children if it's a container or structural node\n  if (isContainerNode(node) || isStructuralNode(node)) {\n    const newChildren = node.children.map((child) =>\n      updateNodeById(child, targetId, updater)\n    )\n\n    // Only create new object if children actually changed\n    const childrenChanged = newChildren.some(\n      (newChild, index) => newChild !== node.children[index]\n    )\n\n    if (childrenChanged) {\n      return {\n        ...node,\n        children: newChildren,\n      }\n    }\n  }\n\n  // No changes, return original node\n  return node\n}\n\n/**\n * Deletes a node by ID immutably.\n * Returns a new tree without the specified node.\n *\n * @param node - The root node\n * @param targetId - The ID of the node to delete\n * @returns A new tree without the deleted node\n *\n * @example\n * ```typescript\n * const newTree = deleteNodeById(root, 'paragraph-to-remove');\n * ```\n */\nexport function deleteNodeById(\n  node: EditorNode,\n  targetId: string\n): EditorNode | null {\n  // If this is the target node, signal deletion\n  if (node.id === targetId) {\n    return null\n  }\n\n  // If it's a container or structural node, filter out the target from children\n  if (isContainerNode(node) || isStructuralNode(node)) {\n    const newChildren = node.children\n      .map((child) => deleteNodeById(child, targetId))\n      .filter((child): child is EditorNode => child !== null)\n\n    // Only create new object if children changed\n    if (newChildren.length !== node.children.length) {\n      return {\n        ...node,\n        children: newChildren,\n      }\n    }\n  }\n\n  return node\n}\n\n/**\n * Position for inserting a node relative to another node.\n */\nexport type InsertPosition = \"before\" | \"after\" | \"prepend\" | \"append\"\n\n/**\n * Inserts a new node relative to a target node.\n *\n * @param root - The root node\n * @param targetId - The ID of the reference node\n * @param newNode - The node to insert\n * @param position - Where to insert relative to target ('before', 'after', 'prepend', 'append')\n * @returns A new tree with the node inserted\n *\n * @example\n * ```typescript\n * // Insert after a specific paragraph\n * const newTree = insertNode(root, 'p-1', newParagraph, 'after');\n *\n * // Prepend to a container\n * const newTree = insertNode(root, 'container-1', newHeading, 'prepend');\n * ```\n */\nexport function insertNode(\n  root: EditorNode,\n  targetId: string,\n  newNode: EditorNode,\n  position: InsertPosition\n): EditorNode {\n  // For 'prepend' and 'append', insert inside the target container\n  if (position === \"prepend\" || position === \"append\") {\n    return updateNodeById(root, targetId, (node) => {\n      if (!isContainerNode(node) && !isStructuralNode(node)) {\n        console.warn(\n          `Cannot ${position} to non-container/structural node ${targetId}`\n        )\n        return {}\n      }\n\n      return {\n        children:\n          position === \"prepend\"\n            ? [newNode, ...node.children]\n            : [...node.children, newNode],\n      }\n    })\n  }\n\n  // For 'before' and 'after', insert as sibling\n  // We need to find the parent and insert at the right position\n  return insertNodeRecursive(root, targetId, newNode, position)\n}\n\n/**\n * Helper function for inserting nodes as siblings.\n * @internal\n */\nfunction insertNodeRecursive(\n  node: EditorNode,\n  targetId: string,\n  newNode: EditorNode,\n  position: \"before\" | \"after\"\n): EditorNode {\n  if (!isContainerNode(node) && !isStructuralNode(node)) {\n    return node\n  }\n\n  // Check if target is a direct child\n  const targetIndex = node.children.findIndex((child) => child.id === targetId)\n\n  if (targetIndex !== -1) {\n    // Found the target, insert the new node\n    const newChildren = [...node.children]\n    const insertIndex = position === \"before\" ? targetIndex : targetIndex + 1\n    newChildren.splice(insertIndex, 0, newNode)\n\n    return {\n      ...node,\n      children: newChildren,\n    }\n  }\n\n  // Recursively search in children\n  const newChildren = node.children.map((child) =>\n    insertNodeRecursive(child, targetId, newNode, position)\n  )\n\n  // Only create new object if children changed\n  const childrenChanged = newChildren.some(\n    (newChild, index) => newChild !== node.children[index]\n  )\n\n  if (childrenChanged) {\n    return {\n      ...node,\n      children: newChildren,\n    }\n  }\n\n  return node\n}\n\n/**\n * Moves a node to a new position in the tree.\n *\n * @param root - The root node\n * @param nodeId - The ID of the node to move\n * @param targetId - The ID of the reference node\n * @param position - Where to move relative to target\n * @returns A new tree with the node moved\n *\n * @example\n * ```typescript\n * // Move paragraph-2 before paragraph-1\n * const newTree = moveNode(root, 'p-2', 'p-1', 'before');\n * ```\n */\nexport function moveNode(\n  root: EditorNode,\n  nodeId: string,\n  targetId: string,\n  position: InsertPosition\n): EditorNode {\n  // Cannot move a node to itself\n  if (nodeId === targetId) {\n    console.warn(\"Cannot move a node to itself\")\n    return root\n  }\n\n  // Find the node to move\n  const nodeToMove = findNodeById(root, nodeId)\n  if (!nodeToMove) {\n    console.warn(`Node ${nodeId} not found`)\n    return root\n  }\n\n  // Verify target exists\n  const targetNode = findNodeById(root, targetId)\n  if (!targetNode) {\n    console.warn(`Target node ${targetId} not found`)\n    return root\n  }\n\n  // First, remove the node from its current position\n  const treeWithoutNode = deleteNodeById(root, nodeId)\n  if (!treeWithoutNode) {\n    return root\n  }\n\n  // Then, insert it at the new position\n  return insertNode(treeWithoutNode, targetId, nodeToMove, position)\n}\n\n/**\n * Deep clones a node (and all its children if it's a container).\n * Useful for duplicating content.\n *\n * @param node - The node to clone\n * @param newId - Optional new ID for the cloned node\n * @returns A deep clone of the node\n *\n * @example\n * ```typescript\n * const clone = cloneNode(originalNode, 'new-unique-id');\n * ```\n */\nexport function cloneNode(node: EditorNode, newId?: string): EditorNode {\n  const cloned: EditorNode = {\n    ...node,\n    id: newId || `${node.id}-clone-${Date.now()}`,\n  }\n\n  if (\n    (isContainerNode(cloned) || isStructuralNode(cloned)) &&\n    (isContainerNode(node) || isStructuralNode(node))\n  ) {\n    cloned.children = node.children.map((child) => cloneNode(child))\n  }\n\n  return cloned\n}\n\n/**\n * Traverses the tree and calls a callback for each node.\n * Useful for analytics, validation, or batch operations.\n *\n * @param node - The root node to traverse\n * @param callback - Function called for each node\n * @param depth - Current depth (starts at 0)\n *\n * @example\n * ```typescript\n * // Count all nodes\n * let count = 0;\n * traverseTree(root, () => count++);\n *\n *\n * // Find all images\n * const images: TextNode[] = [];\n * traverseTree(root, (node) => {\n *   if (node.type === 'img') images.push(node as TextNode);\n * });\n * ```\n */\nexport function traverseTree(\n  node: EditorNode,\n  callback: (node: EditorNode, depth: number) => void,\n  depth: number = 0\n): void {\n  callback(node, depth)\n\n  if (isContainerNode(node) || isStructuralNode(node)) {\n    for (const child of node.children) {\n      traverseTree(child, callback, depth + 1)\n    }\n  }\n}\n\n/**\n * Validates the tree structure.\n * Checks for duplicate IDs, orphaned nodes, etc.\n *\n * @param node - The root node to validate\n * @returns Validation result with errors if any\n *\n * @example\n * ```typescript\n * const result = validateTree(root);\n * if (!result.valid) {\n *   console.error('Tree validation errors:', result.errors);\n * }\n * ```\n */\nexport function validateTree(node: EditorNode): {\n  valid: boolean\n  errors: string[]\n} {\n  const errors: string[] = []\n  const seenIds = new Set<string>()\n\n  traverseTree(node, (currentNode) => {\n    // Check for duplicate IDs\n    if (seenIds.has(currentNode.id)) {\n      errors.push(`Duplicate ID found: ${currentNode.id}`)\n    }\n    seenIds.add(currentNode.id)\n\n    // Check for empty IDs\n    if (!currentNode.id || currentNode.id.trim() === \"\") {\n      errors.push(\"Node found with empty or missing ID\")\n    }\n\n    // Check for invalid container/structural node children\n    if (\n      (isContainerNode(currentNode) || isStructuralNode(currentNode)) &&\n      !Array.isArray(currentNode.children)\n    ) {\n      errors.push(\n        `Container/Structural node ${currentNode.id} has invalid children property`\n      )\n    }\n  })\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/hooks/use-toast.ts",
      "content": "/**\n * Toast Hook\n *\n * Simple wrapper around sonner toast notifications\n */\n\nimport { toast as sonnerToast } from \"sonner\"\n\nexport interface ToastProps {\n  title?: string\n  description?: string\n  variant?: \"default\" | \"destructive\"\n}\n\nexport function useToast() {\n  const toast = ({ title, description, variant }: ToastProps) => {\n    if (variant === \"destructive\") {\n      sonnerToast.error(title, {\n        description,\n      })\n    } else {\n      sonnerToast.success(title, {\n        description,\n      })\n    }\n  }\n\n  return { toast }\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/hooks/use-mobile.ts",
      "content": "import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/rich-editor/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:ui"
    }
  ]
}