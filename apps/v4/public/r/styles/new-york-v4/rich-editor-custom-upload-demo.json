{
  "$schema": "https://ui-v4-livid.vercel.app/schema/registry-item.json",
  "name": "rich-editor-custom-upload-demo",
  "type": "registry:example",
  "registryDependencies": [
    "rich-editor"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/examples/rich-editor-custom-upload-demo.tsx",
      "content": "\"use client\"\n\nimport type { ContainerNode } from \"../ui/rich-editor\"\nimport { EditorProvider } from \"../ui/rich-editor\"\nimport { createDemoContent } from \"../ui/rich-editor/demo-content\"\nimport { Editor } from \"../ui/rich-editor/editor\"\n\nexport default function RichEditorCustomUploadDemo() {\n  const initialContainer: ContainerNode = {\n    id: \"root\",\n    type: \"container\",\n    children: createDemoContent(),\n    attributes: {},\n  }\n\n  // Example custom upload handler for both images and videos\n  const handleUpload = async (file: File): Promise<string> => {\n    // Simulate upload delay\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n\n    // In production, you would:\n    // 1. Upload to your backend API\n    // 2. Return the permanent URL\n    // Example:\n    // const formData = new FormData();\n    // formData.append('file', file);\n    // const response = await fetch('/api/upload', {\n    //   method: 'POST',\n    //   body: formData\n    // });\n    // const data = await response.json();\n    // return data.url;\n\n    // For demo purposes, return a data URL\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader()\n      reader.onload = () => resolve(reader.result as string)\n      reader.onerror = reject\n      reader.readAsDataURL(file)\n    })\n  }\n\n  return (\n    <div className=\"mx-auto w-full overflow-y-auto\">\n      <EditorProvider initialContainer={initialContainer}>\n        <Editor notionBased onUploadImage={handleUpload} />\n      </EditorProvider>\n    </div>\n  )\n}\n",
      "type": "registry:example"
    }
  ]
}